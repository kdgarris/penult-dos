------- FILE test320c.78b.asm LEVEL 1 PASS 3
      1  10000 ????						; MACRO.H
      2  10000 ????
      3  10000 ????						; Based on the 2600 macro.h file.
      4  10000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro
      5  10000 ????						; has been adapted to give accurate results on the 7800.
      6  10000 ????
      7  10000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  10000 ????
      9  10000 ????						; Available macros...
     10  10000 ????						;   SLEEP n		 - sleep for n cycles
     11  10000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  10000 ????
     13  10000 ????						;-------------------------------------------------------------------------------
     14  10000 ????						; SLEEP duration
     15  10000 ????						; Original author: Thomas Jentzsch
     16  10000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  10000 ????						; useful for code where precise timing is required.
     18  10000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  10000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  10000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  10000 ????
     22  10000 ????				       MAC	sleep
     23  10000 ????			    .CYCLES    SET	{1}
     24  10000 ????
     25  10000 ????				       IF	.CYCLES < 2
     26  10000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  10000 ????				       ERR
     28  10000 ????				       ENDIF
     29  10000 ????
     30  10000 ????				       IF	.CYCLES & 1
     31  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  10000 ????				       nop	$80
     33  10000 ????				       ELSE
     34  10000 ????				       bit	$80
     35  10000 ????				       ENDIF
     36  10000 ????			    .CYCLES    SET	.CYCLES - 3
     37  10000 ????				       ENDIF
     38  10000 ????
     39  10000 ????				       REPEAT	.CYCLES / 2
     40  10000 ????				       nop
     41  10000 ????				       REPEND
     42  10000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  10000 ????
     44  10000 ????
     45  10000 ????						;-------------------------------------------------------------------------------
     46  10000 ????						; FRACSLEEP duration
     47  10000 ????						; Based on Thomas Jentzsch's SLEEP macro, but takes cycles*2 to allow for
     48  10000 ????						; 7800 based 0.5 cycle sleep.
     49  10000 ????
     50  10000 ????				       MAC	fracsleep
     51  10000 ????			    .CYCLES    SET	{1}
     52  10000 ????
     53  10000 ????				       IF	.CYCLES < 4
     54  10000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration must be > 4"
     55  10000 ????				       ERR
     56  10000 ????				       ENDIF
     57  10000 ????				       IF	.CYCLES = 5
     58  10000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration = 5 is impossible"
     59  10000 ????				       ERR
     60  10000 ????				       ENDIF
     61  10000 ????
     62  10000 ????				       IF	.CYCLES & 1
     63  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     64  10000 ????				       nop	$0	; TIA access is 3.5 cycles
     65  10000 ????				       ELSE
     66  10000 ????				       bit	$0	; TIA access is 3.5 cycles
     67  10000 ????				       ENDIF
     68  10000 ????			    .CYCLES    SET	.CYCLES - 7
     69  10000 ????				       ENDIF
     70  10000 ????
     71  10000 ????				       IF	.CYCLES & 2
     72  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     73  10000 ????				       nop	$80
     74  10000 ????				       ELSE
     75  10000 ????				       bit	$80
     76  10000 ????				       ENDIF
     77  10000 ????			    .CYCLES    SET	.CYCLES - 6
     78  10000 ????				       ENDIF
     79  10000 ????
     80  10000 ????				       REPEAT	.CYCLES / 4
     81  10000 ????				       nop
     82  10000 ????				       REPEND
     83  10000 ????				       ENDM		;usage: FRACSLEEP n (n>1)
     84  10000 ????
     85  10000 ????
     86  10000 ????						;-------------------------------------------------------
     87  10000 ????						; SET_POINTER
     88  10000 ????						; Original author: Manuel Rotschkar
     89  10000 ????						;
     90  10000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     91  10000 ????						;
     92  10000 ????						; Usage: SET_POINTER pointer, address
     93  10000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     94  10000 ????						;
     95  10000 ????						; Note: Alters the accumulator, NZ flags
     96  10000 ????						; IN 1: 2 byte RAM location reserved for pointer
     97  10000 ????						; IN 2: absolute address
     98  10000 ????
     99  10000 ????				       MAC	set_pointer
    100  10000 ????			    .POINTER   SET	{1}
    101  10000 ????			    .ADDRESS   SET	{2}
    102  10000 ????
    103  10000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    104  10000 ????				       STA	.POINTER	; Store in pointer
    105  10000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    106  10000 ????				       STA	.POINTER+1	; Store in pointer+1
    107  10000 ????
    108  10000 ????				       ENDM
    109  10000 ????
    110  10000 ????						; EOF
    111  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    112  10000 ????
    113  10000 ????						; 7800MACRO.H
    114  10000 ????
    115  10000 ????						;-------------------------------------------------------
    116  10000 ????						; BOXCOLLISIONCHECK
    117  10000 ????						; author: Mike Saarna
    118  10000 ????						;
    119  10000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    120  10000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
    121  10000 ????						;
    122  10000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    123  10000 ????						;
    124  10000 ????
    125  10000 ????				       MAC	boxcollisioncheck
    126  10000 ????			    .boxx1     SET	{1}
    127  10000 ????			    .boxy1     SET	{2}
    128  10000 ????			    .boxw1     SET	{3}
    129  10000 ????			    .boxh1     SET	{4}
    130  10000 ????			    .boxx2     SET	{5}
    131  10000 ????			    .boxy2     SET	{6}
    132  10000 ????			    .boxw2     SET	{7}
    133  10000 ????			    .boxh2     SET	{8}
    134  10000 ????
    135  10000 ????			    .DoXCollisionCheck
    136  10000 ????				       lda	.boxx1	;3
    137  10000 ????				       cmp	.boxx2	;2
    138  10000 ????				       bcs	.X1isbiggerthanX2	;2/3
    139  10000 ????			    .X2isbiggerthanX1
    140  10000 ????				       adc	#.boxw1	;2
    141  10000 ????				       cmp	.boxx2	;3
    142  10000 ????				       bcs	.DoYCollisionCheck	;3/2
    143  10000 ????				       bcc	.noboxcollision	;3
    144  10000 ????			    .X1isbiggerthanX2
    145  10000 ????				       clc		;2
    146  10000 ????				       sbc	#.boxw2	;2
    147  10000 ????				       cmp	.boxx2	;3
    148  10000 ????				       bcs	.noboxcollision	;3/2
    149  10000 ????			    .DoYCollisionCheck
    150  10000 ????				       lda	.boxy1	;3
    151  10000 ????				       cmp	.boxy2	;3
    152  10000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    153  10000 ????			    .Y2isbiggerthanY1
    154  10000 ????				       adc	#.boxh1	;2
    155  10000 ????				       cmp	.boxy2	;3
    156  10000 ????				       jmp	.checkdone	;6
    157  10000 ????			    .Y1isbiggerthanY2
    158  10000 ????				       clc		;2
    159  10000 ????				       sbc	#.boxh2	;2
    160  10000 ????				       cmp	.boxy2	;3
    161  10000 ????				       bcs	.noboxcollision	;3/2
    162  10000 ????			    .boxcollision
    163  10000 ????				       sec		;2
    164  10000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    165  10000 ????			    .noboxcollision
    166  10000 ????				       clc		;2
    167  10000 ????			    .checkdone
    168  10000 ????
    169  10000 ????				       ENDM
    170  10000 ????
    171  10000 ????						; QBOXCOLLISIONCHECK
    172  10000 ????						; author: unknown
    173  10000 ????						;
    174  10000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    175  10000 ????						; and shape for overlap. Carry is CLEAR for collision detected, SET for none.
    176  10000 ????						;
    177  10000 ????						; Usage: QBOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    178  10000 ????						;
    179  10000 ????				       MAC	qboxcollisioncheck
    180  10000 ????			    .boxx1     SET	{1}
    181  10000 ????			    .boxy1     SET	{2}
    182  10000 ????			    .boxw1     SET	{3}
    183  10000 ????			    .boxh1     SET	{4}
    184  10000 ????			    .boxx2     SET	{5}
    185  10000 ????			    .boxy2     SET	{6}
    186  10000 ????			    .boxw2     SET	{7}
    187  10000 ????			    .boxh2     SET	{8}
    188  10000 ????
    189  10000 ????				       lda	.boxx2
    190  10000 ????				       clc
    191  10000 ????				       adc	#.boxw2
    192  10000 ????				       sbc	.boxx1
    193  10000 ????				       cmp	#.boxw1+.boxw2-1
    194  10000 ????				       bcs	.qboxcollisiondone
    195  10000 ????						;if we're here, carry is clear
    196  10000 ????				       lda	.boxy2
    197  10000 ????				       adc	#.boxh2
    198  10000 ????				       sbc	.boxy1
    199  10000 ????				       cmp	#.boxh1+.boxh2-1
    200  10000 ????			    .qboxcollisiondone
    201  10000 ????				       rol		; temp for testing - invert carry...
    202  10000 ????				       eor	#1
    203  10000 ????				       ror
    204  10000 ????				       ENDM
    205  10000 ????
    206  10000 ????
    207  10000 ????				       MAC	median3
    208  10000 ????
    209  10000 ????						; A median filter (for smoothing paddle jitter)
    210  10000 ????						;   this macro takes the current paddle value, compares it to historic
    211  10000 ????						;   values, and replaces the current paddle value with the median.
    212  10000 ????						;
    213  10000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    214  10000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    215  10000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    216  10000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    217  10000 ????						;	  the previous values, and update with the median value.
    218  10000 ????						;
    219  10000 ????						; returns: CURRENT (modified to contain median value)
    220  10000 ????						;
    221  10000 ????						; author: Mike Saarna (aka RevEng)
    222  10000 ????
    223  10000 ????			    .MedianBytes SET	{1}
    224  10000 ????			    .NewValue  SET	{2}
    225  10000 ????
    226  10000 ????				       lda	#0
    227  10000 ????				       ldy	.NewValue
    228  10000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    229  10000 ????
    230  10000 ????						; build an index from relative size comparisons between our 3 values.
    231  10000 ????				       cpy	.MedianBytes
    232  10000 ????				       rol
    233  10000 ????				       cpy	.MedianBytes+1
    234  10000 ????				       rol
    235  10000 ????				       ldy	.MedianBytes
    236  10000 ????				       cpy	.MedianBytes+1
    237  10000 ????				       rol
    238  10000 ????				       tay
    239  10000 ????
    240  10000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    241  10000 ????				       lda	.MedianBytes,x
    242  10000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    243  10000 ????
    244  10000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the
    245  10000 ????						; newest byte (.MedianBytes+2) empty for next time.
    246  10000 ????				       lda	.MedianBytes+1
    247  10000 ????				       sta	.MedianBytes
    248  10000 ????				       lda	.MedianBytes+2
    249  10000 ????				       sta	.MedianBytes+1
    250  10000 ????				       ifnconst	MedianOrderLUT
    251  10000 ????				       jmp	MedianOrderLUTend
    252  10000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    253  10000 ????				       .byte	0	; 0  B2 < B0 < B1
    254  10000 ????				       .byte	1	; 1  B2 < B1 < B0
    255  10000 ????				       .byte	2	; 2   impossible
    256  10000 ????				       .byte	2	; 3  B1 < B2 < B0
    257  10000 ????				       .byte	2	; 4  B0 < B2 < B1
    258  10000 ????				       .byte	2	; 5   impossible
    259  10000 ????				       .byte	1	; 6  B0 < B1 < B2
    260  10000 ????				       .byte	0	; 7  B1 < B0 < B2
    261  10000 ????			    MedianOrderLUTend
    262  10000 ????				       endif
    263  10000 ????				       ENDM
    264  10000 ????
    265  10000 ????				       MAC	plotsprite
    266  10000 ????
    267  10000 ????						; A macro version of the plotsprite command.
    268  10000 ????						; This trades off rom space for speed.
    269  10000 ????						; It also doesn't check if the visible screen is displayed or not.
    270  10000 ????						; It has no training wheels. It is all rusty sharp edges.
    271  10000 ????
    272  10000 ????			    .GFXLabel  SET	{1}
    273  10000 ????			    .Palette   SET	{2}	; constant
    274  10000 ????			    .SpriteX   SET	{3}	; variable
    275  10000 ????			    .SpriteY   SET	{4}	; variable
    276  10000 ????			    .ByteOffset SET	{5}	; variable
    277  10000 ????
    278  10000 ????				       lda	.SpriteY
    279  10000 ????				       lsr
    280  10000 ????				       lsr
    281  10000 ????				       asr	#%11111110	; ensure carry is clear
    282  10000 ????				       if	WZONEHEIGHT = 16
    283  10000 ????				       asr	#%11111110	; ensure carry is clear
    284  10000 ????				       endif
    285  10000 ????
    286  10000 ????				       tax
    287  10000 ????
    288  10000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    289  10000 ????				       sta	dlpnt
    290  10000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    291  10000 ????				       sta	dlpnt+1
    292  10000 ????
    293  10000 ????				       ldy	dlend,x	; find the next new object position in this zone
    294  10000 ????
    295  10000 ????				       lda	.ByteOffset
    296  10000 ????				       if	{1}_width = 2
    297  10000 ????				       asl
    298  10000 ????				       endif
    299  10000 ????				       if	{1}_width = 3
    300  10000 ????				       asl
    301  10000 ????				       adc	.ByteOffset
    302  10000 ????				       endif
    303  10000 ????				       if	{1}_width = 4
    304  10000 ????				       asl
    305  10000 ????				       asl
    306  10000 ????				       endif
    307  10000 ????				       if	{1}_width = 5
    308  10000 ????				       asl
    309  10000 ????				       asl
    310  10000 ????				       adc	.ByteOffset
    311  10000 ????				       endif
    312  10000 ????				       if	{1}_width = 6
    313  10000 ????				       asl
    314  10000 ????				       adc	.ByteOffset
    315  10000 ????				       asl
    316  10000 ????				       endif
    317  10000 ????				       if	{1}_width = 7
    318  10000 ????				       asl
    319  10000 ????				       adc	.ByteOffset
    320  10000 ????				       asl
    321  10000 ????				       adc	.ByteOffset
    322  10000 ????				       endif
    323  10000 ????				       if	{1}_width = 8
    324  10000 ????				       asl
    325  10000 ????				       asl
    326  10000 ????				       asl
    327  10000 ????				       endif
    328  10000 ????				       if	{1}_width = 9
    329  10000 ????				       asl
    330  10000 ????				       asl
    331  10000 ????				       asl
    332  10000 ????				       adc	.ByteOffset
    333  10000 ????				       endif
    334  10000 ????				       if	{1}_width = 10
    335  10000 ????				       asl
    336  10000 ????				       asl
    337  10000 ????				       adc	.ByteOffset
    338  10000 ????				       asl
    339  10000 ????				       endif
    340  10000 ????				       if	{1}_width = 11
    341  10000 ????				       asl
    342  10000 ????				       asl
    343  10000 ????				       adc	.ByteOffset
    344  10000 ????				       asl
    345  10000 ????				       adc	.ByteOffset
    346  10000 ????				       endif
    347  10000 ????				       if	{1}_width = 12
    348  10000 ????				       asl
    349  10000 ????				       adc	.ByteOffset
    350  10000 ????				       asl
    351  10000 ????				       asl
    352  10000 ????				       endif
    353  10000 ????				       if	{1}_width = 13
    354  10000 ????				       asl
    355  10000 ????				       adc	.ByteOffset
    356  10000 ????				       asl
    357  10000 ????				       asl
    358  10000 ????				       adc	.ByteOffset
    359  10000 ????				       endif
    360  10000 ????				       if	{1}_width = 14
    361  10000 ????				       asl
    362  10000 ????				       adc	.ByteOffset
    363  10000 ????				       asl
    364  10000 ????				       adc	.ByteOffset
    365  10000 ????				       asl
    366  10000 ????				       endif
    367  10000 ????
    368  10000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    369  10000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    370  10000 ????
    371  10000 ????				       iny
    372  10000 ????
    373  10000 ????				       lda	#({1}_mode | %01000000)
    374  10000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    375  10000 ????
    376  10000 ????				       iny
    377  10000 ????
    378  10000 ????				       lda	.SpriteY
    379  10000 ????				       and	#(WZONEHEIGHT - 1)
    380  10000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    381  10000 ????				       ora	#>.GFXLabel
    382  10000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    383  10000 ????
    384  10000 ????				       iny
    385  10000 ????
    386  10000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    387  10000 ????				       sta	(dlpnt),y	; #4 - palette|width
    388  10000 ????
    389  10000 ????				       iny
    390  10000 ????
    391  10000 ????				       lda	.SpriteX
    392  10000 ????				       sta	(dlpnt),y	; #5 - x object position
    393  10000 ????
    394  10000 ????				       iny
    395  10000 ????				       sty	dlend,x
    396  10000 ????
    397  10000 ????				       ifconst	ALWAYSTERMINATE
    398  10000 ????				       iny
    399  10000 ????				       lda	#0
    400  10000 ????				       sta	(dlpnt),y
    401  10000 ????				       endif
    402  10000 ????
    403  10000 ????				       bcc	.PLOTSPRITEend
    404  10000 ????
    405  10000 ????				       inx		; next zone
    406  10000 ????
    407  10000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    408  10000 ????				       sta	dlpnt
    409  10000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    410  10000 ????				       sta	dlpnt+1
    411  10000 ????
    412  10000 ????				       ldy	dlend,x	; find the next new object position in this zone
    413  10000 ????
    414  10000 ????				       lda	.ByteOffset
    415  10000 ????				       if	{1}_width = 1
    416  10000 ????				       clc
    417  10000 ????				       endif
    418  10000 ????				       if	{1}_width = 2
    419  10000 ????				       asl		; carry clear
    420  10000 ????				       endif
    421  10000 ????				       if	{1}_width = 3
    422  10000 ????				       asl		; carry clear
    423  10000 ????				       adc	.ByteOffset
    424  10000 ????				       endif
    425  10000 ????				       if	{1}_width = 4
    426  10000 ????				       asl		; carry clear
    427  10000 ????				       asl
    428  10000 ????				       endif
    429  10000 ????				       if	{1}_width = 5
    430  10000 ????				       asl		; carry clear
    431  10000 ????				       asl
    432  10000 ????				       adc	.ByteOffset
    433  10000 ????				       endif
    434  10000 ????				       if	{1}_width = 6
    435  10000 ????				       asl		; carry clear
    436  10000 ????				       adc	.ByteOffset
    437  10000 ????				       asl
    438  10000 ????				       endif
    439  10000 ????				       if	{1}_width = 7
    440  10000 ????				       asl		; carry clear
    441  10000 ????				       adc	.ByteOffset
    442  10000 ????				       asl
    443  10000 ????				       endif
    444  10000 ????				       if	{1}_width = 8
    445  10000 ????				       asl		; carry clear
    446  10000 ????				       asl
    447  10000 ????				       asl
    448  10000 ????				       endif
    449  10000 ????				       if	{1}_width = 9
    450  10000 ????				       asl		; carry clear
    451  10000 ????				       asl
    452  10000 ????				       asl
    453  10000 ????				       adc	.ByteOffset
    454  10000 ????				       endif
    455  10000 ????				       if	{1}_width = 10
    456  10000 ????				       asl		; carry clear
    457  10000 ????				       asl
    458  10000 ????				       adc	.ByteOffset
    459  10000 ????				       asl
    460  10000 ????				       endif
    461  10000 ????				       if	{1}_width = 11
    462  10000 ????				       asl		; carry clear
    463  10000 ????				       asl
    464  10000 ????				       adc	.ByteOffset
    465  10000 ????				       asl
    466  10000 ????				       adc	.ByteOffset
    467  10000 ????				       endif
    468  10000 ????				       if	{1}_width = 12
    469  10000 ????				       asl		; carry clear
    470  10000 ????				       adc	.ByteOffset
    471  10000 ????				       asl
    472  10000 ????				       asl
    473  10000 ????				       endif
    474  10000 ????				       if	{1}_width = 13
    475  10000 ????				       asl		; carry clear
    476  10000 ????				       adc	.ByteOffset
    477  10000 ????				       asl
    478  10000 ????				       asl
    479  10000 ????				       adc	.ByteOffset
    480  10000 ????				       endif
    481  10000 ????				       if	{1}_width = 14
    482  10000 ????				       asl		; carry clear
    483  10000 ????				       adc	.ByteOffset
    484  10000 ????				       asl
    485  10000 ????				       adc	.ByteOffset
    486  10000 ????				       asl
    487  10000 ????				       endif
    488  10000 ????
    489  10000 ????				       adc	#<.GFXLabel
    490  10000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    491  10000 ????
    492  10000 ????				       iny
    493  10000 ????
    494  10000 ????				       lda	#({1}_mode | %01000000)
    495  10000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    496  10000 ????
    497  10000 ????				       iny
    498  10000 ????
    499  10000 ????				       lda	.SpriteY
    500  10000 ????				       and	#(WZONEHEIGHT - 1)
    501  10000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    502  10000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    503  10000 ????
    504  10000 ????				       iny
    505  10000 ????
    506  10000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    507  10000 ????				       sta	(dlpnt),y	; #4 - palette|width
    508  10000 ????
    509  10000 ????				       iny
    510  10000 ????
    511  10000 ????				       lda	.SpriteX
    512  10000 ????				       sta	(dlpnt),y	; #5 - x object position
    513  10000 ????
    514  10000 ????				       iny
    515  10000 ????				       sty	dlend,x
    516  10000 ????
    517  10000 ????				       ifconst	ALWAYSTERMINATE
    518  10000 ????				       iny
    519  10000 ????				       lda	#0
    520  10000 ????				       sta	(dlpnt),y
    521  10000 ????				       endif
    522  10000 ????
    523  10000 ????			    .PLOTSPRITEend
    524  10000 ????				       ENDM
    525  10000 ????
    526  10000 ????				       MAC	sizeof
    527  10000 ????
    528  10000 ????						; echo's the size difference between the current address and the
    529  10000 ????						; a label that was passed as an argument. This is a quick way to
    530  10000 ????						; determine the size of a structure.
    531  10000 ????
    532  10000 ????			    .NAME      SETSTR	{1}
    533  10000 ????				       echo	" The Size of",.NAME,"is:",[* - {1}]d,[* - {2}]d,"bytes."
    534  10000 ????				       ENDM
    535  10000 ????
    536  10000 ????						;
    537  10000 ????						; speakjet.inc
    538  10000 ????						;
    539  10000 ????						;
    540  10000 ????						; AtariVox Speech Synth Driver
    541  10000 ????						;
    542  10000 ????						; By Alex Herbert, 2004
    543  10000 ????						;
    544  10000 ????
    545  10000 ????
    546  10000 ????
    547  10000 ????
    548  10000 ????						; Constants
    549  10000 ????
    550  10000 ????
    551  10000 ????		00 01	    SERIAL_OUTMASK equ	$01
    552  10000 ????		00 02	    SERIAL_RDYMASK equ	$02
    553  10000 ????
    554  10000 ????
    555  10000 ????
    556  10000 ????						; Macros
    557  10000 ????
    558  10000 ????				       mac	spkout
    559  10000 ????
    560  10000 ????						; check buffer-full status
    561  10000 ????				       lda	SWCHA
    562  10000 ????				       and	#SERIAL_RDYMASK
    563  10000 ????				       beq	.speech_done
    564  10000 ????
    565  10000 ????						; get next speech byte
    566  10000 ????				       ldy	#$00
    567  10000 ????				       lda	(speech_addr),y
    568  10000 ????
    569  10000 ????						; invert data and check for end of string
    570  10000 ????				       eor	#$ff
    571  10000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
    572  10000 ????				       beq	.speech_done
    573  10000 ????				       sta	{1}
    574  10000 ????
    575  10000 ????						; increment speech pointer
    576  10000 ????				       inc	speech_addr
    577  10000 ????				       bne	.incaddr_skip
    578  10000 ????				       inc	speech_addr+1
    579  10000 ????			    .incaddr_skip
    580  10000 ????
    581  10000 ????						; output byte as serial data
    582  10000 ????
    583  10000 ????				       sec		; start bit
    584  10000 ????			    .byteout_loop
    585  10000 ????						; put carry flag into bit 0 of SWACNT, preserving other bits
    586  10000 ????				       lda	SWACNT	; 4
    587  10000 ????				       and	#$fe	; 2 6
    588  10000 ????				       adc	#$00	; 2 8
    589  10000 ????				       sta	SWACNT	; 4 12
    590  10000 ????
    591  10000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
    592  10000 ????				       cpy	#$09	; 2 14
    593  10000 ????				       beq	.speech_done	; 2 16
    594  10000 ????				       iny		; 2 18
    595  10000 ????
    596  10000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
    597  10000 ????						; to match the original baud rate...
    598  10000 ????						;ldx	  #$07 ; 2600
    599  10000 ????				       ldx	#$0D
    600  10000 ????
    601  10000 ????			    .delay_loop
    602  10000 ????				       dex		;
    603  10000 ????				       bne	.delay_loop	; 36 54
    604  10000 ????
    605  10000 ????						; shift next data bit into carry
    606  10000 ????				       lsr	{1}	; 5 59
    607  10000 ????
    608  10000 ????						; and loop (branch always taken)
    609  10000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
    610  10000 ????
    611  10000 ????			    .speech_done
    612  10000 ????
    613  10000 ????				       endm
    614  10000 ????
    615  10000 ????
    616  10000 ????				       mac	speak
    617  10000 ????
    618  10000 ????				       lda	#<{1}
    619  10000 ????				       sta	speech_addr
    620  10000 ????				       lda	#>{1}
    621  10000 ????				       sta	speech_addr+1
    622  10000 ????
    623  10000 ????				       endm
    624  10000 ????
    625  10000 ????
    626  10000 ????
    627  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    628  10000 ????
    629  10000 ????				       processor	6502
    630  10000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  10000 ????				       include	"7800basic.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  10000 ????				       include	"7800.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????						; 7800.h
      4  10000 ????						; Version 1.0, 2019/12/13
      5  10000 ????
      6  10000 ????						; This file defines hardware registers and memory mapping for the
      7  10000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  10000 ????						; available at https://github.com/dasm-assembler/dasm
     10  10000 ????
     11  10000 ????
     12  10000 ????						; ******************** 7800 Hardware Addresses ***************************
     13  10000 ????						;
     14  10000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  10000 ????						;
     16  10000 ????						;	  00 -   1F	TIA REGISTERS
     17  10000 ????						;	  20 -   3F	MARIA REGISTERS
     18  10000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  10000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  10000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  10000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  10000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  10000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  10000 ????						;	 240 -  27F	???
     25  10000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  10000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  10000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  10000 ????						;	 340 -  3FF	???
     29  10000 ????						;	 400 -  47F	unused address space
     30  10000 ????						;	 480 -  4FF	RIOT RAM
     31  10000 ????						;	 500 -  57F	unused address space
     32  10000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  10000 ????						;	 600 - 17FF	unused address space
     34  10000 ????						;	1800 - 203F	RAM
     35  10000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  10000 ????						;	2100 - 213F	RAM
     37  10000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  10000 ????						;	2200 - 27FF	RAM
     39  10000 ????						;	2800 - 2FFF	unavailable to external devices (bios bus-conflict)
     40  10000 ????						;	3000 - 3FFF	unused address space
     41  10000 ????						;	4000 - FF7F	potential cartridge address space
     42  10000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  10000 ????						;	FFFA - FFFF	6502 VECTORS
     44  10000 ????
     45  10000 ????
     46  10000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  10000 ????
     48  10000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  10000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  10000 ????		00 02	    _WSYNC     =	$02	;Wait for HSync			       write-only
     51  10000 ????		00 03	    _RSYNC     =	$03	;Reset HSync				       write-only
     52  10000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     53  10000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     54  10000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     55  10000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     56  10000 ????
     57  10000 ????						; ** some common alternate names for INPT0/1/2/3
     58  10000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     59  10000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     60  10000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     61  10000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     62  10000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     63  10000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     64  10000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     65  10000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     66  10000 ????
     67  10000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     68  10000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     69  10000 ????
     70  10000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     71  10000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     72  10000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     73  10000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     74  10000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     75  10000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     76  10000 ????
     77  10000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     78  10000 ????
     79  10000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     80  10000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     81  10000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     82  10000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     83  10000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     84  10000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     85  10000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     86  10000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     87  10000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     88  10000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     89  10000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     90  10000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     91  10000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     92  10000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     93  10000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     94  10000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     95  10000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     96  10000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     97  10000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     98  10000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     99  10000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
    100  10000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
    101  10000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    102  10000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    103  10000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    104  10000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    105  10000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    106  10000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    107  10000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    108  10000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    109  10000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    110  10000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    111  10000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    112  10000 ????
    113  10000 ????
    114  10000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    115  10000 ????
    116  10000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    117  10000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    118  10000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    119  10000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    120  10000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    121  10000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    122  10000 ????
    123  10000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    124  10000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    125  10000 ????		02 95	    TIMINT     =	$295	;Interval Timer Interrupt		       read-only
    126  10000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    127  10000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    128  10000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    129  10000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    130  10000 ????
    131  10000 ????						;XM
    132  10000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    133  10000 ????		04 70	    XCTRL1     =	$470
    134  10000 ????		04 78	    XCTRL2     =	$478
    135  10000 ????		04 7c	    XCTRL3     =	$47c
    136  10000 ????		04 71	    XCTRL4     =	$471
    137  10000 ????		04 72	    XCTRL5     =	$472
    138  10000 ????
    139  10000 ????						; Pokey register relative locations, since its base may be different
    140  10000 ????						; depending on the hardware.
    141  10000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    142  10000 ????		00 01	    PAUDC0     =	$1
    143  10000 ????		00 02	    PAUDF1     =	$2
    144  10000 ????		00 03	    PAUDC1     =	$3
    145  10000 ????		00 04	    PAUDF2     =	$4
    146  10000 ????		00 05	    PAUDC2     =	$5
    147  10000 ????		00 06	    PAUDF3     =	$6
    148  10000 ????		00 07	    PAUDC3     =	$7
    149  10000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    150  10000 ????		00 09	    PSTIMER    =	$9
    151  10000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    152  10000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  10000 ????				       include	"7800basic_variable_redefs.h"
      1  10000 ????						; This file contains variable mapping and other information for the current project.
      2  10000 ????
      3  10000 ????		00 00	    dhero_tallsprite_03_mode =	$00
      4  10000 ????		00 00	    dhero_tallsprite_03_width_twoscompliment =	$00
      5  10000 ????		00 00	    dhero_tallsprite_03_width =	$00
      6  10000 ????		00 80	    dhero_tallsprite_02_mode =	$80
      7  10000 ????		00 18	    dhero_tallsprite_02_width_twoscompliment =	$18
      8  10000 ????		00 08	    dhero_tallsprite_02_width =	$08
      9  10000 ????		00 80	    dhero_tallsprite_01_mode =	$80
     10  10000 ????		00 18	    dhero_tallsprite_01_width_twoscompliment =	$18
     11  10000 ????		00 08	    dhero_tallsprite_01_width =	$08
     12  10000 ????		00 80	    dhero_tallsprite_00_mode =	$80
     13  10000 ????		00 18	    dhero_tallsprite_00_width_twoscompliment =	$18
     14  10000 ????		00 08	    dhero_tallsprite_00_width =	$08
     15  10000 ????		00 80	    dhero_mode =	$80
     16  10000 ????		00 18	    dhero_width_twoscompliment =	$18
     17  10000 ????		00 08	    dhero_width =	$08
     18  10000 ????		00 00	    dhero_tallsprite_02_color15 =	0
     19  10000 ????		00 00	    dhero_tallsprite_02_color14 =	0
     20  10000 ????		00 00	    dhero_tallsprite_02_color13 =	0
     21  10000 ????		00 00	    dhero_tallsprite_02_color12 =	0
     22  10000 ????		00 00	    dhero_tallsprite_02_color11 =	0
     23  10000 ????		00 00	    dhero_tallsprite_02_color10 =	0
     24  10000 ????		00 00	    dhero_tallsprite_02_color9 =	0
     25  10000 ????		00 00	    dhero_tallsprite_02_color8 =	0
     26  10000 ????		00 00	    dhero_tallsprite_02_color7 =	0
     27  10000 ????		00 00	    dhero_tallsprite_02_color6 =	0
     28  10000 ????		00 00	    dhero_tallsprite_02_color5 =	0
     29  10000 ????		00 0f	    dhero_tallsprite_02_color4 =	$0f
     30  10000 ????		00 0f	    dhero_tallsprite_02_color3 =	$0f
     31  10000 ????		00 ba	    dhero_tallsprite_02_color2 =	$ba
     32  10000 ????		00 44	    dhero_tallsprite_02_color1 =	$44
     33  10000 ????		00 00	    dhero_tallsprite_02_color0 =	$00
     34  10000 ????		00 00	    dhero_tallsprite_01_color15 =	0
     35  10000 ????		00 00	    dhero_tallsprite_01_color14 =	0
     36  10000 ????		00 00	    dhero_tallsprite_01_color13 =	0
     37  10000 ????		00 00	    dhero_tallsprite_01_color12 =	0
     38  10000 ????		00 00	    dhero_tallsprite_01_color11 =	0
     39  10000 ????		00 00	    dhero_tallsprite_01_color10 =	0
     40  10000 ????		00 00	    dhero_tallsprite_01_color9 =	0
     41  10000 ????		00 00	    dhero_tallsprite_01_color8 =	0
     42  10000 ????		00 00	    dhero_tallsprite_01_color7 =	0
     43  10000 ????		00 00	    dhero_tallsprite_01_color6 =	0
     44  10000 ????		00 00	    dhero_tallsprite_01_color5 =	0
     45  10000 ????		00 0f	    dhero_tallsprite_01_color4 =	$0f
     46  10000 ????		00 0f	    dhero_tallsprite_01_color3 =	$0f
     47  10000 ????		00 ba	    dhero_tallsprite_01_color2 =	$ba
     48  10000 ????		00 44	    dhero_tallsprite_01_color1 =	$44
     49  10000 ????		00 00	    dhero_tallsprite_01_color0 =	$00
     50  10000 ????		00 00	    dhero_tallsprite_00_color15 =	0
     51  10000 ????		00 00	    dhero_tallsprite_00_color14 =	0
     52  10000 ????		00 00	    dhero_tallsprite_00_color13 =	0
     53  10000 ????		00 00	    dhero_tallsprite_00_color12 =	0
     54  10000 ????		00 00	    dhero_tallsprite_00_color11 =	0
     55  10000 ????		00 00	    dhero_tallsprite_00_color10 =	0
     56  10000 ????		00 00	    dhero_tallsprite_00_color9 =	0
     57  10000 ????		00 00	    dhero_tallsprite_00_color8 =	0
     58  10000 ????		00 00	    dhero_tallsprite_00_color7 =	0
     59  10000 ????		00 00	    dhero_tallsprite_00_color6 =	0
     60  10000 ????		00 00	    dhero_tallsprite_00_color5 =	0
     61  10000 ????		00 0f	    dhero_tallsprite_00_color4 =	$0f
     62  10000 ????		00 0f	    dhero_tallsprite_00_color3 =	$0f
     63  10000 ????		00 ba	    dhero_tallsprite_00_color2 =	$ba
     64  10000 ????		00 44	    dhero_tallsprite_00_color1 =	$44
     65  10000 ????		00 00	    dhero_tallsprite_00_color0 =	$00
     66  10000 ????		00 00	    dhero_color15 =	0
     67  10000 ????		00 00	    dhero_color14 =	0
     68  10000 ????		00 00	    dhero_color13 =	0
     69  10000 ????		00 00	    dhero_color12 =	0
     70  10000 ????		00 00	    dhero_color11 =	0
     71  10000 ????		00 00	    dhero_color10 =	0
     72  10000 ????		00 00	    dhero_color9 =	0
     73  10000 ????		00 00	    dhero_color8 =	0
     74  10000 ????		00 00	    dhero_color7 =	0
     75  10000 ????		00 00	    dhero_color6 =	0
     76  10000 ????		00 00	    dhero_color5 =	0
     77  10000 ????		00 0f	    dhero_color4 =	$0f
     78  10000 ????		00 0f	    dhero_color3 =	$0f
     79  10000 ????		00 ba	    dhero_color2 =	$ba
     80  10000 ????		00 44	    dhero_color1 =	$44
     81  10000 ????		00 00	    dhero_color0 =	$00
     82  10000 ????		00 08	    ZONEHEIGHT =	8
------- FILE 7800basic.h
      6  10000 ????
      7  10000 ????						;************ 7800 overall RAM map **************
      8  10000 ????
      9  10000 ????						;	   40-FF	 zero page RAM
     10  10000 ????						;	  140-1FF	 RAM (stack)
     11  10000 ????						;	 1800-203F	 RAM
     12  10000 ????						;	 2100-213F	 RAM
     13  10000 ????						;	 2200-27FF	 RAM
     14  10000 ????
     15  10000 ????						;************ 7800basic RAM usage map **************
     16  10000 ????
     17  10000 ????						;	   40-FF	 numerous defines, listed below
     18  10000 ????						;	  140-1FF	 RAM (stack)
     19  10000 ????
     20  10000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  10000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  10000 ????
     23  10000 ????						;	 2000-203F	 Reserved
     24  10000 ????						;	 2100-213F	 Reserved
     25  10000 ????						;	 2200-27FF	 Free
     26  10000 ????
     27  10000 ????		1f e0	    eeprombuffer =	$1FE0
     28  10000 ????		18 00	    DLLMEM     =	$1800
     29  10000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  10000 ????
     31  10000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  10000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  10000 ????				       else
     34  10000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  10000 ????				       endif
     36  10000 ????
     37  10000 ????
     38  10000 ????		21 00	    pausestate =	$2100
     39  10000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  10000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  10000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  10000 ????		21 04	    currentbank =	$2104
     43  10000 ????
     44  10000 ????		21 05	    currentrambank =	$2105
     45  10000 ????		21 06	    charactermode =	$2106
     46  10000 ????		21 07	    sCTRL      =	$2107
     47  10000 ????		21 08	    pokeydetected =	$2108
     48  10000 ????		21 09	    paldetected =	$2109
     49  10000 ????		21 0a	    avoxdetected =	$210A
     50  10000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  10000 ????
     52  10000 ????		21 0c	    hsdevice   =	$210C
     53  10000 ????		21 0d	    hsdifficulty =	$210D
     54  10000 ????		21 0e	    hserror    =	$210E
     55  10000 ????		21 0f	    hsgameslot =	$210F
     56  10000 ????		21 10	    hsnewscoreline =	$2110
     57  10000 ????		21 11	    hsnewscorerank =	$2111
     58  10000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  10000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  10000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  10000 ????
     62  10000 ????		21 31	    ssCTRL     =	$2131
     63  10000 ????		21 32	    ssCHARBASE =	$2132
     64  10000 ????		21 33	    hsdisplaymode =	$2133
     65  10000 ????		21 34	    gamedifficulty =	$2134
     66  10000 ????		21 35	    hsinitialpos =	$2135
     67  10000 ????		21 36	    hsinitialhold =	$2136
     68  10000 ????		21 37	    hscursorx  =	$2137
     69  10000 ????		21 38	    hsjoydebounce =	$2138
     70  10000 ????		21 39	    hsswcha    =	$2139
     71  10000 ????		21 3a	    hsinpt1    =	$213A
     72  10000 ????		21 3b	    hscolorchaseindex =	$213B
     73  10000 ????		21 3c	    visibleDLLstart =	$213C
     74  10000 ????		21 3d	    overscanDLLstart =	$213D
     75  10000 ????		21 3e	    frameslost =	$213E
     76  10000 ????		21 3f	    hsreturn   =	$213F
     77  10000 ????
     78  10000 ????
     79  10000 ????		00 40	    rand       =	$40
     80  10000 ????		00 41	    rand16     =	$41
     81  10000 ????		00 42	    temp1      =	$42
     82  10000 ????		00 43	    temp2      =	$43
     83  10000 ????		00 44	    temp3      =	$44
     84  10000 ????		00 45	    temp4      =	$45
     85  10000 ????		00 46	    temp5      =	$46
     86  10000 ????		00 47	    temp6      =	$47
     87  10000 ????		00 48	    temp7      =	$48
     88  10000 ????		00 49	    temp8      =	$49
     89  10000 ????		00 4a	    temp9      =	$4a
     90  10000 ????
     91  10000 ????		00 4b	    pokeybase  =	$4b
     92  10000 ????		00 4b	    pokeybaselo =	$4b
     93  10000 ????		00 4c	    pokeybasehi =	$4c
     94  10000 ????
     95  10000 ????		00 4d	    visibleover =	$4d
     96  10000 ????
     97  10000 ????		00 4e	    sfx1pointlo =	$4e
     98  10000 ????		00 4f	    sfx2pointlo =	$4f
     99  10000 ????		00 50	    sfx1pointhi =	$50
    100  10000 ????		00 51	    sfx2pointhi =	$51
    101  10000 ????
    102  10000 ????		00 52	    sfx1priority =	$52
    103  10000 ????		00 53	    sfx2priority =	$53
    104  10000 ????		00 54	    sfx1poffset =	$54
    105  10000 ????		00 55	    sfx2poffset =	$55
    106  10000 ????
    107  10000 ????		00 56	    sfx1frames =	$56
    108  10000 ????		00 57	    sfx2frames =	$57
    109  10000 ????		00 58	    sfx1tick   =	$58
    110  10000 ????		00 59	    sfx2tick   =	$59
    111  10000 ????
    112  10000 ????		00 5a	    tempmath   =	$5a
    113  10000 ????
    114  10000 ????		00 5b	    pokey1pointlo =	$5b
    115  10000 ????		00 5c	    pokey1pointhi =	$5c
    116  10000 ????		00 5d	    pokey2pointlo =	$5d
    117  10000 ????		00 5e	    pokey2pointhi =	$5e
    118  10000 ????		00 5f	    pokey3pointlo =	$5f
    119  10000 ????		00 60	    pokey3pointhi =	$60
    120  10000 ????		00 61	    pokey4pointlo =	$61
    121  10000 ????		00 62	    pokey4pointhi =	$62
    122  10000 ????
    123  10000 ????		00 63	    dlpnt      =	$63	; to $64
    124  10000 ????		00 65	    dlend      =	$65	; to $81 - for 28 possible visible dll entries
    125  10000 ????		00 82	    dlendsave  =	$82	; to $9e - for 28 possible visible dll entries
    126  10000 ????
    127  10000 ????		00 9f	    speech_addr =	$9f
    128  10000 ????		00 a0	    speech_addr_hi =	$a0
    129  10000 ????
    130  10000 ????		00 a1	    HSGameTableLo =	$a1
    131  10000 ????		00 a2	    HSGameTableHi =	$a2
    132  10000 ????		00 a3	    HSVoxHi    =	$a3
    133  10000 ????		00 a4	    HSVoxLo    =	$a4
    134  10000 ????
    135  10000 ????						;channel pointers
    136  10000 ????
    137  10000 ????		00 a5	    songchannel1layer1lo =	$a5
    138  10000 ????		00 a6	    songchannel2layer1lo =	$a6
    139  10000 ????		00 a7	    songchannel3layer1lo =	$a7
    140  10000 ????		00 a8	    songchannel4layer1lo =	$a8
    141  10000 ????
    142  10000 ????		00 a9	    songchannel1layer2lo =	$a9
    143  10000 ????		00 aa	    songchannel2layer2lo =	$aA
    144  10000 ????		00 ab	    songchannel3layer2lo =	$aB
    145  10000 ????		00 ac	    songchannel4layer2lo =	$aC
    146  10000 ????
    147  10000 ????		00 ad	    songchannel1layer3lo =	$aD
    148  10000 ????		00 ae	    songchannel2layer3lo =	$aE
    149  10000 ????		00 af	    songchannel3layer3lo =	$aF
    150  10000 ????		00 b0	    songchannel4layer3lo =	$b0
    151  10000 ????
    152  10000 ????		00 b1	    songchannel1layer1hi =	$b1
    153  10000 ????		00 b2	    songchannel2layer1hi =	$b2
    154  10000 ????		00 b3	    songchannel3layer1hi =	$b3
    155  10000 ????		00 b4	    songchannel4layer1hi =	$b4
    156  10000 ????
    157  10000 ????		00 b5	    songchannel1layer2hi =	$b5
    158  10000 ????		00 b6	    songchannel2layer2hi =	$b6
    159  10000 ????		00 b7	    songchannel3layer2hi =	$b7
    160  10000 ????		00 b8	    songchannel4layer2hi =	$b8
    161  10000 ????
    162  10000 ????		00 b9	    songchannel1layer3hi =	$b9
    163  10000 ????		00 ba	    songchannel2layer3hi =	$bA
    164  10000 ????		00 bb	    songchannel3layer3hi =	$bB
    165  10000 ????		00 bc	    songchannel4layer3hi =	$bC
    166  10000 ????
    167  10000 ????		00 bd	    songdatalo =	$bd
    168  10000 ????		00 be	    songdatahi =	$be
    169  10000 ????
    170  10000 ????		00 bf	    inactivechannelcount =	$bf
    171  10000 ????
    172  10000 ????		00 c0	    songchannel1transpose =	$c0
    173  10000 ????		00 c1	    songchannel2transpose =	$c1
    174  10000 ????		00 c2	    songchannel3transpose =	$c2
    175  10000 ????		00 c3	    songchannel4transpose =	$c3
    176  10000 ????
    177  10000 ????		00 c4	    songstackindex =	$c4
    178  10000 ????
    179  10000 ????		00 c5	    songchannel1instrumentlo =	$c5
    180  10000 ????		00 c6	    songchannel2instrumentlo =	$c6
    181  10000 ????		00 c7	    songchannel3instrumentlo =	$c7
    182  10000 ????		00 c8	    songchannel4instrumentlo =	$c8
    183  10000 ????
    184  10000 ????		00 c9	    songchannel1instrumenthi =	$c9
    185  10000 ????		00 ca	    songchannel2instrumenthi =	$ca
    186  10000 ????		00 cb	    songchannel3instrumenthi =	$cb
    187  10000 ????		00 cc	    songchannel4instrumenthi =	$cc
    188  10000 ????
    189  10000 ????		00 cd	    sfx1notedata =	$cd
    190  10000 ????		00 ce	    sfx2notedata =	$ce
    191  10000 ????
    192  10000 ????		00 cf	    songloops  =	$cf
    193  10000 ????
    194  10000 ????		00 d0	    songpointerlo =	$D0
    195  10000 ????		00 d1	    songpointerhi =	$D1
    196  10000 ????
    197  10000 ????		00 d2	    voxlock    =	$D2
    198  10000 ????		00 d3	    voxqueuesize =	$D3
    199  10000 ????
    200  10000 ????		00 d4	    vblankroutines =	$D4
    201  10000 ????
    202  10000 ????		00 d5	    doublebufferstate =	$D5
    203  10000 ????		00 d6	    doublebufferdloffset =	$D6
    204  10000 ????		00 d7	    doublebufferbufferdirty =	$D7
    205  10000 ????
    206  10000 ????		00 d8	    inttemp1   =	$D8
    207  10000 ????		00 d9	    inttemp2   =	$D9
    208  10000 ????		00 da	    inttemp3   =	$DA
    209  10000 ????		00 db	    inttemp4   =	$DB
    210  10000 ????		00 dc	    inttemp5   =	$DC
    211  10000 ????		00 dd	    inttemp6   =	$DD
    212  10000 ????
    213  10000 ????		00 de	    sfxschedulelock =	$DE
    214  10000 ????		00 df	    sfxschedulemissed =	$DF
    215  10000 ????		00 e0	    sfxinstrumentlo =	$E0
    216  10000 ????		00 e1	    sfxinstrumenthi =	$E1
    217  10000 ????		00 e2	    sfxpitchoffset =	$E2
    218  10000 ????		00 e3	    sfxnoteindex =	$E3
    219  10000 ????
    220  10000 ????		00 e4	    CTLSWAs    =	$E4
    221  10000 ????		00 e5	    CTLSWBs    =	$E5
    222  10000 ????
    223  10000 ????		00 e6	    A	       =	$e6
    224  10000 ????		00 e6	    a	       =	$e6
    225  10000 ????		00 e7	    B	       =	$e7
    226  10000 ????		00 e7	    b	       =	$e7
    227  10000 ????		00 e8	    C	       =	$e8
    228  10000 ????		00 e8	    c	       =	$e8
    229  10000 ????		00 e9	    D	       =	$e9
    230  10000 ????		00 e9	    d	       =	$e9
    231  10000 ????		00 ea	    E	       =	$ea
    232  10000 ????		00 ea	    e	       =	$ea
    233  10000 ????		00 eb	    F	       =	$eb
    234  10000 ????		00 eb	    f	       =	$eb
    235  10000 ????		00 ec	    G	       =	$ec
    236  10000 ????		00 ec	    g	       =	$ec
    237  10000 ????		00 ed	    H	       =	$ed
    238  10000 ????		00 ed	    h	       =	$ed
    239  10000 ????		00 ee	    I	       =	$ee
    240  10000 ????		00 ee	    i	       =	$ee
    241  10000 ????		00 ef	    J	       =	$ef
    242  10000 ????		00 ef	    j	       =	$ef
    243  10000 ????		00 f0	    K	       =	$f0
    244  10000 ????		00 f0	    k	       =	$f0
    245  10000 ????		00 f1	    L	       =	$f1
    246  10000 ????		00 f1	    l	       =	$f1
    247  10000 ????		00 f2	    M	       =	$f2
    248  10000 ????		00 f2	    m	       =	$f2
    249  10000 ????		00 f3	    N	       =	$f3
    250  10000 ????		00 f3	    n	       =	$f3
    251  10000 ????		00 f4	    O	       =	$f4
    252  10000 ????		00 f4	    o	       =	$f4
    253  10000 ????		00 f5	    P	       =	$f5
    254  10000 ????		00 f5	    p	       =	$f5
    255  10000 ????		00 f6	    Q	       =	$f6
    256  10000 ????		00 f6	    q	       =	$f6
    257  10000 ????		00 f7	    R	       =	$f7
    258  10000 ????		00 f7	    r	       =	$f7
    259  10000 ????		00 f8	    S	       =	$f8
    260  10000 ????		00 f8	    s	       =	$f8
    261  10000 ????		00 f9	    T	       =	$f9
    262  10000 ????		00 f9	    t	       =	$f9
    263  10000 ????		00 fa	    U	       =	$fa
    264  10000 ????		00 fa	    u	       =	$fa
    265  10000 ????		00 fb	    V	       =	$fb
    266  10000 ????		00 fb	    v	       =	$fb
    267  10000 ????		00 fc	    W	       =	$fc
    268  10000 ????		00 fc	    w	       =	$fc
    269  10000 ????		00 fd	    X	       =	$fd
    270  10000 ????		00 fd	    x	       =	$fd
    271  10000 ????		00 fe	    Y	       =	$fe
    272  10000 ????		00 fe	    y	       =	$fe
    273  10000 ????		00 ff	    Z	       =	$ff
    274  10000 ????		00 ff	    z	       =	$ff
    275  10000 ????
    276  10000 ????						; var0-var99 variables use the top of the stack
    277  10000 ????		01 40	    var0       =	$140
    278  10000 ????		01 41	    var1       =	$141
    279  10000 ????		01 42	    var2       =	$142
    280  10000 ????		01 43	    var3       =	$143
    281  10000 ????		01 44	    var4       =	$144
    282  10000 ????		01 45	    var5       =	$145
    283  10000 ????		01 46	    var6       =	$146
    284  10000 ????		01 47	    var7       =	$147
    285  10000 ????		01 48	    var8       =	$148
    286  10000 ????		01 49	    var9       =	$149
    287  10000 ????		01 4a	    var10      =	$14a
    288  10000 ????		01 4b	    var11      =	$14b
    289  10000 ????		01 4c	    var12      =	$14c
    290  10000 ????		01 4d	    var13      =	$14d
    291  10000 ????		01 4e	    var14      =	$14e
    292  10000 ????		01 4f	    var15      =	$14f
    293  10000 ????		01 50	    var16      =	$150
    294  10000 ????		01 51	    var17      =	$151
    295  10000 ????		01 52	    var18      =	$152
    296  10000 ????		01 53	    var19      =	$153
    297  10000 ????		01 54	    var20      =	$154
    298  10000 ????		01 55	    var21      =	$155
    299  10000 ????		01 56	    var22      =	$156
    300  10000 ????		01 57	    var23      =	$157
    301  10000 ????		01 58	    var24      =	$158
    302  10000 ????		01 59	    var25      =	$159
    303  10000 ????		01 5a	    var26      =	$15a
    304  10000 ????		01 5b	    var27      =	$15b
    305  10000 ????		01 5c	    var28      =	$15c
    306  10000 ????		01 5d	    var29      =	$15d
    307  10000 ????		01 5e	    var30      =	$15e
    308  10000 ????		01 5f	    var31      =	$15f
    309  10000 ????		01 60	    var32      =	$160
    310  10000 ????		01 61	    var33      =	$161
    311  10000 ????		01 62	    var34      =	$162
    312  10000 ????		01 63	    var35      =	$163
    313  10000 ????		01 64	    var36      =	$164
    314  10000 ????		01 65	    var37      =	$165
    315  10000 ????		01 66	    var38      =	$166
    316  10000 ????		01 67	    var39      =	$167
    317  10000 ????		01 68	    var40      =	$168
    318  10000 ????		01 69	    var41      =	$169
    319  10000 ????		01 6a	    var42      =	$16a
    320  10000 ????		01 6b	    var43      =	$16b
    321  10000 ????		01 6c	    var44      =	$16c
    322  10000 ????		01 6d	    var45      =	$16d
    323  10000 ????		01 6e	    var46      =	$16e
    324  10000 ????		01 6f	    var47      =	$16f
    325  10000 ????		01 70	    var48      =	$170
    326  10000 ????		01 71	    var49      =	$171
    327  10000 ????		01 72	    var50      =	$172
    328  10000 ????		01 73	    var51      =	$173
    329  10000 ????		01 74	    var52      =	$174
    330  10000 ????		01 75	    var53      =	$175
    331  10000 ????		01 76	    var54      =	$176
    332  10000 ????		01 77	    var55      =	$177
    333  10000 ????		01 78	    var56      =	$178
    334  10000 ????		01 79	    var57      =	$179
    335  10000 ????		01 7a	    var58      =	$17a
    336  10000 ????		01 7b	    var59      =	$17b
    337  10000 ????		01 7c	    var60      =	$17c
    338  10000 ????		01 7d	    var61      =	$17d
    339  10000 ????		01 7e	    var62      =	$17e
    340  10000 ????		01 7f	    var63      =	$17f
    341  10000 ????		01 80	    var64      =	$180
    342  10000 ????		01 81	    var65      =	$181
    343  10000 ????		01 82	    var66      =	$182
    344  10000 ????		01 83	    var67      =	$183
    345  10000 ????		01 84	    var68      =	$184
    346  10000 ????		01 85	    var69      =	$185
    347  10000 ????		01 86	    var70      =	$186
    348  10000 ????		01 87	    var71      =	$187
    349  10000 ????		01 88	    var72      =	$188
    350  10000 ????		01 89	    var73      =	$189
    351  10000 ????		01 8a	    var74      =	$18a
    352  10000 ????		01 8b	    var75      =	$18b
    353  10000 ????		01 8c	    var76      =	$18c
    354  10000 ????		01 8d	    var77      =	$18d
    355  10000 ????		01 8e	    var78      =	$18e
    356  10000 ????		01 8f	    var79      =	$18f
    357  10000 ????		01 90	    var80      =	$190
    358  10000 ????		01 91	    var81      =	$191
    359  10000 ????		01 92	    var82      =	$192
    360  10000 ????		01 93	    var83      =	$193
    361  10000 ????		01 94	    var84      =	$194
    362  10000 ????		01 95	    var85      =	$195
    363  10000 ????		01 96	    var86      =	$196
    364  10000 ????		01 97	    var87      =	$197
    365  10000 ????		01 98	    var88      =	$198
    366  10000 ????		01 99	    var89      =	$199
    367  10000 ????		01 9a	    var90      =	$19a
    368  10000 ????		01 9b	    var91      =	$19b
    369  10000 ????		01 9c	    var92      =	$19c
    370  10000 ????		01 9d	    var93      =	$19d
    371  10000 ????		01 9e	    var94      =	$19e
    372  10000 ????		01 9f	    var95      =	$19f
    373  10000 ????		01 a0	    var96      =	$1a0
    374  10000 ????		01 a1	    var97      =	$1a1
    375  10000 ????		01 a2	    var98      =	$1a2
    376  10000 ????		01 a3	    var99      =	$1a3
    377  10000 ????
    378 U01c2 ????				      SEG.U	"7800basicRAM"
    379 U01a4					      ORG	$1A4
    380 U01a4
    381 U01a4							; MAX allocation locations are in comments...
    382 U01a4		       00	   framecounter DS	1	; $1A4
    383 U01a5		       00	   countdownseconds DS	1	; $1A5
    384 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    385 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    386 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    387 U01ad		       00	   valbufend  DS	1	; $1AD
    388 U01ae		       00	   valbufendsave DS	1	; $1AE
    389 U01af		       00	   finescrollx DS	1	; $1AF
    390 U01b0		       00	   finescrolly DS	1	; $1B0
    391 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    392 U01b2		       00	   interruptindex DS	1	; $1B2
    393 U01b3
    394 U01b3				  -	      ifconst	DOUBLEBUFFER
    395 U01b3				  -doublebufferminimumframetarget DS	1	; $1B3
    396 U01b3				  -doublebufferminimumframeindex DS	1	; $1B4
    397 U01b3					      endif
    398 U01b3
    399 U01b3		       00	   pausedisable DS	1	; $1B5
    400 U01b4		       00	   XCTRL1s    DS	1	; $1B6
    401 U01b5
    402 U01b5				  -	      ifconst	AVOXVOICE
    403 U01b5				  -avoxenable DS	1	; $1B7
    404 U01b5				  -tempavox   DS	1	; $1B8
    405 U01b5					      endif
    406 U01b5
    407 U01b5				  -	      ifconst	MUSICTRACKER
    408 U01b5				  -songtempo  DS	1	; $1B9
    409 U01b5				  -songtick   DS	1	; $1BA
    410 U01b5				  -
    411 U01b5				  -songchannel1layer1loops DS	1	; $1BB
    412 U01b5				  -songchannel2layer1loops DS	1	; $1BC
    413 U01b5				  -songchannel3layer1loops DS	1	; $1BD
    414 U01b5				  -songchannel4layer1loops DS	1	; $1BE
    415 U01b5				  -
    416 U01b5				  -songchannel1layer2loops DS	1	; $1BF
    417 U01b5				  -songchannel2layer2loops DS	1	; $1C0
    418 U01b5				  -songchannel3layer2loops DS	1	; $1C1
    419 U01b5				  -songchannel4layer2loops DS	1	; $1C2
    420 U01b5				  -
    421 U01b5				  -songchannel1layer3loops DS	1	; $1C3
    422 U01b5				  -songchannel2layer3loops DS	1	; $1C4
    423 U01b5				  -songchannel3layer3loops DS	1	; $1C5
    424 U01b5				  -songchannel4layer3loops DS	1	; $1C6
    425 U01b5				  -
    426 U01b5				  -songchannel1busywait DS	1	; $1C7
    427 U01b5				  -songchannel2busywait DS	1	; $1C8
    428 U01b5				  -songchannel3busywait DS	1	; $1C9
    429 U01b5				  -songchannel4busywait DS	1	; $1CA
    430 U01b5				  -
    431 U01b5				  -songchannel1stackdepth DS	1	; $1CB
    432 U01b5				  -songchannel2stackdepth DS	1	; $1CC
    433 U01b5				  -songchannel3stackdepth DS	1	; $1CD
    434 U01b5				  -songchannel4stackdepth DS	1	; $1CE
    435 U01b5					      endif
    436 U01b5
    437 U01b5		       00	   palframes  DS	1	; $1CF
    438 U01b6		       00	   palfastframe DS	1	; $1D0
    439 U01b7
    440 U01b7				  -	      ifconst	MOUSESUPPORT
    441 U01b7				  -port0resolution DS	1	; $1D1
    442 U01b7				  -port1resolution DS	1	; $1D2
    443 U01b7					      else
    444 U01b7				  -	      ifconst	TRAKBALLSUPPORT
    445 U01b7				  -port0resolution DS	1	; $1D1
    446 U01b7				  -port1resolution DS	1	; $1D2
    447 U01b7					      endif
    448 U01b7					      endif
    449 U01b7
    450 U01b7		       00	   port0control DS	1	; $1D3
    451 U01b8		       00	   port1control DS	1	; $1D4
    452 U01b9
    453 U01b9							; port#control values...
    454 U01b9							;	1 = proline
    455 U01b9							;	2 = lightgun
    456 U01b9							;	3 = paddle
    457 U01b9							;	4 = trakball
    458 U01b9							;	5 = vcs joystick
    459 U01b9							;	6 = driving
    460 U01b9							;	7 = keypad
    461 U01b9							;	8 = st mouse/cx80
    462 U01b9							;	9 = amiga mouse
    463 U01b9							;     10 = atarivox
    464 U01b9
    465 U01b9							; controller 0 data...
    466 U01b9		       00	   paddleposition0 DS	1	; $1D5
    467 U01b9		       01 b9	   keypadmatrix0a =	paddleposition0
    468 U01b9		       01 b9	   drivingposition0 =	paddleposition0
    469 U01b9		       01 b9	   trakballx0 =	paddleposition0
    470 U01b9		       01 b9	   mousex0    =	paddleposition0
    471 U01b9		       01 b9	   lighttgunx0 =	paddleposition0
    472 U01b9		       01 b9	   snes2atari0lo =	paddleposition0
    473 U01ba
    474 U01ba							; controller 1 data...
    475 U01ba		       00	   paddleposition2 DS	1	; $1D6
    476 U01ba		       01 ba	   keypadmatrix1a =	paddleposition2
    477 U01ba		       01 ba	   drivingposition1 =	paddleposition2
    478 U01ba		       01 ba	   trakballx1 =	paddleposition2
    479 U01ba		       01 ba	   mousex1    =	paddleposition2
    480 U01ba		       01 ba	   lightgunx1 =	paddleposition2
    481 U01ba		       01 ba	   snes2atari1lo =	paddleposition2
    482 U01bb
    483 U01bb							; controller 0 altdata...
    484 U01bb		       00	   paddleposition1 DS	1	; $1D7
    485 U01bb		       01 bb	   keypadmatrix0b =	paddleposition1
    486 U01bb		       01 bb	   trakbally0 =	paddleposition1
    487 U01bb		       01 bb	   mousey0    =	paddleposition1
    488 U01bb		       01 bb	   lightguny0 =	paddleposition1
    489 U01bb		       01 bb	   snes2atari0hi =	paddleposition1
    490 U01bc
    491 U01bc							; controller 1 altdata...
    492 U01bc		       00	   paddleposition3 DS	1	; $1D8
    493 U01bc		       01 bc	   keypadmatrix1b =	paddleposition3
    494 U01bc		       01 bc	   trakbally1 =	paddleposition3
    495 U01bc		       01 bc	   mousey1    =	paddleposition3
    496 U01bc		       01 bc	   lightguny1 =	paddleposition3
    497 U01bc		       01 bc	   snes2atari1hi =	paddleposition3
    498 U01bd
    499 U01bd							; controller state save. for trakball state+dir codes, rotary position codes
    500 U01bd		       00	   controller0statesave DS	1	; $1D9
    501 U01bd		       01 bd	   paddleprevious0 =	controller0statesave
    502 U01bd		       01 bd	   mousecodex0 =	controller0statesave
    503 U01bd		       01 bd	   trakballcodex0 =	controller0statesave
    504 U01bd		       01 bd	   keypadmatrix0c =	controller0statesave
    505 U01bd		       01 bd	   snesdetected0 =	controller0statesave
    506 U01be
    507 U01be		       00	   controller1statesave DS	1	; $1DA
    508 U01be		       01 be	   paddleprevious2 =	controller1statesave
    509 U01be		       01 be	   mousecodex1 =	controller1statesave
    510 U01be		       01 be	   trakballcodex1 =	controller1statesave
    511 U01be		       01 be	   keypadmatrix1c =	controller1statesave
    512 U01be		       01 be	   snesdetected1 =	controller1statesave
    513 U01bf
    514 U01bf		       00	   paddleprevious1 DS	1	; $1DB
    515 U01bf		       01 bf	   keypadmatrix0d =	paddleprevious1
    516 U01bf		       01 bf	   mousecodey0 =	paddleprevious1
    517 U01bf		       01 bf	   trakballcodey0 =	paddleprevious1
    518 U01c0
    519 U01c0		       00	   paddleprevious3 DS	1	; $1DC
    520 U01c0		       01 c0	   keypadmatrix1d =	paddleprevious3
    521 U01c0		       01 c0	   mousecodey1 =	paddleprevious3
    522 U01c0		       01 c0	   trakballcodey1 =	paddleprevious3
    523 U01c1
    524 U01c1				  -	      ifconst	pokeysupport
    525 U01c1				  -pokey1frames DS	1	; $1DD
    526 U01c1				  -pokey1tick DS	1	; $1DE
    527 U01c1				  -pokey2frames DS	1	; $1DF
    528 U01c1				  -pokey2tick DS	1	; $1E0
    529 U01c1				  -pokey3frames DS	1	; $1E1
    530 U01c1				  -pokey3tick DS	1	; $1E2
    531 U01c1				  -pokey4frames DS	1	; $1E3
    532 U01c1				  -pokey4tick DS	1	; $1E4
    533 U01c1				  -pokey1priority DS	1	; $1E5
    534 U01c1				  -pokey1offset DS	1	; $1E6
    535 U01c1				  -pokey2priority DS	1	; $1E7
    536 U01c1				  -pokey2offset DS	1	; $1E8
    537 U01c1				  -pokey3priority DS	1	; $1E9
    538 U01c1				  -pokey3offset DS	1	; $1EA
    539 U01c1				  -pokey4priority DS	1	; $1EB
    540 U01c1				  -pokey4offset DS	1	; $1EC
    541 U01c1					      endif
    542 U01c1
    543 U01c1				  -	      ifconst	pokeykeysupport
    544 U01c1				  -pokeylastkeycode DS	1
    545 U01c1				  -pokeykeycode DS	1
    546 U01c1				  -pokeykeydebounce DS	1
    547 U01c1					      endif
    548 U01c1
    549 U01c1				  -	      ifconst	RMT
    550 U01c1				  -rasterpause DS	1
    551 U01c1					      endif		; RMT
    552 U01c1				  -	      ifconst	RMTVOLUME
    553 U01c1				  -rmtvolume  DS	1
    554 U01c1					      endif		; RMTVOLUME
    555 U01c1				  -	      ifconst	TIAVOLUME
    556 U01c1				  -tiavolume  DS	1
    557 U01c1					      endif		; TIAVOLUME
    558 U01c1
    559 U01c1				  -	      ifconst	FOURBITFADE
    560 U01c1				  -fourbittemp1 DS	1
    561 U01c1				  -fourbitfadevalue DS	1
    562 U01c1				  -fourbittemp1int DS	1
    563 U01c1				  -fourbitfadevalueint DS	1
    564 U01c1					      endif		; FOURBITFADE
    565 U01c1
    566 U01c1				  -	      ifconst	SNES2ATARISUPPORT
    567 U01c1				  -snesport   DS	1
    568 U01c1					      endif
    569 U01c1
    570 U01c1				  -	      ifconst	KEYPADSUPPORT
    571 U01c1				  -keypadcounter DS	1
    572 U01c1					      endif
    573 U01c1
    574 U01c1							; see if we need an interrupthold byte...
    575 U01c1				   INTERRUPTNEEDED SET	0
    576 U01c1				  -	      ifconst	.topscreenroutine
    577 U01c1				  -INTERRUPTNEEDED SET	1
    578 U01c1					      endif
    579 U01c1				  -	      ifconst	.bottomscreenroutine
    580 U01c1				  -INTERRUPTNEEDED SET	1
    581 U01c1					      endif
    582 U01c1				  -	      ifconst	.userinterrupt
    583 U01c1				  -INTERRUPTNEEDED SET	1
    584 U01c1					      endif
    585 U01c1				  -	      if	INTERRUPTNEEDED = 1
    586 U01c1				  -interrupthold DS	1	; $1ED
    587 U01c1					      endif
    588 U01c1
    589 U01c1					      ifnconst	CANARYOFF
    590 U01c1		       00	   canary     DS	1	; $1EF
    591 U01c2					      endif
    592 U01c2
    593 U01c2
    594 U01c2					      ifnconst	bankswitchmode
   stack allowance: 30 nested subroutines.
    595 U01c2					      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    596 U01c2				  -	      else
    597 U01c2				  -	      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    598 U01c2					      endif
    599 U01c2					      ifnconst	CANARYOFF
   the canary is situated at: $1c1
    600 U01c2					      echo	"  the canary is situated at:",[canary]
    601 U01c2				  -	      else
    602 U01c2				  -	      echo	"  the canary is disabled."
    603 U01c2					      endif
    604 U01c2
    605 U01c2							; $1EE - $1FF reserved for stack
    606 U01c2
    607  10000 ????				       SEG	"GAME"
    608  10000 ????
------- FILE test320c.78b.asm
------- FILE 7800basic_variable_redefs.h LEVEL 2 PASS 3
      0  10000 ????				       include	"7800basic_variable_redefs.h"
      1  10000 ????						; This file contains variable mapping and other information for the current project.
      2  10000 ????
      3  10000 ????		00 00	    dhero_tallsprite_03_mode =	$00
      4  10000 ????		00 00	    dhero_tallsprite_03_width_twoscompliment =	$00
      5  10000 ????		00 00	    dhero_tallsprite_03_width =	$00
      6  10000 ????		00 80	    dhero_tallsprite_02_mode =	$80
      7  10000 ????		00 18	    dhero_tallsprite_02_width_twoscompliment =	$18
      8  10000 ????		00 08	    dhero_tallsprite_02_width =	$08
      9  10000 ????		00 80	    dhero_tallsprite_01_mode =	$80
     10  10000 ????		00 18	    dhero_tallsprite_01_width_twoscompliment =	$18
     11  10000 ????		00 08	    dhero_tallsprite_01_width =	$08
     12  10000 ????		00 80	    dhero_tallsprite_00_mode =	$80
     13  10000 ????		00 18	    dhero_tallsprite_00_width_twoscompliment =	$18
     14  10000 ????		00 08	    dhero_tallsprite_00_width =	$08
     15  10000 ????		00 80	    dhero_mode =	$80
     16  10000 ????		00 18	    dhero_width_twoscompliment =	$18
     17  10000 ????		00 08	    dhero_width =	$08
     18  10000 ????		00 00	    dhero_tallsprite_02_color15 =	0
     19  10000 ????		00 00	    dhero_tallsprite_02_color14 =	0
     20  10000 ????		00 00	    dhero_tallsprite_02_color13 =	0
     21  10000 ????		00 00	    dhero_tallsprite_02_color12 =	0
     22  10000 ????		00 00	    dhero_tallsprite_02_color11 =	0
     23  10000 ????		00 00	    dhero_tallsprite_02_color10 =	0
     24  10000 ????		00 00	    dhero_tallsprite_02_color9 =	0
     25  10000 ????		00 00	    dhero_tallsprite_02_color8 =	0
     26  10000 ????		00 00	    dhero_tallsprite_02_color7 =	0
     27  10000 ????		00 00	    dhero_tallsprite_02_color6 =	0
     28  10000 ????		00 00	    dhero_tallsprite_02_color5 =	0
     29  10000 ????		00 0f	    dhero_tallsprite_02_color4 =	$0f
     30  10000 ????		00 0f	    dhero_tallsprite_02_color3 =	$0f
     31  10000 ????		00 ba	    dhero_tallsprite_02_color2 =	$ba
     32  10000 ????		00 44	    dhero_tallsprite_02_color1 =	$44
     33  10000 ????		00 00	    dhero_tallsprite_02_color0 =	$00
     34  10000 ????		00 00	    dhero_tallsprite_01_color15 =	0
     35  10000 ????		00 00	    dhero_tallsprite_01_color14 =	0
     36  10000 ????		00 00	    dhero_tallsprite_01_color13 =	0
     37  10000 ????		00 00	    dhero_tallsprite_01_color12 =	0
     38  10000 ????		00 00	    dhero_tallsprite_01_color11 =	0
     39  10000 ????		00 00	    dhero_tallsprite_01_color10 =	0
     40  10000 ????		00 00	    dhero_tallsprite_01_color9 =	0
     41  10000 ????		00 00	    dhero_tallsprite_01_color8 =	0
     42  10000 ????		00 00	    dhero_tallsprite_01_color7 =	0
     43  10000 ????		00 00	    dhero_tallsprite_01_color6 =	0
     44  10000 ????		00 00	    dhero_tallsprite_01_color5 =	0
     45  10000 ????		00 0f	    dhero_tallsprite_01_color4 =	$0f
     46  10000 ????		00 0f	    dhero_tallsprite_01_color3 =	$0f
     47  10000 ????		00 ba	    dhero_tallsprite_01_color2 =	$ba
     48  10000 ????		00 44	    dhero_tallsprite_01_color1 =	$44
     49  10000 ????		00 00	    dhero_tallsprite_01_color0 =	$00
     50  10000 ????		00 00	    dhero_tallsprite_00_color15 =	0
     51  10000 ????		00 00	    dhero_tallsprite_00_color14 =	0
     52  10000 ????		00 00	    dhero_tallsprite_00_color13 =	0
     53  10000 ????		00 00	    dhero_tallsprite_00_color12 =	0
     54  10000 ????		00 00	    dhero_tallsprite_00_color11 =	0
     55  10000 ????		00 00	    dhero_tallsprite_00_color10 =	0
     56  10000 ????		00 00	    dhero_tallsprite_00_color9 =	0
     57  10000 ????		00 00	    dhero_tallsprite_00_color8 =	0
     58  10000 ????		00 00	    dhero_tallsprite_00_color7 =	0
     59  10000 ????		00 00	    dhero_tallsprite_00_color6 =	0
     60  10000 ????		00 00	    dhero_tallsprite_00_color5 =	0
     61  10000 ????		00 0f	    dhero_tallsprite_00_color4 =	$0f
     62  10000 ????		00 0f	    dhero_tallsprite_00_color3 =	$0f
     63  10000 ????		00 ba	    dhero_tallsprite_00_color2 =	$ba
     64  10000 ????		00 44	    dhero_tallsprite_00_color1 =	$44
     65  10000 ????		00 00	    dhero_tallsprite_00_color0 =	$00
     66  10000 ????		00 00	    dhero_color15 =	0
     67  10000 ????		00 00	    dhero_color14 =	0
     68  10000 ????		00 00	    dhero_color13 =	0
     69  10000 ????		00 00	    dhero_color12 =	0
     70  10000 ????		00 00	    dhero_color11 =	0
     71  10000 ????		00 00	    dhero_color10 =	0
     72  10000 ????		00 00	    dhero_color9 =	0
     73  10000 ????		00 00	    dhero_color8 =	0
     74  10000 ????		00 00	    dhero_color7 =	0
     75  10000 ????		00 00	    dhero_color6 =	0
     76  10000 ????		00 00	    dhero_color5 =	0
     77  10000 ????		00 0f	    dhero_color4 =	$0f
     78  10000 ????		00 0f	    dhero_color3 =	$0f
     79  10000 ????		00 ba	    dhero_color2 =	$ba
     80  10000 ????		00 44	    dhero_color1 =	$44
     81  10000 ????		00 00	    dhero_color0 =	$00
     82  10000 ????		00 08	    ZONEHEIGHT =	8
------- FILE test320c.78b.asm
    633  10000 ????
    634  10000 ????						; BEADHEADER... disabled for now
    635  10000 ????						; A BEAD header gets automatically incorportated into the ROM header.
    636  10000 ????						; For more BEAD executable info, check out the spec...
    637  10000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
    638  10000 ????
    639  10000 ????		00 01	    GAMEDESCRIPTIONSET =	1
    640  10000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
    641  10000 ????
    642  10000 ????
    643  10000 ????		00 40	    BDHSC      =	%01000000
    644  10000 ????		00 20	    BDYM       =	%00100000
    645  10000 ????		00 10	    BDPOKEY    =	%00010000
    646  10000 ????		00 08	    BDROF      =	%00001000
    647  10000 ????		00 00	    BD16K      =	%00000000
    648  10000 ????		00 01	    BD32K      =	%00000001
    649  10000 ????		00 02	    BD48K      =	%00000010
    650  10000 ????		00 05	    BD1800     =	%00000101
    651  10000 ????		00 06	    BD4000     =	%00000110
    652  10000 ????
    653  10000 ????			   -	       ifconst	BEADHEADER
    654  10000 ????			   -BEADHARDWARE SET	0
    655  10000 ????			   -	       ifconst	ROM16K
    656  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
    657  10000 ????			   -	       endif
    658  10000 ????			   -	       ifconst	ROM32K
    659  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
    660  10000 ????			   -	       endif
    661  10000 ????			   -	       ifconst	ROM48K
    662  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
    663  10000 ????			   -	       endif
    664  10000 ????			   -	       ifconst	pokeysupport
    665  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
    666  10000 ????			   -	       endif
    667  10000 ????			   -	       ifconst	HSSUPPORT
    668  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
    669  10000 ????			   -	       endif
    670  10000 ????				       endif
    671  10000 ????
    672  10000 ????						;start address of cart...
    673  10000 ????
    674  10000 ????			    BANK_WAS_SET SET	0
    675  10000 ????
    676  10000 ????			   -	       ifconst	ROM8K
    677  10000 ????			   -	       ORG	$E000,0
    678  10000 ????			   -BANK_WAS_SET SET	1
    679  10000 ????				       endif		; ROM8K
    680  10000 ????
    681  10000 ????			   -	       ifconst	ROM16K
    682  10000 ????			   -	       ORG	$C000,0
    683  10000 ????			   -BANK_WAS_SET SET	1
    684  10000 ????			   -	       ifconst	BEADHEADER
    685  10000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    686  10000 ????			   -	       ifconst	GAMEDESCRIPTION
    687  10000 ????			   -	       CLC
    688  10000 ????			   -	       BCC	_SKIPDESCRIPTION
    689  10000 ????			   -	       .byte	GAMEDESCRIPTION,0
    690  10000 ????			   -_SKIPDESCRIPTION
    691  10000 ????			   -	       endif		; GAMEDESCRIPTION
    692  10000 ????			   -	       jmp	($FFFC)
    693  10000 ????			   -	       endif		; BEADHEADER
    694  10000 ????				       endif		; ROM16K
    695  10000 ????
    696  10000 ????			   -	       ifconst	ROM32K
    697  10000 ????			   -	       ORG	$8000,0
    698  10000 ????			   -BANK_WAS_SET SET	1
    699  10000 ????			   -	       ifconst	BEADHEADER
    700  10000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    701  10000 ????			   -	       ifconst	GAMEDESCRIPTION
    702  10000 ????			   -	       CLC
    703  10000 ????			   -	       BCC	_SKIPDESCRIPTION
    704  10000 ????			   -	       .byte	GAMEDESCRIPTION,0
    705  10000 ????			   -_SKIPDESCRIPTION
    706  10000 ????			   -	       endif		; GAMEDESCRIPTION
    707  10000 ????			   -	       jmp	($FFFC)
    708  10000 ????			   -	       endif		; BEADHEADER
    709  10000 ????				       endif		; ROM32K
    710  10000 ????
    711  10000 ????			   -	       ifconst	ROM48K
    712  10000 ????			   -	       ORG	$4000,0
    713  10000 ????			   -BANK_WAS_SET SET	1
    714  10000 ????			   -	       ifconst	BEADHEADER
    715  10000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    716  10000 ????			   -	       ifconst	GAMEDESCRIPTIONSET
    717  10000 ????			   -	       CLC
    718  10000 ????			   -	       BCC	_SKIPDESCRIPTION
    719  10000 ????			   -	       .byte	GAMEDESCRIPTION,0
    720  10000 ????			   -_SKIPDESCRIPTION
    721  10000 ????			   -	       endif		; GAMEDESCRIPTIONSET
    722  10000 ????			   -	       jmp	($FFFC)
    723  10000 ????			   -	       endif		; BEADHEADER
    724  10000 ????				       endif		; ROM48K
    725  10000 ????
    726  10000 ????			   -	       ifconst	ROM52K
    727  10000 ????			   -BANK_WAS_SET SET	1
    728  10000 ????			   -	       ORG	$3000,0
    729  10000 ????				       endif		; ROM52K
    730  10000 ????
    731  10000 ????			   -	       ifconst	bankswitchmode
    732  10000 ????			   -	       ifconst	ROMAT4K
    733  10000 ????			   -BANK_WAS_SET SET	1
    734  10000 ????			   -	       ORG	$4000,0
    735  10000 ????			   -	       RORG	$4000
    736  10000 ????			   -	       else		; ROMAT4K
    737  10000 ????			   -BANK_WAS_SET SET	1
    738  10000 ????			   -	       ORG	$8000,0
    739  10000 ????			   -	       RORG	$8000
    740  10000 ????			   -	       endif
    741  10000 ????				       endif
    742  10000 ????
    743  10000 ????				       if	BANK_WAS_SET = 0
    744  8000					      ORG	$8000,0	; default is 32K
    745  8000					      endif
    746  8000
    747  8000				   START_OF_ROM SET	.
    748  8000							;7800basic v0.24 Mar  2 2023 18:16:27
    749  8000				   SPACEOVERFLOW SET	0
    750  8000				   game
    751  8000				   .L00 		;;  set tallsprite on
    752  8000
    753  8000				   .L01 		;;  set zoneheight 8
    754  8000
    755  8000				   .L02 		;;  displaymode 320A
    756  8000
    757  8000		       a9 43		      lda	#%01000011	;Enable DMA, mode=160x2/160x4
    758  8002		       85 3c		      sta	CTRL
    759  8004
    760  8004		       8d 07 21 	      sta	sCTRL
    761  8007
    762  8007				   .
    763  8007							;;
    764  8007
    765  8007				   .
    766  8007							;;
    767  8007
    768  8007				   .L03 		;;  P1C2  =  $46
    769  8007
    770  8007		       a9 46		      LDA	#$46
    771  8009		       85 26		      STA	P1C2
    772  800b				   .L04 		;;  P2C2  =  $AA
    773  800b
    774  800b		       a9 aa		      LDA	#$AA
    775  800d		       85 2a		      STA	P2C2
    776  800f				   .L05 		;;  P3C2  =  $0F
    777  800f
    778  800f		       a9 0f		      LDA	#$0F
    779  8011		       85 2e		      STA	P3C2
    780  8013				   .
    781  8013							;;
    782  8013
    783  8013				   .L06 		;;  incgraphic dhero.png 320C 0 1 2 3
    784  8013
    785  8013				   .
    786  8013							;;
    787  8013
    788  8013				   .Main
    789  8013							;; Main
    790  8013
    791  8013				   .L07 		;;  clearscreen
    792  8013
    793  8013		       20 7f f0 	      jsr	clearscreen
    794  8016				   .L08 		;;  plotsprite dhero 0 72 64
    795  8016
    796  8016		       a9 00		      lda	#<dhero
    797  8018		       85 42		      sta	temp1
    798  801a
    799  801a		       a9 e0		      lda	#>dhero
    800  801c		       85 43		      sta	temp2
    801  801e
    802  801e		       a9 18		      lda	#(0|dhero_width_twoscompliment)
    803  8020		       85 44		      sta	temp3
    804  8022
    805  8022		       a9 48		      lda	#72
    806  8024		       85 45		      sta	temp4
    807  8026
    808  8026		       a9 40		      lda	#64
    809  8028
    810  8028		       85 46		      sta	temp5
    811  802a
    812  802a		       a9 c0		      lda	#(dhero_mode|%01000000)
    813  802c		       85 47		      sta	temp6
    814  802e
    815  802e		       20 c9 f2 	      jsr	plotsprite
    816  8031							; +tall sprite replot
    817  8031		       18		      clc
    818  8032		       a5 42		      lda	temp1
    819  8034		       69 08		      adc	#dhero_width
    820  8036		       85 42		      sta	temp1
    821  8038		       a5 46		      lda	temp5
    822  803a		       69 08		      adc	#WZONEHEIGHT
    823  803c		       85 46		      sta	temp5
    824  803e		       20 c9 f2 	      jsr	plotsprite
    825  8041							; +tall sprite replot
    826  8041		       18		      clc
    827  8042		       a5 42		      lda	temp1
    828  8044		       69 08		      adc	#dhero_width
    829  8046		       85 42		      sta	temp1
    830  8048		       a5 46		      lda	temp5
    831  804a		       69 08		      adc	#WZONEHEIGHT
    832  804c		       85 46		      sta	temp5
    833  804e		       20 c9 f2 	      jsr	plotsprite
    834  8051							; +tall sprite replot
    835  8051		       18		      clc
    836  8052		       a5 42		      lda	temp1
    837  8054		       69 08		      adc	#dhero_width
    838  8056		       85 42		      sta	temp1
    839  8058		       a5 46		      lda	temp5
    840  805a		       69 08		      adc	#WZONEHEIGHT
    841  805c		       85 46		      sta	temp5
    842  805e		       20 c9 f2 	      jsr	plotsprite
    843  8061				   .L09 		;;  drawscreen
    844  8061
    845  8061		       20 b3 f0 	      jsr	drawscreen
    846  8064				   .L010		;;  goto Main
    847  8064
    848  8064		       4c 13 80 	      jmp	.Main
    849  8067
    850  8067				   .L011		;;
    851  8067				   DMAHOLEEND0 SET	.
    852  8067				   gameend
    853  8067				   DMAHOLEEND0 SET	.
   24473 bytes of ROM space left in the main area.
    854  8067					      echo	" ",[($E000 - gameend)]d , "bytes of ROM space left in the main area."
    855  8067				  -	      if	($E000 - gameend) < 0
    856  8067				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
    857  8067					      endif
    858  8067				  -	      if	START_OF_ROM = .	; avoid dasm empty start-rom truncation.
    859  8067				  -	      .byte	0
    860  8067					      endif
    861  8067				   START_OF_ROM SET	0	; scuttle so we always fail subsequent banks
    862  8067
    863  e000					      ORG	$E000,0	; *************
    864  e000
    865  e000		       e0 00	   dhero      =	$E000
    866  e000
    867  e000				   dhero
    868  e000		       fa 75 fa d9*	      HEX	fa75fad9f5f51288
    869  e000		       e0 08	   dhero_tallsprite_00 =	$E008
    870  e008
    871  e008				   dhero_tallsprite_00
    872  e008		       12 75 ea ff*	      HEX	1275eaffff000000
    873  e008		       e0 10	   dhero_tallsprite_01 =	$E010
    874  e010
    875  e010				   dhero_tallsprite_01
    876  e010		       00 33 cc 00*	      HEX	0033cc000033cc00
    877  e010		       e0 18	   dhero_tallsprite_02 =	$E018
    878  e018
    879  e018				   dhero_tallsprite_02
    880  e018		       00 00 00 00*	      HEX	0000000000000000
    881  e020
    882  e100					      ORG	$E100,0	; *************
    883  e100
    884  e100							;dhero
    885  e100		       fa fa fa d9*	      HEX	fafafad9f5e51288
    886  e108							;dhero_tallsprite_00
    887  e108		       32 f6 fa 75*	      HEX	32f6fa75e5001288
    888  e110							;dhero_tallsprite_01
    889  e110		       00 33 cc 00*	      HEX	0033cc000033cc00
    890  e118							;dhero_tallsprite_02
    891  e118		       00 00 00 00*	      HEX	0000000000000000
    892  e120
    893  e200					      ORG	$E200,0	; *************
    894  e200
    895  e200							;dhero
    896  e200		       00 00 00 00*	      HEX	0000000000001288
    897  e208							;dhero_tallsprite_00
    898  e208		       7a e5 fa b9*	      HEX	7ae5fab9e5001288
    899  e210							;dhero_tallsprite_01
    900  e210		       00 13 ef 00*	      HEX	0013ef00007f8c00
    901  e218							;dhero_tallsprite_02
    902  e218		       00 00 00 00*	      HEX	0000000000000000
    903  e220
    904  e300					      ORG	$E300,0	; *************
    905  e300
    906  e300							;dhero
    907  e300		       00 00 00 ff*	      HEX	000000ffcc001288
    908  e308							;dhero_tallsprite_00
    909  e308		       fa f9 fa d9*	      HEX	faf9fad9e50075c4
    910  e310							;dhero_tallsprite_01
    911  e310		       00 13 ff 00*	      HEX	0013ff0000ff8c00
    912  e318							;dhero_tallsprite_02
    913  e318		       00 00 00 00*	      HEX	0000000000000000
    914  e320
    915  e400					      ORG	$E400,0	; *************
    916  e400
    917  e400							;dhero
    918  e400		       00 00 00 ff*	      HEX	000000ffcc001288
    919  e408							;dhero_tallsprite_00
    920  e408		       fa f9 b6 d9*	      HEX	faf9b6d9f500f5e5
    921  e410							;dhero_tallsprite_01
    922  e410		       00 00 ff cc*	      HEX	0000ffcc33ff0000
    923  e418							;dhero_tallsprite_02
    924  e418		       11 f5 c4 00*	      HEX	11f5c4000031f584
    925  e420
    926  e500					      ORG	$E500,0	; *************
    927  e500
    928  e500							;dhero
    929  e500		       00 00 00 ff*	      HEX	000000ffcc001288
    930  e508							;dhero_tallsprite_00
    931  e508		       fa fa f6 d9*	      HEX	fafaf6d9f5959688
    932  e510							;dhero_tallsprite_01
    933  e510		       00 32 7f ff*	      HEX	00327fffffef0000
    934  e518							;dhero_tallsprite_02
    935  e518		       11 f5 c4 00*	      HEX	11f5c4000031f584
    936  e520
    937  e600					      ORG	$E600,0	; *************
    938  e600
    939  e600							;dhero
    940  e600		       00 00 00 ff*	      HEX	000000ffcc001288
    941  e608							;dhero_tallsprite_00
    942  e608		       fa fa f6 d9*	      HEX	fafaf6d9f5959688
    943  e610							;dhero_tallsprite_01
    944  e610		       00 7a bb ff*	      HEX	007abbffffcc0000
    945  e618							;dhero_tallsprite_02
    946  e618		       00 f5 c4 00*	      HEX	00f5c4000031f500
    947  e620
    948  e700					      ORG	$E700,0	; *************
    949  e700
    950  e700							;dhero
    951  e700		       00 00 00 7f*	      HEX	0000007f8c000000
    952  e708							;dhero_tallsprite_00
    953  e708		       fa f5 b6 d9*	      HEX	faf5b6d9f5b51288
    954  e710							;dhero_tallsprite_01
    955  e710		       00 f9 db ff*	      HEX	00f9dbffff8c0000
    956  e718							;dhero_tallsprite_02
    957  e718		       00 31 c4 00*	      HEX	0031c4000031c400
    958  e720				  -	      if	SPACEOVERFLOW > 0
    959  e720				  -	      echo	""
    960  e720				  -	      echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
    961  e720				  -	      echo	"######## look above for areas with negative ROM space left."
    962  e720				  -	      echo	"######## Aborting assembly."
    963  e720				  -	      ERR
    964  e720					      endif
    965  e720
    966  e720
    967  e720							; Provided under the CC0 license. See the included LICENSE.txt for details.
    968  e720
    969  e720					      ifnconst	bankswitchmode
    970  e720					      if	( * < $f000 )
    971  f000					      ORG	$F000
    972  f000					      endif
    973  f000				  -	      else
    974  f000				  -	      ifconst	ROM128K
    975  f000				  -	      if	( * < $f000 )
    976  f000				  -	      ORG	$27000
    977  f000				  -	      RORG	$F000
    978  f000				  -	      endif
    979  f000				  -	      endif
    980  f000				  -	      ifconst	ROM144K
    981  f000				  -	      if	( * < $f000 )
    982  f000				  -	      ORG	$27000
    983  f000				  -	      RORG	$F000
    984  f000				  -	      endif
    985  f000				  -	      endif
    986  f000				  -	      ifconst	ROM256K
    987  f000				  -	      if	( * < $f000 )
    988  f000				  -	      ORG	$47000
    989  f000				  -	      RORG	$F000
    990  f000				  -	      endif
    991  f000				  -	      endif
    992  f000				  -	      ifconst	ROM272K
    993  f000				  -	      if	( * < $f000 )
    994  f000				  -	      ORG	$47000
    995  f000				  -	      RORG	$F000
    996  f000				  -	      endif
    997  f000				  -	      endif
    998  f000				  -	      ifconst	ROM512K
    999  f000				  -	      if	( * < $f000 )
   1000  f000				  -	      ORG	$87000
   1001  f000				  -	      RORG	$F000
   1002  f000				  -	      endif
   1003  f000				  -	      endif
   1004  f000				  -	      ifconst	ROM528K
   1005  f000				  -	      if	( * < $f000 )
   1006  f000				  -	      ORG	$87000
   1007  f000				  -	      RORG	$F000
   1008  f000				  -	      endif
   1009  f000				  -	      endif
   1010  f000					      endif
   1011  f000
   1012  f000							; all of these "modules" have conditional clauses in them, so even though
   1013  f000							; they're always included here, they don't take up rom unless the user
   1014  f000							; explicitly enables support for the feature.
   1015  f000
   1016  f000					      ifnconst	included.rmtplayer.asm
------- FILE rmtplayer.asm LEVEL 2 PASS 3
      0  f000					      include	rmtplayer.asm	; requires page alignment, so go first
      1  f000				  -	      ifconst	RMT
      2  f000				  -
      3  f000				  -rmtmodulestart
      4  f000				  -
      5  f000				  -			;*
      6  f000				  -			;* Raster Music Tracker, RMT Atari routine version 1.20030223
      7  f000				  -			;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2003
      8  f000				  -			;* http://raster.atari.org
      9  f000				  -			;*
     10  f000				  -			;* Some small changes to allow using this code with DASM cross assembler and
     11  f000				  -			;* to compile for cartridge based systems, like the Atari 5200 or Atari 7800,
     12  f000				  -			;* by Eckhard Stolberg ( http://home.arcor.de/estolberg/ ).
     13  f000				  -			;*
     14  f000				  -			;* Warnings:
     15  f000				  -			;*
     16  f000				  -			;* 1. RMT player routine needs 19 itself reserved bytes in zero page (no accessed
     17  f000				  -			;*    from any other routines) as well as cca 1KB of memory before the "PLAYER"
     18  f000				  -			;*    address for frequency tables and functionary variables. It's:
     19  f000				  -			;*	  a) from PLAYER-$400 to PLAYER for stereo RMTplayer
     20  f000				  -			;*    b) from PLAYER-$380 to PLAYER for mono RMTplayer
     21  f000				  -			;*
     22  f000				  -			;* note: This has been changed for 5200 & 7800 compatibility. Now PLAYER points
     23  f000				  -			;*	  to the start of the frequency tables. The player routines follows after
     24  f000				  -			;*	  that. The variables are now independent and can be located with
     25  f000				  -			;*	  PLAYER_VAR_RAM and PLAYER_ZP_RAM (see below):
     26  f000				  -			;*
     27  f000				  -			;* 2. RMT player routine MUST (!!!) be compiled from the begin of the memory page.
     28  f000				  -			;*    i.e. "PLAYER" address can be $..00 only!
     29  f000				  -			;*
     30  f000				  -			;* 3. Because of RMTplayer provides a lot of effects, it spent a lot of CPU time.
     31  f000				  -			;*
     32  f000				  -			;*
     33  f000				  -			;* Define the following equates here or in your main code file.
     34  f000				  -			;* Set the values according to the system you compile for.
     35  f000				  -			;*
     36  f000				  -
     37  f000				  -POKEY_BASE equ	pokeyaddress
     38  f000				  -PLAYER_ZP_RAM equ	songchannel1layer1lo	; player routine needs 19 bytes of zero page RAM
     39  f000				  -PLAYER_VAR_RAM equ	RMTRAM	;variables in main RAM - 173 bytes mono - 337 stereo
     40  f000				  -ROM_BASED  equ	1	;using a ROM based system - no self modifying code
     41  f000				  -STEREO8T   equ	0	;0 => compile RMTplayer for mono 4 tracks
     42  f000				  -			;				    ;1 => compile RMTplayer for stereo 8 tracks
     43  f000				  -
     44  f000				  -rmt_ispeed equ	PLAYER_ZP_RAM+19
     45  f000				  -rmt_intcount equ	PLAYER_ZP_RAM+20
     46  f000				  -
     47  f000				  -			;*
     48  f000				  -
     49  f000				  -	      IF	STEREO8T
     50  f000				  -TRACKS     equ	8
     51  f000				  -	      ELSE
     52  f000				  -TRACKS     equ	4
     53  f000				  -	      EIF
     54  f000				  -
     55  f000				  -			;*
     56  f000				  -			;* RMT FEATures definitions
     57  f000				  -			;* For optimizations of RMT player routine to concrete RMT modul only!
     58  f000				  -			;* --------BEGIN--------
     59  f000				  -FEAT_COMMAND1 equ	1	;* cca 8 bytes
     60  f000				  -FEAT_COMMAND2 equ	1	;* cca 20 bytes (+save 1 address in zero page) and quicker whole RMT routine
     61  f000				  -FEAT_COMMAND3 equ	1	;* cca 12 bytes
     62  f000				  -FEAT_COMMAND4 equ	1	;* cca 15 bytes
     63  f000				  -FEAT_COMMAND5 equ	1	;* cca 67 bytes
     64  f000				  -FEAT_COMMAND6 equ	1	;* cca 15 bytes
     65  f000				  -			;* COMMAND7 SETNOTE (i.e. command 7 with parameter != $80)
     66  f000				  -FEAT_COMMAND7SETNOTE equ	1	;* cca 12 bytes
     67  f000				  -			;* COMMAND7 VOLUMEONLY (i.e. command 7 with parameter == $80)
     68  f000				  -FEAT_COMMAND7VOLUMEONLY equ	1	;* cca 74 bytes
     69  f000				  -			;* PORTAMENTO
     70  f000				  -FEAT_PORTAMENTO equ	1	;* cca 138 bytes and quicker whole RMT routine
     71  f000				  -			;* FILTER
     72  f000				  -FEAT_FILTER equ	1	;* cca 179 bytes and quicker whole RMT routine
     73  f000				  -FEAT_FILTERG0L equ	1	;* (cca 38 bytes for each)
     74  f000				  -FEAT_FILTERG1L equ	1
     75  f000				  -FEAT_FILTERG0R equ	1
     76  f000				  -FEAT_FILTERG1R equ	1
     77  f000				  -			;* BASS16B (i.e. distortion value 6)
     78  f000				  -FEAT_BASS16 equ	1	;* cca 194 bytes +128bytes freq table and quicker whole RMT routine
     79  f000				  -FEAT_BASS16G1L equ	1	;* (cca 47 bytes for each)
     80  f000				  -FEAT_BASS16G3L equ	1
     81  f000				  -FEAT_BASS16G1R equ	1
     82  f000				  -FEAT_BASS16G3R equ	1
     83  f000				  -			;* VOLUME ONLY for particular generators
     84  f000				  -FEAT_VOLUMEONLYG0L equ	1	;* (cca 7 bytes for each)
     85  f000				  -FEAT_VOLUMEONLYG2L equ	1
     86  f000				  -FEAT_VOLUMEONLYG3L equ	1
     87  f000				  -FEAT_VOLUMEONLYG0R equ	1
     88  f000				  -FEAT_VOLUMEONLYG2R equ	1
     89  f000				  -FEAT_VOLUMEONLYG3R equ	1
     90  f000				  -			;* TABLE TYPE (i.e. TABLETYPE=1)
     91  f000				  -FEAT_TABLETYPE equ	1	;* cca 53 bytes and quicker whole RMT routine
     92  f000				  -			;* TABLE MODE (i.e. TABLEMODE=1)
     93  f000				  -FEAT_TABLEMODE equ	1	;* cca 16 bytes and quicker whole RMT routine
     94  f000				  -			;* AUDCTLMANUALSET (i.e. any MANUAL AUDCTL setting to nonzero value)
     95  f000				  -FEAT_AUDCTLMANUALSET equ	1	;* cca 27 bytes and quicker whole RMT routine
     96  f000				  -			;* --------END--------
     97  f000				  -			;*
     98  f000				  -			;*
     99  f000				  -			;* RMT ZeroPage addresses
    100  f000				  -
    101  f000				  -MEMLOC     SET	PLAYER_ZP_RAM
    102  f000				  -p_tis      =	MEMLOC
    103  f000				  -p_instrstable =	MEMLOC
    104  f000				  -MEMLOC     SET	(MEMLOC+2)
    105  f000				  -p_trackslbstable =	MEMLOC
    106  f000				  -MEMLOC     SET	(MEMLOC+2)
    107  f000				  -p_trackshbstable =	MEMLOC
    108  f000				  -MEMLOC     SET	(MEMLOC+2)
    109  f000				  -p_song     =	MEMLOC
    110  f000				  -MEMLOC     SET	(MEMLOC+2)
    111  f000				  -
    112  f000				  -_ns	      =	MEMLOC
    113  f000				  -MEMLOC     SET	(MEMLOC+2)
    114  f000				  -_nr	      =	MEMLOC
    115  f000				  -MEMLOC     SET	(MEMLOC+2)
    116  f000				  -_nt	      =	MEMLOC
    117  f000				  -MEMLOC     SET	(MEMLOC+2)
    118  f000				  -
    119  f000				  -rmtreg1    =	MEMLOC
    120  f000				  -MEMLOC     SET	(MEMLOC+1)
    121  f000				  -rmtreg2    =	MEMLOC
    122  f000				  -MEMLOC     SET	(MEMLOC+1)
    123  f000				  -rmtreg3    =	MEMLOC
    124  f000				  -MEMLOC     SET	(MEMLOC+1)
    125  f000				  -_tmp       =	MEMLOC
    126  f000				  -MEMLOC     SET	(MEMLOC+1)
    127  f000				  -	      IF	FEAT_COMMAND2
    128  f000				  -frqaddcmd2 =	MEMLOC
    129  f000				  -MEMLOC     SET	(MEMLOC+1)
    130  f000				  -	      EIF
    131  f000				  -
    132  f000				  -			;*
    133  f000				  -			;* Variables in main RAM used by player routine.
    134  f000				  -			;* 337 bytes for stereo - 173 bytes for mono
    135  f000				  -			;*
    136  f000				  -
    137  f000				  -MEMLOC     SET	PLAYER_VAR_RAM
    138  f000				  -track_variables =	MEMLOC
    139  f000				  -
    140  f000				  -trackn_db  =	MEMLOC
    141  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    142  f000				  -trackn_hb  =	MEMLOC
    143  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    144  f000				  -trackn_idx =	MEMLOC
    145  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    146  f000				  -trackn_pause =	MEMLOC
    147  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    148  f000				  -trackn_note =	MEMLOC
    149  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    150  f000				  -trackn_volume =	MEMLOC
    151  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    152  f000				  -trackn_distor =	MEMLOC
    153  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    154  f000				  -trackn_shiftfrq =	MEMLOC
    155  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    156  f000				  -
    157  f000				  -	      IF	FEAT_PORTAMENTO
    158  f000				  -trackn_portafrqc =	MEMLOC
    159  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    160  f000				  -trackn_portafrqa =	MEMLOC
    161  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    162  f000				  -trackn_portaspeed =	MEMLOC
    163  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    164  f000				  -trackn_portaspeeda =	MEMLOC
    165  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    166  f000				  -trackn_portadepth =	MEMLOC
    167  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    168  f000				  -	      EIF
    169  f000				  -
    170  f000				  -trackn_instrx2 =	MEMLOC
    171  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    172  f000				  -trackn_instrdb =	MEMLOC
    173  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    174  f000				  -trackn_instrhb =	MEMLOC
    175  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    176  f000				  -trackn_instridx =	MEMLOC
    177  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    178  f000				  -trackn_instrlen =	MEMLOC
    179  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    180  f000				  -trackn_instrlop =	MEMLOC
    181  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    182  f000				  -trackn_instrreachend =	MEMLOC
    183  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    184  f000				  -trackn_volumeslidedepth =	MEMLOC
    185  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    186  f000				  -trackn_volumeslidevalue =	MEMLOC
    187  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    188  f000				  -trackn_volumemin =	MEMLOC
    189  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    190  f000				  -trackn_effdelay =	MEMLOC
    191  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    192  f000				  -trackn_effvibratoa =	MEMLOC
    193  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    194  f000				  -trackn_effvibratobeg =	MEMLOC
    195  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    196  f000				  -trackn_effvibratoend =	MEMLOC
    197  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    198  f000				  -trackn_effshift =	MEMLOC
    199  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    200  f000				  -trackn_tabletypespeed =	MEMLOC
    201  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    202  f000				  -
    203  f000				  -	      IF	FEAT_TABLEMODE
    204  f000				  -trackn_tablemode =	MEMLOC
    205  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    206  f000				  -	      EIF
    207  f000				  -
    208  f000				  -trackn_tablenote =	MEMLOC
    209  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    210  f000				  -
    211  f000				  -trackn_tablea =	MEMLOC
    212  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    213  f000				  -trackn_tableend =	MEMLOC
    214  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    215  f000				  -trackn_tablelop =	MEMLOC
    216  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    217  f000				  -trackn_tablespeeda =	MEMLOC
    218  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    219  f000				  -trackn_command =	MEMLOC
    220  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    221  f000				  -
    222  f000				  -	      IF	FEAT_BASS16
    223  f000				  -trackn_outnote =	MEMLOC
    224  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    225  f000				  -	      EIF
    226  f000				  -	      IF	FEAT_FILTER
    227  f000				  -trackn_filter =	MEMLOC
    228  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    229  f000				  -	      EIF
    230  f000				  -
    231  f000				  -trackn_audf =	MEMLOC
    232  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    233  f000				  -trackn_audc =	MEMLOC
    234  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    235  f000				  -
    236  f000				  -	      IF	FEAT_AUDCTLMANUALSET
    237  f000				  -trackn_audctl =	MEMLOC
    238  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    239  f000				  -	      EIF
    240  f000				  -
    241  f000				  -v_audctl   =	MEMLOC
    242  f000				  -MEMLOC     SET	(MEMLOC+1)
    243  f000				  -v_audctl2  =	MEMLOC
    244  f000				  -MEMLOC     SET	(MEMLOC+1)
    245  f000				  -v_speed    =	MEMLOC
    246  f000				  -MEMLOC     SET	(MEMLOC+1)
    247  f000				  -v_aspeed   =	MEMLOC
    248  f000				  -MEMLOC     SET	(MEMLOC+1)
    249  f000				  -v_bspeed   =	MEMLOC
    250  f000				  -MEMLOC     SET	(MEMLOC+1)
    251  f000				  -v_instrspeed =	MEMLOC
    252  f000				  -MEMLOC     SET	(MEMLOC+1)
    253  f000				  -v_ainstrspeed =	MEMLOC
    254  f000				  -MEMLOC     SET	(MEMLOC+1)
    255  f000				  -v_maxtracklen =	MEMLOC
    256  f000				  -MEMLOC     SET	(MEMLOC+1)
    257  f000				  -v_abeat    =	MEMLOC
    258  f000				  -MEMLOC     SET	(MEMLOC+1)
    259  f000				  -
    260  f000				  -track_endvariables =	MEMLOC
    261  f000				  -
    262  f000				  -			;*
    263  f000				  -			;* Data tables used by player routine.
    264  f000				  -			;*
    265  f000				  -	      ALIGN	256
    266  f000				  -PLAYER     =	.
    267  f000				  -
    268  f000				  -volumetab
    269  f000				  -	      dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    270  f000				  -	      dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
    271  f000				  -	      dc.b	$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
    272  f000				  -	      dc.b	$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
    273  f000				  -	      dc.b	$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
    274  f000				  -	      dc.b	$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
    275  f000				  -	      dc.b	$00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
    276  f000				  -	      dc.b	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
    277  f000				  -	      dc.b	$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
    278  f000				  -	      dc.b	$00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
    279  f000				  -	      dc.b	$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
    280  f000				  -	      dc.b	$00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
    281  f000				  -	      dc.b	$00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
    282  f000				  -	      dc.b	$00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
    283  f000				  -	      dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
    284  f000				  -	      dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
    285  f000				  -
    286  f000				  -frqtab
    287  f000				  -			;	ERT [<frqtab]!=0	;* frqtab must begin at the memory page bound! (i.e. $..00 address)
    288  f000				  -frqtabbass1
    289  f000				  -	      dc.b	$BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
    290  f000				  -	      dc.b	$98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
    291  f000				  -	      dc.b	$3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
    292  f000				  -	      dc.b	$17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
    293  f000				  -frqtabbass2
    294  f000				  -	      dc.b	$FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
    295  f000				  -	      dc.b	$66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
    296  f000				  -	      dc.b	$28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
    297  f000				  -	      dc.b	$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
    298  f000				  -frqtabpure
    299  f000				  -	      dc.b	$F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
    300  f000				  -	      dc.b	$60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
    301  f000				  -	      dc.b	$25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
    302  f000				  -	      dc.b	$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
    303  f000				  -	      IF	FEAT_BASS16
    304  f000				  -frqtabbasshi
    305  f000				  -	      dc.b	$0D,$0D,$0C,$0B,$0B,$0A,$0A,$09,$08,$08,$07,$07,$07,$06,$06,$05
    306  f000				  -	      dc.b	$05,$05,$04,$04,$04,$04,$03,$03,$03,$03,$03,$02,$02,$02,$02,$02
    307  f000				  -	      dc.b	$02,$02,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$00,$00
    308  f000				  -	      dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    309  f000				  -	      EIF
    310  f000				  -
    311  f000				  -	      IF	FEAT_BASS16
    312  f000				  -frqtabbasslo
    313  f000				  -	      dc.b	$F2,$33,$96,$E2,$38,$8C,$00,$6A,$E8,$6A,$EF,$80,$08,$AE,$46,$E6
    314  f000				  -	      dc.b	$95,$41,$F6,$B0,$6E,$30,$F6,$BB,$84,$52,$22,$F4,$C8,$A0,$7A,$55
    315  f000				  -	      dc.b	$34,$14,$F5,$D8,$BD,$A4,$8D,$77,$60,$4E,$38,$27,$15,$06,$F7,$E8
    316  f000				  -	      dc.b	$DB,$CF,$C3,$B8,$AC,$A2,$9A,$90,$88,$7F,$78,$70,$6A,$64,$5E,$00
    317  f000				  -	      EIF
    318  f000				  -
    319  f000				  -	      IF	ROM_BASED
    320  f000				  -rts_tab    dc.w	cmd0-1,cmd1-1,cmd2-1,cmd3-1,cmd4-1,cmd5-1,cmd6-1,cmd7-1
    321  f000				  -	      EIF
    322  f000				  -INSTRPAR   equ	12
    323  f000				  -tabbeganddistor
    324  f000				  -	      dc.b	frqtabpure-frqtab,$00
    325  f000				  -	      dc.b	frqtabpure-frqtab,$20
    326  f000				  -	      dc.b	frqtabpure-frqtab,$40
    327  f000				  -	      dc.b	frqtabbass1-frqtab,$c0
    328  f000				  -	      dc.b	frqtabpure-frqtab,$80
    329  f000				  -	      dc.b	frqtabpure-frqtab,$a0
    330  f000				  -	      dc.b	frqtabbass1-frqtab,$c0
    331  f000				  -	      dc.b	frqtabbass2-frqtab,$c0
    332  f000				  -vibtabbeg  dc.b	0,vib1-vib0,vib2-vib0,vib3-vib0,vibx-vib0
    333  f000				  -vib0       dc.b	0
    334  f000				  -vib1       dc.b	1,-1,-1,1
    335  f000				  -vib2       dc.b	1,0,-1,-1,0,1
    336  f000				  -vib3       dc.b	1,1,0,-1,-1,-1,-1,0,1,1
    337  f000				  -vibx
    338  f000				  -emptytrack
    339  f000				  -	      dc.b	62,0
    340  f000				  -
    341  f000				  -			;*
    342  f000				  -			;* Set of RMT main vectors:
    343  f000				  -			;*
    344  f000				  -RASTERMUSICTRACKER
    345  f000				  -	      jmp	rmt_init
    346  f000				  -	      jmp	rmt_play
    347  f000				  -	      jmp	rmt_p3
    348  f000				  -	      jmp	rmt_silence
    349  f000				  -	      jmp	SetPokey
    350  f000				  -rmt_init
    351  f000				  -	      stx	_ns
    352  f000				  -	      sty	_ns+1
    353  f000				  -	      pha
    354  f000				  -	      IF	track_endvariables-track_variables>255
    355  f000				  -	      ldy	#0
    356  f000				  -	      tya
    357  f000				  -rmtri0     sta	track_variables,y
    358  f000				  -	      sta	track_endvariables-$100,y
    359  f000				  -	      iny
    360  f000				  -	      bne	rmtri0
    361  f000				  -	      ELSE
    362  f000				  -	      ldy	#track_endvariables-track_variables
    363  f000				  -	      lda	#0
    364  f000				  -rmtri0     sta	track_variables-1,y
    365  f000				  -	      dey
    366  f000				  -	      bne	rmtri0
    367  f000				  -	      EIF
    368  f000				  -	      ldy	#4
    369  f000				  -	      lda	(_ns),y
    370  f000				  -	      sta	v_maxtracklen
    371  f000				  -	      iny
    372  f000				  -	      lda	(_ns),y
    373  f000				  -	      sta	v_speed
    374  f000				  -	      iny
    375  f000				  -	      lda	(_ns),y
    376  f000				  -	      sta	v_instrspeed
    377  f000				  -	      sta	v_ainstrspeed
    378  f000				  -	      ldy	#8
    379  f000				  -rmtri1     lda	(_ns),y
    380  f000				  -	      sta	p_tis-8,y
    381  f000				  -	      iny
    382  f000				  -	      cpy	#8+8
    383  f000				  -	      bne	rmtri1
    384  f000				  -	      pla
    385  f000				  -	      pha
    386  f000				  -	      IF	STEREO8T
    387  f000				  -	      asl
    388  f000				  -	      asl
    389  f000				  -	      asl
    390  f000				  -	      clc
    391  f000				  -	      adc	p_song
    392  f000				  -	      sta	p_song
    393  f000				  -	      pla
    394  f000				  -	      and	#$e0
    395  f000				  -	      asl
    396  f000				  -	      rol
    397  f000				  -	      rol
    398  f000				  -	      rol
    399  f000				  -	      ELSE
    400  f000				  -	      asl
    401  f000				  -	      asl
    402  f000				  -	      clc
    403  f000				  -	      adc	p_song
    404  f000				  -	      sta	p_song
    405  f000				  -	      pla
    406  f000				  -	      and	#$c0
    407  f000				  -	      asl
    408  f000				  -	      rol
    409  f000				  -	      rol
    410  f000				  -	      EIF
    411  f000				  -	      adc	p_song+1
    412  f000				  -	      sta	p_song+1
    413  f000				  -	      jsr	GetSongLine
    414  f000				  -	      jsr	GetTrackLine
    415  f000				  -	      jsr	InitOfNewSetInstrumentsOnly
    416  f000				  -	      jsr	rmt_silence
    417  f000				  -	      lda	v_instrspeed
    418  f000				  -	      rts
    419  f000				  -rmt_silence
    420  f000				  -	      IF	STEREO8T
    421  f000				  -	      lda	#0
    422  f000				  -	      sta	POKEY_BASE+$08
    423  f000				  -	      sta	POKEY_BASE_S+$08
    424  f000				  -	      ldy	#3
    425  f000				  -	      sty	POKEY_BASE+$0f
    426  f000				  -	      sty	POKEY_BASE_S+$0f
    427  f000				  -	      ldy	#8
    428  f000				  -rmtsi1     sta	POKEY_BASE+$00,y
    429  f000				  -	      sta	POKEY_BASE_S+$00,y
    430  f000				  -	      dey
    431  f000				  -	      bpl	rmtsi1
    432  f000				  -	      ELSE
    433  f000				  -	      lda	#0
    434  f000				  -	      sta	POKEY_BASE+$08
    435  f000				  -	      ldy	#3
    436  f000				  -	      sty	POKEY_BASE+$0f
    437  f000				  -	      ldy	#8
    438  f000				  -rmtsi1     sta	POKEY_BASE+$00,y
    439  f000				  -	      dey
    440  f000				  -	      bpl	rmtsi1
    441  f000				  -	      EIF
    442  f000				  -	      rts
    443  f000				  -GetSongLine
    444  f000				  -	      ldx	#0
    445  f000				  -	      stx	v_abeat
    446  f000				  -rmtnn0
    447  f000				  -	      ldx	#0
    448  f000				  -rmtnn1     txa
    449  f000				  -	      tay
    450  f000				  -	      lda	(p_song),y
    451  f000				  -	      cmp	#$fe
    452  f000				  -	      bcs	rmtnn2
    453  f000				  -	      tay
    454  f000				  -	      lda	(p_trackslbstable),y
    455  f000				  -	      sta	trackn_db,x
    456  f000				  -	      lda	(p_trackshbstable),y
    457  f000				  -rmtnn1a    sta	trackn_hb,x
    458  f000				  -	      lda	#0
    459  f000				  -	      sta	trackn_idx,x
    460  f000				  -	      lda	#1
    461  f000				  -	      sta	trackn_pause,x
    462  f000				  -	      lda	#$80
    463  f000				  -	      sta	trackn_instrx2,x
    464  f000				  -	      inx
    465  f000				  -	      cpx	#TRACKS
    466  f000				  -	      bne	rmtnn1
    467  f000				  -	      lda	p_song
    468  f000				  -	      clc
    469  f000				  -	      adc	#TRACKS
    470  f000				  -	      sta	p_song
    471  f000				  -	      bcc	rmtnn1b
    472  f000				  -	      inc	p_song+1
    473  f000				  -rmtnn1b
    474  f000				  -	      rts
    475  f000				  -rmtnn2
    476  f000				  -	      beq	rmtnn3
    477  f000				  -rmtnn2a    lda	#<emptytrack
    478  f000				  -	      sta	trackn_db,x
    479  f000				  -	      lda	#>emptytrack
    480  f000				  -	      jmp	rmtnn1a
    481  f000				  -rmtnn3
    482  f000				  -	      ldy	#2
    483  f000				  -	      lda	(p_song),y
    484  f000				  -	      tax
    485  f000				  -	      iny
    486  f000				  -	      lda	(p_song),y
    487  f000				  -	      sta	p_song+1
    488  f000				  -	      stx	p_song
    489  f000				  -	      jmp	rmtnn0
    490  f000				  -GetTrackLine
    491  f000				  -rmtoo0
    492  f000				  -rmtoo0a
    493  f000				  -	      lda	v_speed
    494  f000				  -	      sta	v_bspeed
    495  f000				  -	      ldx	#0
    496  f000				  -rmtoo1
    497  f000				  -	      lda	trackn_pause,x
    498  f000				  -	      beq	rmtoo1x
    499  f000				  -	      dec	trackn_pause,x
    500  f000				  -	      bne	rmtoo1x
    501  f000				  -	      inc	trackn_pause,x
    502  f000				  -rmtoo1b
    503  f000				  -	      lda	trackn_db,x
    504  f000				  -	      sta	_ns
    505  f000				  -	      lda	trackn_hb,x
    506  f000				  -	      sta	_ns+1
    507  f000				  -rmtoo1i
    508  f000				  -	      ldy	trackn_idx,x
    509  f000				  -	      lda	(_ns),y
    510  f000				  -	      sta	rmtreg1
    511  f000				  -	      iny
    512  f000				  -	      lda	(_ns),y
    513  f000				  -	      sta	rmtreg2
    514  f000				  -	      iny
    515  f000				  -	      tya
    516  f000				  -	      sta	trackn_idx,x
    517  f000				  -	      lda	rmtreg1
    518  f000				  -	      and	#$3f
    519  f000				  -	      cmp	#61
    520  f000				  -	      beq	rmtoo1a
    521  f000				  -	      bcs	rmtoo2
    522  f000				  -	      sta	trackn_note,x
    523  f000				  -	      IF	FEAT_BASS16
    524  f000				  -	      sta	trackn_outnote,x
    525  f000				  -	      EIF
    526  f000				  -	      lda	rmtreg2
    527  f000				  -	      lsr
    528  f000				  -	      and	#$3f*2
    529  f000				  -	      sta	trackn_instrx2,x
    530  f000				  -rmtoo1a    lda	rmtreg2
    531  f000				  -	      lsr
    532  f000				  -	      ror	rmtreg1
    533  f000				  -	      lsr
    534  f000				  -	      ror	rmtreg1
    535  f000				  -	      lda	rmtreg1
    536  f000				  -	      and	#$f0
    537  f000				  -	      sta	trackn_volume,x
    538  f000				  -rmtoo1x
    539  f000				  -	      inx
    540  f000				  -	      cpx	#TRACKS
    541  f000				  -	      bne	rmtoo1
    542  f000				  -	      lda	v_bspeed
    543  f000				  -	      sta	v_speed
    544  f000				  -	      sta	v_aspeed
    545  f000				  -	      rts
    546  f000				  -rmtoo2
    547  f000				  -	      cmp	#63
    548  f000				  -	      beq	rmtoo63
    549  f000				  -	      lda	rmtreg1
    550  f000				  -	      and	#$c0
    551  f000				  -	      beq	rmtoo62_b
    552  f000				  -	      asl
    553  f000				  -	      rol
    554  f000				  -	      rol
    555  f000				  -	      sta	trackn_pause,x
    556  f000				  -	      dec	trackn_idx,x
    557  f000				  -	      jmp	rmtoo1x
    558  f000				  -rmtoo62_b
    559  f000				  -	      lda	rmtreg2
    560  f000				  -	      sta	trackn_pause,x
    561  f000				  -	      jmp	rmtoo1x
    562  f000				  -rmtoo63
    563  f000				  -	      lda	rmtreg1
    564  f000				  -	      bmi	rmtoo63_1X
    565  f000				  -	      lda	rmtreg2
    566  f000				  -	      sta	v_bspeed
    567  f000				  -	      jmp	rmtoo1i
    568  f000				  -rmtoo63_1X
    569  f000				  -	      cmp	#255
    570  f000				  -	      beq	rmtoo63_11
    571  f000				  -	      lda	rmtreg2
    572  f000				  -	      sta	trackn_idx,x
    573  f000				  -	      jmp	rmtoo1i
    574  f000				  -rmtoo63_11
    575  f000				  -	      jsr	GetSongLine
    576  f000				  -	      jmp	rmtoo0
    577  f000				  -InitOfNewSetInstrumentsOnly
    578  f000				  -	      ldx	#0
    579  f000				  -p2x1       ldy	trackn_instrx2,x
    580  f000				  -	      bmi	p2x2
    581  f000				  -	      jsr	SetUpInstrumentY2
    582  f000				  -	      lda	#$80
    583  f000				  -	      sta	trackn_instrx2,x
    584  f000				  -p2x2
    585  f000				  -	      inx
    586  f000				  -	      cpx	#TRACKS
    587  f000				  -	      bne	p2x1
    588  f000				  -	      rts
    589  f000				  -rmt_play
    590  f000				  -rmt_p0
    591  f000				  -	      jsr	SetPokey
    592  f000				  -rmt_p1
    593  f000				  -	      dec	v_ainstrspeed
    594  f000				  -	      beq	rmtp1a
    595  f000				  -	      jmp	rmt_p3
    596  f000				  -rmtp1a
    597  f000				  -	      lda	v_instrspeed
    598  f000				  -	      sta	v_ainstrspeed
    599  f000				  -rmt_p2
    600  f000				  -	      dec	v_aspeed
    601  f000				  -	      bne	rmt_p3
    602  f000				  -	      inc	v_abeat
    603  f000				  -	      lda	v_abeat
    604  f000				  -	      cmp	v_maxtracklen
    605  f000				  -	      bne	rmtp2o2
    606  f000				  -	      jsr	GetSongLine
    607  f000				  -rmtp2o2
    608  f000				  -	      jsr	GetTrackLine
    609  f000				  -	      jmp	rmt_p2X
    610  f000				  -go_ppnext  jmp	ppnext
    611  f000				  -rmt_p2X
    612  f000				  -	      jsr	InitOfNewSetInstrumentsOnly
    613  f000				  -rmt_p3
    614  f000				  -	      lda	#>frqtab
    615  f000				  -	      sta	_nr+1
    616  f000				  -	      ldx	#0
    617  f000				  -rmtpp1
    618  f000				  -	      lda	trackn_instrhb,x
    619  f000				  -	      beq	go_ppnext
    620  f000				  -	      sta	_ns+1
    621  f000				  -	      lda	trackn_instrdb,x
    622  f000				  -	      sta	_ns
    623  f000				  -	      ldy	trackn_instridx,x
    624  f000				  -	      lda	(_ns),y
    625  f000				  -	      sta	rmtreg1
    626  f000				  -	      iny
    627  f000				  -	      lda	(_ns),y
    628  f000				  -	      sta	rmtreg2
    629  f000				  -	      iny
    630  f000				  -	      lda	(_ns),y
    631  f000				  -	      sta	rmtreg3
    632  f000				  -	      iny
    633  f000				  -	      tya
    634  f000				  -	      cmp	trackn_instrlen,x
    635  f000				  -	      bcc	rmtpp2
    636  f000				  -	      beq	rmtpp2
    637  f000				  -	      lda	#$80
    638  f000				  -	      sta	trackn_instrreachend,x
    639  f000				  -rmtpp1b
    640  f000				  -	      lda	trackn_instrlop,x
    641  f000				  -rmtpp2     sta	trackn_instridx,x
    642  f000				  -	      lda	rmtreg1
    643  f000				  -	      IF	STEREO8T
    644  f000				  -	      cpx	#4
    645  f000				  -	      bcc	rmtpp2s
    646  f000				  -	      lsr
    647  f000				  -	      lsr
    648  f000				  -	      lsr
    649  f000				  -	      lsr
    650  f000				  -rmtpp2s
    651  f000				  -	      EIF
    652  f000				  -	      and	#$0f
    653  f000				  -	      ora	trackn_volume,x
    654  f000				  -	      tay
    655  f000				  -	      lda	volumetab,y
    656  f000				  -	      pha
    657  f000				  -	      lda	rmtreg2
    658  f000				  -	      and	#$0e
    659  f000				  -	      tay
    660  f000				  -	      lda	tabbeganddistor,y
    661  f000				  -	      sta	_nr
    662  f000				  -	      pla
    663  f000				  -	      ora	tabbeganddistor+1,y
    664  f000				  -	      sta	trackn_audc,x
    665  f000				  -	      jmp	InstrumentsEffects
    666  f000				  -returnfromInstrumentsEffects
    667  f000				  -	      IF	FEAT_COMMAND2
    668  f000				  -	      lda	#0
    669  f000				  -	      sta	frqaddcmd2
    670  f000				  -	      EIF
    671  f000				  -	      lda	rmtreg2
    672  f000				  -	      sta	trackn_command,x
    673  f000				  -	      and	#$70
    674  f000				  -	      lsr
    675  f000				  -	      lsr
    676  f000				  -	      IF	ROM_BASED
    677  f000				  -	      lsr
    678  f000				  -	      tay
    679  f000				  -	      lda	rts_tab+1,y
    680  f000				  -	      pha
    681  f000				  -	      lda	rts_tab,y
    682  f000				  -	      pha
    683  f000				  -	      rts
    684  f000				  -	      ELSE
    685  f000				  -	      sta	jmx+1
    686  f000				  -jmx	      bcc	*
    687  f000				  -	      jmp	cmd0
    688  f000				  -	      nop
    689  f000				  -	      jmp	cmd1
    690  f000				  -	      nop
    691  f000				  -	      jmp	cmd2
    692  f000				  -	      nop
    693  f000				  -	      jmp	cmd3
    694  f000				  -	      nop
    695  f000				  -	      jmp	cmd4
    696  f000				  -	      nop
    697  f000				  -	      jmp	cmd5
    698  f000				  -	      nop
    699  f000				  -	      jmp	cmd6
    700  f000				  -	      nop
    701  f000				  -	      jmp	cmd7
    702  f000				  -	      EIF
    703  f000				  -cmd0
    704  f000				  -	      lda	trackn_note,x
    705  f000				  -	      clc
    706  f000				  -	      adc	rmtreg3
    707  f000				  -cmd0a
    708  f000				  -	      IF	FEAT_TABLETYPE
    709  f000				  -	      ldy	trackn_tabletypespeed,x
    710  f000				  -	      bmi	cmd0b
    711  f000				  -	      EIF
    712  f000				  -	      clc
    713  f000				  -	      adc	trackn_tablenote,x
    714  f000				  -	      cmp	#61
    715  f000				  -	      bcc	cmd0a1
    716  f000				  -	      lda	#0
    717  f000				  -	      sta	trackn_audc,x
    718  f000				  -	      lda	#63
    719  f000				  -cmd0a1
    720  f000				  -	      IF	FEAT_BASS16
    721  f000				  -	      sta	trackn_outnote,x
    722  f000				  -	      EIF
    723  f000				  -	      tay
    724  f000				  -	      lda	(_nr),y
    725  f000				  -	      clc
    726  f000				  -	      adc	trackn_shiftfrq,x
    727  f000				  -	      IF	FEAT_COMMAND2
    728  f000				  -	      clc
    729  f000				  -	      adc	frqaddcmd2
    730  f000				  -	      EIF
    731  f000				  -	      sta	trackn_audf,x
    732  f000				  -	      jmp	rmtpp9
    733  f000				  -	      IF	FEAT_TABLETYPE
    734  f000				  -cmd0b
    735  f000				  -	      cmp	#61
    736  f000				  -	      bcc	cmd0b1
    737  f000				  -	      lda	#0
    738  f000				  -	      sta	trackn_audc,x
    739  f000				  -	      lda	#63
    740  f000				  -cmd0b1
    741  f000				  -	      tay
    742  f000				  -	      lda	trackn_shiftfrq,x
    743  f000				  -	      clc
    744  f000				  -	      adc	trackn_tablenote,x
    745  f000				  -	      clc
    746  f000				  -	      adc	(_nr),y
    747  f000				  -	      IF	FEAT_COMMAND2
    748  f000				  -	      clc
    749  f000				  -	      adc	frqaddcmd2
    750  f000				  -	      EIF
    751  f000				  -	      sta	trackn_audf,x
    752  f000				  -	      jmp	rmtpp9
    753  f000				  -	      EIF
    754  f000				  -cmd1
    755  f000				  -	      IF	FEAT_COMMAND1
    756  f000				  -	      lda	rmtreg3
    757  f000				  -	      sta	trackn_audf,x
    758  f000				  -	      jmp	rmtpp9
    759  f000				  -	      EIF
    760  f000				  -cmd2
    761  f000				  -	      IF	FEAT_COMMAND2
    762  f000				  -	      lda	rmtreg3
    763  f000				  -	      sta	frqaddcmd2
    764  f000				  -	      lda	trackn_note,x
    765  f000				  -	      jmp	cmd0a
    766  f000				  -	      EIF
    767  f000				  -cmd3
    768  f000				  -	      IF	FEAT_COMMAND3
    769  f000				  -	      lda	trackn_note,x
    770  f000				  -	      clc
    771  f000				  -	      adc	rmtreg3
    772  f000				  -	      sta	trackn_note,x
    773  f000				  -	      jmp	cmd0a
    774  f000				  -	      EIF
    775  f000				  -cmd4
    776  f000				  -	      IF	FEAT_COMMAND4
    777  f000				  -	      lda	trackn_shiftfrq,x
    778  f000				  -	      clc
    779  f000				  -	      adc	rmtreg3
    780  f000				  -	      sta	trackn_shiftfrq,x
    781  f000				  -	      lda	trackn_note,x
    782  f000				  -	      jmp	cmd0a
    783  f000				  -	      EIF
    784  f000				  -cmd5
    785  f000				  -	      IF	FEAT_COMMAND5&&FEAT_PORTAMENTO
    786  f000				  -	      IF	FEAT_TABLETYPE
    787  f000				  -	      lda	trackn_tabletypespeed,x
    788  f000				  -	      bpl	cmd5a1
    789  f000				  -	      ldy	trackn_note,x
    790  f000				  -	      lda	(_nr),y
    791  f000				  -	      clc
    792  f000				  -	      adc	trackn_tablenote,x
    793  f000				  -	      jmp	cmd5ax
    794  f000				  -	      EIF
    795  f000				  -cmd5a1
    796  f000				  -	      lda	trackn_note,x
    797  f000				  -	      clc
    798  f000				  -	      adc	trackn_tablenote,x
    799  f000				  -	      cmp	#61
    800  f000				  -	      bcc	cmd5a2
    801  f000				  -	      lda	#63
    802  f000				  -cmd5a2
    803  f000				  -	      tay
    804  f000				  -	      lda	(_nr),y
    805  f000				  -cmd5ax
    806  f000				  -	      sta	trackn_portafrqc,x
    807  f000				  -	      ldy	rmtreg3
    808  f000				  -	      bne	cmd5a
    809  f000				  -	      sta	trackn_portafrqa,x
    810  f000				  -cmd5a
    811  f000				  -	      tya
    812  f000				  -	      lsr
    813  f000				  -	      lsr
    814  f000				  -	      lsr
    815  f000				  -	      lsr
    816  f000				  -	      sta	trackn_portaspeed,x
    817  f000				  -	      sta	trackn_portaspeeda,x
    818  f000				  -	      lda	rmtreg3
    819  f000				  -	      and	#$0f
    820  f000				  -	      sta	trackn_portadepth,x
    821  f000				  -	      lda	trackn_note,x
    822  f000				  -	      jmp	cmd0a
    823  f000				  -	      ELSE
    824  f000				  -	      IF	FEAT_COMMAND5
    825  f000				  -	      jmp	rmtpp9
    826  f000				  -	      EIF
    827  f000				  -	      EIF
    828  f000				  -cmd6
    829  f000				  -	      IF	FEAT_COMMAND6&&FEAT_FILTER
    830  f000				  -	      lda	rmtreg3
    831  f000				  -	      clc
    832  f000				  -	      adc	trackn_filter,x
    833  f000				  -	      sta	trackn_filter,x
    834  f000				  -	      lda	trackn_note,x
    835  f000				  -	      jmp	cmd0a
    836  f000				  -	      ELSE
    837  f000				  -	      IF	FEAT_COMMAND6
    838  f000				  -	      jmp	rmtpp9
    839  f000				  -	      EIF
    840  f000				  -	      EIF
    841  f000				  -cmd7
    842  f000				  -	      IF	FEAT_COMMAND7SETNOTE||FEAT_COMMAND7VOLUMEONLY
    843  f000				  -	      IF	FEAT_COMMAND7SETNOTE
    844  f000				  -	      lda	rmtreg3
    845  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY
    846  f000				  -	      cmp	#$80
    847  f000				  -	      beq	cmd7a
    848  f000				  -	      EIF
    849  f000				  -	      sta	trackn_note,x
    850  f000				  -	      jmp	cmd0a
    851  f000				  -	      EIF
    852  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY
    853  f000				  -cmd7a
    854  f000				  -	      lda	trackn_audc,x
    855  f000				  -	      ora	#$f0
    856  f000				  -	      sta	trackn_audc,x
    857  f000				  -	      lda	trackn_note,x
    858  f000				  -	      jmp	cmd0a
    859  f000				  -	      EIF
    860  f000				  -	      EIF
    861  f000				  -rmtpp9
    862  f000				  -	      IF	FEAT_PORTAMENTO
    863  f000				  -	      lda	trackn_portaspeeda,x
    864  f000				  -	      beq	rmtpp10
    865  f000				  -	      sec
    866  f000				  -	      sbc	#1
    867  f000				  -	      sta	trackn_portaspeeda,x
    868  f000				  -	      bne	rmtpp10
    869  f000				  -	      lda	trackn_portaspeed,x
    870  f000				  -	      sta	trackn_portaspeeda,x
    871  f000				  -	      lda	trackn_portafrqa,x
    872  f000				  -	      cmp	trackn_portafrqc,x
    873  f000				  -	      beq	rmtpp10
    874  f000				  -	      bcs	pps1
    875  f000				  -	      adc	trackn_portadepth,x
    876  f000				  -	      bcs	pps8
    877  f000				  -	      cmp	trackn_portafrqc,x
    878  f000				  -	      bcs	pps8
    879  f000				  -	      jmp	pps9
    880  f000				  -pps1
    881  f000				  -	      sbc	trackn_portadepth,x
    882  f000				  -	      bcc	pps8
    883  f000				  -	      cmp	trackn_portafrqc,x
    884  f000				  -	      bcs	pps9
    885  f000				  -pps8
    886  f000				  -	      lda	trackn_portafrqc,x
    887  f000				  -pps9
    888  f000				  -	      sta	trackn_portafrqa,x
    889  f000				  -rmtpp10
    890  f000				  -	      lda	rmtreg2
    891  f000				  -	      and	#$01
    892  f000				  -	      beq	rmtpp11
    893  f000				  -	      lda	trackn_portafrqa,x
    894  f000				  -	      clc
    895  f000				  -	      adc	trackn_shiftfrq,x
    896  f000				  -	      sta	trackn_audf,x
    897  f000				  -rmtpp11
    898  f000				  -	      EIF
    899  f000				  -ppnext
    900  f000				  -	      inx
    901  f000				  -	      cpx	#TRACKS
    902  f000				  -	      beq	rmt_p4
    903  f000				  -	      jmp	rmtpp1
    904  f000				  -rmt_p4
    905  f000				  -	      IF	FEAT_AUDCTLMANUALSET
    906  f000				  -	      ldx	#3
    907  f000				  -	      lda	#0
    908  f000				  -qq0	      ora	trackn_audctl,x
    909  f000				  -	      dex
    910  f000				  -	      bpl	qq0
    911  f000				  -	      sta	v_audctl
    912  f000				  -qq1
    913  f000				  -	      ldx	v_audctl
    914  f000				  -	      ELSE
    915  f000				  -	      ldx	#0
    916  f000				  -	      stx	v_audctl
    917  f000				  -	      EIF
    918  f000				  -	      IF	FEAT_FILTER
    919  f000				  -	      IF	FEAT_FILTERG0L
    920  f000				  -	      lda	trackn_command+0
    921  f000				  -	      bpl	qq2
    922  f000				  -	      lda	trackn_audc+0
    923  f000				  -	      and	#$0f
    924  f000				  -	      beq	qq2
    925  f000				  -	      lda	trackn_audf+0
    926  f000				  -	      clc
    927  f000				  -	      adc	trackn_filter+0
    928  f000				  -	      sta	trackn_audf+2
    929  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
    930  f000				  -	      lda	trackn_audc+2
    931  f000				  -	      and	#$10
    932  f000				  -	      bne	qq1a
    933  f000				  -	      EIF
    934  f000				  -	      lda	#0
    935  f000				  -	      sta	trackn_audc+2
    936  f000				  -qq1a
    937  f000				  -	      txa
    938  f000				  -	      ora	#4
    939  f000				  -	      tax
    940  f000				  -	      EIF
    941  f000				  -qq2
    942  f000				  -	      IF	FEAT_FILTERG1L
    943  f000				  -	      lda	trackn_command+1
    944  f000				  -	      bpl	qq3
    945  f000				  -	      lda	trackn_audc+1
    946  f000				  -	      and	#$0f
    947  f000				  -	      beq	qq3
    948  f000				  -	      lda	trackn_audf+1
    949  f000				  -	      clc
    950  f000				  -	      adc	trackn_filter+1
    951  f000				  -	      sta	trackn_audf+3
    952  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3L
    953  f000				  -	      lda	trackn_audc+3
    954  f000				  -	      and	#$10
    955  f000				  -	      bne	qq2a
    956  f000				  -	      EIF
    957  f000				  -	      lda	#0
    958  f000				  -	      sta	trackn_audc+3
    959  f000				  -qq2a
    960  f000				  -	      txa
    961  f000				  -	      ora	#2
    962  f000				  -	      tax
    963  f000				  -	      EIF
    964  f000				  -qq3
    965  f000				  -	      IF	FEAT_FILTERG0L||FEAT_FILTERG1L
    966  f000				  -	      cpx	v_audctl
    967  f000				  -	      bne	qq5
    968  f000				  -	      EIF
    969  f000				  -	      EIF
    970  f000				  -	      IF	FEAT_BASS16
    971  f000				  -	      IF	FEAT_BASS16G1L
    972  f000				  -	      lda	trackn_command+1
    973  f000				  -	      and	#$0e
    974  f000				  -	      cmp	#6
    975  f000				  -	      bne	qq4
    976  f000				  -	      lda	trackn_audc+1
    977  f000				  -	      and	#$0f
    978  f000				  -	      beq	qq4
    979  f000				  -	      ldy	trackn_outnote+1
    980  f000				  -	      lda	frqtabbasslo,y
    981  f000				  -	      sta	trackn_audf+0
    982  f000				  -	      lda	frqtabbasshi,y
    983  f000				  -	      sta	trackn_audf+1
    984  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0L
    985  f000				  -	      lda	trackn_audc+0
    986  f000				  -	      and	#$10
    987  f000				  -	      bne	qq3a
    988  f000				  -	      EIF
    989  f000				  -	      lda	#0
    990  f000				  -	      sta	trackn_audc+0
    991  f000				  -qq3a
    992  f000				  -	      txa
    993  f000				  -	      ora	#$50
    994  f000				  -	      tax
    995  f000				  -	      EIF
    996  f000				  -qq4
    997  f000				  -	      IF	FEAT_BASS16G3L
    998  f000				  -	      lda	trackn_command+3
    999  f000				  -	      and	#$0e
   1000  f000				  -	      cmp	#6
   1001  f000				  -	      bne	qq5
   1002  f000				  -	      lda	trackn_audc+3
   1003  f000				  -	      and	#$0f
   1004  f000				  -	      beq	qq5
   1005  f000				  -	      ldy	trackn_outnote+3
   1006  f000				  -	      lda	frqtabbasslo,y
   1007  f000				  -	      sta	trackn_audf+2
   1008  f000				  -	      lda	frqtabbasshi,y
   1009  f000				  -	      sta	trackn_audf+3
   1010  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1011  f000				  -	      lda	trackn_audc+2
   1012  f000				  -	      and	#$10
   1013  f000				  -	      bne	qq4a
   1014  f000				  -	      EIF
   1015  f000				  -	      lda	#0
   1016  f000				  -	      sta	trackn_audc+2
   1017  f000				  -qq4a
   1018  f000				  -	      txa
   1019  f000				  -	      ora	#$28
   1020  f000				  -	      tax
   1021  f000				  -	      EIF
   1022  f000				  -	      EIF
   1023  f000				  -qq5
   1024  f000				  -	      stx	v_audctl
   1025  f000				  -	      IF	STEREO8T
   1026  f000				  -	      IF	FEAT_AUDCTLMANUALSET
   1027  f000				  -	      ldx	#3
   1028  f000				  -	      lda	#0
   1029  f000				  -qs0	      ora	trackn_audctl+4,x
   1030  f000				  -	      dex
   1031  f000				  -	      bpl	qs0
   1032  f000				  -	      sta	v_audctl2
   1033  f000				  -qs1
   1034  f000				  -	      ldx	v_audctl2
   1035  f000				  -	      ELSE
   1036  f000				  -	      ldx	#0
   1037  f000				  -	      stx	v_audctl2
   1038  f000				  -	      EIF
   1039  f000				  -	      IF	FEAT_FILTER
   1040  f000				  -	      IF	FEAT_FILTERG0R
   1041  f000				  -	      lda	trackn_command+0+4
   1042  f000				  -	      bpl	qs2
   1043  f000				  -	      lda	trackn_audc+0+4
   1044  f000				  -	      and	#$0f
   1045  f000				  -	      beq	qs2
   1046  f000				  -	      lda	trackn_audf+0+4
   1047  f000				  -	      clc
   1048  f000				  -	      adc	trackn_filter+0+4
   1049  f000				  -	      sta	trackn_audf+2+4
   1050  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1051  f000				  -	      lda	trackn_audc+2+4
   1052  f000				  -	      and	#$10
   1053  f000				  -	      bne	qs1a
   1054  f000				  -	      EIF
   1055  f000				  -	      lda	#0
   1056  f000				  -	      sta	trackn_audc+2+4
   1057  f000				  -qs1a
   1058  f000				  -	      txa
   1059  f000				  -	      ora	#4
   1060  f000				  -	      tax
   1061  f000				  -	      EIF
   1062  f000				  -qs2
   1063  f000				  -	      IF	FEAT_FILTERG1R
   1064  f000				  -	      lda	trackn_command+1+4
   1065  f000				  -	      bpl	qs3
   1066  f000				  -	      lda	trackn_audc+1+4
   1067  f000				  -	      and	#$0f
   1068  f000				  -	      beq	qs3
   1069  f000				  -	      lda	trackn_audf+1+4
   1070  f000				  -	      clc
   1071  f000				  -	      adc	trackn_filter+1+4
   1072  f000				  -	      sta	trackn_audf+3+4
   1073  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3R
   1074  f000				  -	      lda	trackn_audc+3+4
   1075  f000				  -	      and	#$10
   1076  f000				  -	      bne	qs2a
   1077  f000				  -	      EIF
   1078  f000				  -	      lda	#0
   1079  f000				  -	      sta	trackn_audc+3+4
   1080  f000				  -qs2a
   1081  f000				  -	      txa
   1082  f000				  -	      ora	#2
   1083  f000				  -	      tax
   1084  f000				  -	      EIF
   1085  f000				  -qs3
   1086  f000				  -	      IF	FEAT_FILTERG0R||FEAT_FILTERG1R
   1087  f000				  -	      cpx	v_audctl2
   1088  f000				  -	      bne	qs5
   1089  f000				  -	      EIF
   1090  f000				  -	      EIF
   1091  f000				  -	      IF	FEAT_BASS16
   1092  f000				  -	      IF	FEAT_BASS16G1R
   1093  f000				  -	      lda	trackn_command+1+4
   1094  f000				  -	      and	#$0e
   1095  f000				  -	      cmp	#6
   1096  f000				  -	      bne	qs4
   1097  f000				  -	      lda	trackn_audc+1+4
   1098  f000				  -	      and	#$0f
   1099  f000				  -	      beq	qs4
   1100  f000				  -	      ldy	trackn_outnote+1+4
   1101  f000				  -	      lda	frqtabbasslo,y
   1102  f000				  -	      sta	trackn_audf+0+4
   1103  f000				  -	      lda	frqtabbasshi,y
   1104  f000				  -	      sta	trackn_audf+1+4
   1105  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0R
   1106  f000				  -	      lda	trackn_audc+0+4
   1107  f000				  -	      and	#$10
   1108  f000				  -	      bne	qs3a
   1109  f000				  -	      EIF
   1110  f000				  -	      lda	#0
   1111  f000				  -	      sta	trackn_audc+0+4
   1112  f000				  -qs3a
   1113  f000				  -	      txa
   1114  f000				  -	      ora	#$50
   1115  f000				  -	      tax
   1116  f000				  -	      EIF
   1117  f000				  -qs4
   1118  f000				  -	      IF	FEAT_BASS16G3R
   1119  f000				  -	      lda	trackn_command+3+4
   1120  f000				  -	      and	#$0e
   1121  f000				  -	      cmp	#6
   1122  f000				  -	      bne	qs5
   1123  f000				  -	      lda	trackn_audc+3+4
   1124  f000				  -	      and	#$0f
   1125  f000				  -	      beq	qs5
   1126  f000				  -	      ldy	trackn_outnote+3+4
   1127  f000				  -	      lda	frqtabbasslo,y
   1128  f000				  -	      sta	trackn_audf+2+4
   1129  f000				  -	      lda	frqtabbasshi,y
   1130  f000				  -	      sta	trackn_audf+3+4
   1131  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1132  f000				  -	      lda	trackn_audc+2+4
   1133  f000				  -	      and	#$10
   1134  f000				  -	      bne	qs4a
   1135  f000				  -	      EIF
   1136  f000				  -	      lda	#0
   1137  f000				  -	      sta	trackn_audc+2+4
   1138  f000				  -qs4a
   1139  f000				  -	      txa
   1140  f000				  -	      ora	#$28
   1141  f000				  -	      tax
   1142  f000				  -	      EIF
   1143  f000				  -	      EIF
   1144  f000				  -qs5
   1145  f000				  -	      stx	v_audctl2
   1146  f000				  -	      EIF
   1147  f000				  -rmt_p5
   1148  f000				  -	      lda	v_ainstrspeed
   1149  f000				  -	      rts
   1150  f000				  -SetPokey
   1151  f000				  -	      IF	STEREO8T
   1152  f000				  -	      ldy	v_audctl2
   1153  f000				  -	      lda	trackn_audf+0+4
   1154  f000				  -	      ldx	trackn_audf+0
   1155  f000				  -	      sta	POKEY_BASE_S+$00
   1156  f000				  -	      stx	POKEY_BASE+$00
   1157  f000				  -	      lda	trackn_audc+0+4
   1158  f000				  -	      ldx	trackn_audc+0
   1159  f000				  -	      sta	POKEY_BASE_S+$01
   1160  f000				  -	      stx	POKEY_BASE+$01
   1161  f000				  -	      lda	trackn_audf+1+4
   1162  f000				  -	      ldx	trackn_audf+1
   1163  f000				  -	      sta	POKEY_BASE_S+$02
   1164  f000				  -	      stx	POKEY_BASE+$02
   1165  f000				  -	      lda	trackn_audc+1+4
   1166  f000				  -	      ldx	trackn_audc+1
   1167  f000				  -	      sta	POKEY_BASE_S+$03
   1168  f000				  -	      stx	POKEY_BASE+$03
   1169  f000				  -	      lda	trackn_audf+2+4
   1170  f000				  -	      ldx	trackn_audf+2
   1171  f000				  -	      sta	POKEY_BASE_S+$04
   1172  f000				  -	      stx	POKEY_BASE+$04
   1173  f000				  -	      lda	trackn_audc+2+4
   1174  f000				  -	      ldx	trackn_audc+2
   1175  f000				  -	      sta	POKEY_BASE_S+$05
   1176  f000				  -	      stx	POKEY_BASE+$05
   1177  f000				  -	      lda	trackn_audf+3+4
   1178  f000				  -	      ldx	trackn_audf+3
   1179  f000				  -	      sta	POKEY_BASE_S+$06
   1180  f000				  -	      stx	POKEY_BASE+$06
   1181  f000				  -	      lda	trackn_audc+3+4
   1182  f000				  -	      ldx	trackn_audc+3
   1183  f000				  -	      sta	POKEY_BASE_S+$07
   1184  f000				  -	      stx	POKEY_BASE+$07
   1185  f000				  -	      lda	v_audctl
   1186  f000				  -	      sty	POKEY_BASE_S+$08
   1187  f000				  -	      sta	POKEY_BASE+$08
   1188  f000				  -	      ELSE
   1189  f000				  -
   1190  f000				  -	      ifconst	RMTVOLUME
   1191  f000				  -	      lda	rmtvolume
   1192  f000				  -	      sta	fourbitfadevalueint
   1193  f000				  -	      endif
   1194  f000				  -	      ldy	v_audctl
   1195  f000				  -	      ldx	trackn_audf+0
   1196  f000				  -	      lda	trackn_audc+0
   1197  f000				  -	      ifconst	RMTVOLUME
   1198  f000				  -	      jsr	fourbitfadeint
   1199  f000				  -	      endif
   1200  f000				  -	      stx	POKEY_BASE+$00+0
   1201  f000				  -	      stx	POKEY_BASE+$00+0
   1202  f000				  -	      sta	POKEY_BASE+$01+0
   1203  f000				  -	      sta	POKEY_BASE+$01+0
   1204  f000				  -
   1205  f000				  -	      ldx	trackn_audf+1
   1206  f000				  -	      lda	trackn_audc+1
   1207  f000				  -	      ifconst	RMTVOLUME
   1208  f000				  -	      jsr	fourbitfadeint
   1209  f000				  -	      endif
   1210  f000				  -	      stx	POKEY_BASE+$00+2
   1211  f000				  -	      stx	POKEY_BASE+$00+2
   1212  f000				  -	      sta	POKEY_BASE+$01+2
   1213  f000				  -	      sta	POKEY_BASE+$01+2
   1214  f000				  -
   1215  f000				  -	      ldx	trackn_audf+2
   1216  f000				  -	      lda	trackn_audc+2
   1217  f000				  -	      ifconst	RMTVOLUME
   1218  f000				  -	      jsr	fourbitfadeint
   1219  f000				  -	      endif
   1220  f000				  -	      stx	POKEY_BASE+$00+4
   1221  f000				  -	      stx	POKEY_BASE+$00+4
   1222  f000				  -	      sta	POKEY_BASE+$01+4
   1223  f000				  -	      sta	POKEY_BASE+$01+4
   1224  f000				  -
   1225  f000				  -	      ldx	trackn_audf+3
   1226  f000				  -	      lda	trackn_audc+3
   1227  f000				  -	      ifconst	RMTVOLUME
   1228  f000				  -	      jsr	fourbitfadeint
   1229  f000				  -	      endif
   1230  f000				  -	      stx	POKEY_BASE+$00+6
   1231  f000				  -	      stx	POKEY_BASE+$00+6
   1232  f000				  -	      sta	POKEY_BASE+$01+6
   1233  f000				  -	      sta	POKEY_BASE+$01+6
   1234  f000				  -
   1235  f000				  -	      sty	POKEY_BASE+$08
   1236  f000				  -	      sty	POKEY_BASE+$08
   1237  f000				  -
   1238  f000				  -	      EIF
   1239  f000				  -	      rts
   1240  f000				  -SetUpInstrumentY2
   1241  f000				  -	      lda	(p_instrstable),y
   1242  f000				  -	      sta	trackn_instrdb,x
   1243  f000				  -	      sta	_nt
   1244  f000				  -	      iny
   1245  f000				  -	      lda	(p_instrstable),y
   1246  f000				  -	      sta	trackn_instrhb,x
   1247  f000				  -	      sta	_nt+1
   1248  f000				  -	      ldy	#0
   1249  f000				  -	      lda	(_nt),y
   1250  f000				  -	      sta	trackn_tableend,x
   1251  f000				  -	      clc
   1252  f000				  -	      adc	#1
   1253  f000				  -	      sta	trackn_instridx,x
   1254  f000				  -	      iny
   1255  f000				  -	      lda	(_nt),y
   1256  f000				  -	      sta	trackn_tablelop,x
   1257  f000				  -	      iny
   1258  f000				  -	      lda	(_nt),y
   1259  f000				  -	      sta	trackn_instrlen,x
   1260  f000				  -	      iny
   1261  f000				  -	      lda	(_nt),y
   1262  f000				  -	      sta	trackn_instrlop,x
   1263  f000				  -	      iny
   1264  f000				  -	      lda	(_nt),y
   1265  f000				  -	      sta	trackn_tabletypespeed,x
   1266  f000				  -	      IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1267  f000				  -	      and	#$3f
   1268  f000				  -	      EIF
   1269  f000				  -	      sta	trackn_tablespeeda,x
   1270  f000				  -	      IF	FEAT_TABLEMODE
   1271  f000				  -	      lda	(_nt),y
   1272  f000				  -	      and	#$40
   1273  f000				  -	      sta	trackn_tablemode,x
   1274  f000				  -	      EIF
   1275  f000				  -	      iny
   1276  f000				  -	      IF	FEAT_AUDCTLMANUALSET
   1277  f000				  -	      lda	(_nt),y
   1278  f000				  -	      sta	trackn_audctl,x
   1279  f000				  -	      EIF
   1280  f000				  -	      iny
   1281  f000				  -	      lda	(_nt),y
   1282  f000				  -	      sta	trackn_volumeslidedepth,x
   1283  f000				  -	      iny
   1284  f000				  -	      lda	(_nt),y
   1285  f000				  -	      sta	trackn_volumemin,x
   1286  f000				  -	      iny
   1287  f000				  -	      lda	(_nt),y
   1288  f000				  -	      sta	trackn_effdelay,x
   1289  f000				  -	      iny
   1290  f000				  -	      lda	(_nt),y
   1291  f000				  -	      tay
   1292  f000				  -	      lda	vibtabbeg,y
   1293  f000				  -	      sta	trackn_effvibratoa,x
   1294  f000				  -	      sta	trackn_effvibratobeg,x
   1295  f000				  -	      lda	vibtabbeg+1,y
   1296  f000				  -	      sta	trackn_effvibratoend,x
   1297  f000				  -	      ldy	#10
   1298  f000				  -	      lda	(_nt),y
   1299  f000				  -	      sta	trackn_effshift,x
   1300  f000				  -	      lda	#128
   1301  f000				  -	      sta	trackn_volumeslidevalue,x
   1302  f000				  -	      lda	#0
   1303  f000				  -	      sta	trackn_instrreachend,x
   1304  f000				  -	      sta	trackn_shiftfrq,x
   1305  f000				  -	      lda	#INSTRPAR
   1306  f000				  -	      sta	trackn_tablea,x
   1307  f000				  -	      tay
   1308  f000				  -	      lda	(_nt),y
   1309  f000				  -	      sta	trackn_tablenote,x
   1310  f000				  -	      IF	FEAT_FILTER
   1311  f000				  -	      lda	#1
   1312  f000				  -	      sta	trackn_filter,x
   1313  f000				  -	      EIF
   1314  f000				  -	      rts
   1315  f000				  -InstrumentsEffects
   1316  f000				  -	      lda	trackn_effdelay,x
   1317  f000				  -	      beq	ei2
   1318  f000				  -	      tay
   1319  f000				  -	      dey
   1320  f000				  -	      bne	ei1
   1321  f000				  -	      lda	trackn_shiftfrq,x
   1322  f000				  -	      clc
   1323  f000				  -	      adc	trackn_effshift,x
   1324  f000				  -	      clc
   1325  f000				  -	      ldy	trackn_effvibratoa,x
   1326  f000				  -	      adc	vib0,y
   1327  f000				  -	      sta	trackn_shiftfrq,x
   1328  f000				  -	      iny
   1329  f000				  -	      tya
   1330  f000				  -	      cmp	trackn_effvibratoend,x
   1331  f000				  -	      bne	ei1a
   1332  f000				  -	      lda	trackn_effvibratobeg,x
   1333  f000				  -ei1a
   1334  f000				  -	      sta	trackn_effvibratoa,x
   1335  f000				  -	      jmp	ei2
   1336  f000				  -ei1
   1337  f000				  -	      tya
   1338  f000				  -	      sta	trackn_effdelay,x
   1339  f000				  -ei2
   1340  f000				  -	      lda	trackn_tableend,x
   1341  f000				  -	      cmp	#INSTRPAR
   1342  f000				  -	      beq	ei3
   1343  f000				  -	      lda	trackn_tablespeeda,x
   1344  f000				  -	      bpl	ei2f
   1345  f000				  -ei2c
   1346  f000				  -	      lda	trackn_tablea,x
   1347  f000				  -	      clc
   1348  f000				  -	      adc	#1
   1349  f000				  -	      cmp	trackn_tableend,x
   1350  f000				  -	      bcc	ei2a
   1351  f000				  -	      beq	ei2a
   1352  f000				  -	      lda	trackn_tablelop,x
   1353  f000				  -ei2a
   1354  f000				  -	      sta	trackn_tablea,x
   1355  f000				  -	      lda	trackn_instrdb,x
   1356  f000				  -	      sta	_nt
   1357  f000				  -	      lda	trackn_instrhb,x
   1358  f000				  -	      sta	_nt+1
   1359  f000				  -	      ldy	trackn_tablea,x
   1360  f000				  -	      lda	(_nt),y
   1361  f000				  -	      IF	FEAT_TABLEMODE
   1362  f000				  -	      ldy	trackn_tablemode,x
   1363  f000				  -	      beq	ei2e
   1364  f000				  -	      clc
   1365  f000				  -	      adc	trackn_tablenote,x
   1366  f000				  -ei2e
   1367  f000				  -	      EIF
   1368  f000				  -	      sta	trackn_tablenote,x
   1369  f000				  -	      lda	trackn_tabletypespeed,x
   1370  f000				  -	      IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1371  f000				  -	      and	#$3f
   1372  f000				  -	      EIF
   1373  f000				  -ei2f
   1374  f000				  -	      sec
   1375  f000				  -	      sbc	#1
   1376  f000				  -	      sta	trackn_tablespeeda,x
   1377  f000				  -ei3
   1378  f000				  -	      lda	trackn_instrreachend,x
   1379  f000				  -	      bpl	ei4
   1380  f000				  -	      lda	trackn_volume,x
   1381  f000				  -	      beq	ei4
   1382  f000				  -	      cmp	trackn_volumemin,x
   1383  f000				  -	      beq	ei4
   1384  f000				  -	      bcc	ei4
   1385  f000				  -	      tay
   1386  f000				  -	      lda	trackn_volumeslidevalue,x
   1387  f000				  -	      clc
   1388  f000				  -	      adc	trackn_volumeslidedepth,x
   1389  f000				  -	      sta	trackn_volumeslidevalue,x
   1390  f000				  -	      bcc	ei4
   1391  f000				  -	      tya
   1392  f000				  -	      sbc	#16
   1393  f000				  -	      sta	trackn_volume,x
   1394  f000				  -ei4
   1395  f000				  -	      jmp	returnfromInstrumentsEffects
   1396  f000				  -
   1397  f000				  -rmtmoduleend
   1398  f000				  -	      echo	"  (rmtplayer module is using ",[(rmtmoduleend-rmtmodulestart)]d," bytes of rom)"
   1399  f000				  -	      echo	"  (rmtplayer module is using ",[(MEMLOC-RMTRAM-1)]d," bytes of ram)"
   1400  f000				  -
   1401  f000					      endif		; RMT
------- FILE test320c.78b.asm
   1018  f000					      endif
   1019  f000					      ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  f000					      include	7800vox.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000							; AtariVox 7800basic wrapper
      4  f000
      5  f000							; to be called with
      6  f000							; A=# of bytes
      7  f000							;
      8  f000
      9  f000				  -	      ifconst	HSSUPPORT
     10  f000				  -
     11  f000				  -_7800voxstart
     12  f000				  -
     13  f000				  -AVoxReadBytes
     14  f000				  -	      sta	temp8
     15  f000				  -	      jsr	i2c_startwrite
     16  f000				  -	      bcs	eeprom_error
     17  f000				  -
     18  f000				  -	      lda	HSVoxHi
     19  f000				  -	      jsr	i2c_txbyte
     20  f000				  -	      lda	HSVoxLo
     21  f000				  -	      jsr	i2c_txbyte
     22  f000				  -	      jsr	i2c_stopwrite
     23  f000				  -
     24  f000				  -	      jsr	i2c_startread
     25  f000				  -
     26  f000				  -	      ldx	#0
     27  f000				  -AVoxReadBytesLoop
     28  f000				  -	      jsr	i2c_rxbyte
     29  f000				  -	      sta	eeprombuffer,x
     30  f000				  -	      inx
     31  f000				  -	      cpx	temp8
     32  f000				  -	      bne	AVoxReadBytesLoop
     33  f000				  -	      jsr	i2c_stopread
     34  f000				  -	      lda	#0
     35  f000				  -	      rts
     36  f000				  -
     37  f000				  -			; to be called with
     38  f000				  -			; A=# of bytes
     39  f000				  -			;
     40  f000				  -
     41  f000				  -AVoxWriteBytes
     42  f000				  -	      sta	temp8
     43  f000				  -	      jsr	i2c_startwrite
     44  f000				  -	      bcs	eeprom_error
     45  f000				  -
     46  f000				  -	      lda	HSVoxHi
     47  f000				  -	      jsr	i2c_txbyte
     48  f000				  -	      lda	HSVoxLo
     49  f000				  -	      jsr	i2c_txbyte
     50  f000				  -
     51  f000				  -	      ldx	#$00
     52  f000				  -AVoxWriteBytesLoop
     53  f000				  -	      lda	eeprombuffer,x
     54  f000				  -	      jsr	i2c_txbyte
     55  f000				  -	      inx
     56  f000				  -	      cpx	temp8
     57  f000				  -	      bne	AVoxWriteBytesLoop
     58  f000				  -	      jsr	i2c_stopwrite
     59  f000				  -
     60  f000				  -	      lda	#0
     61  f000				  -	      rts
     62  f000				  -
     63  f000				  -eeprom_error
     64  f000				  -	      lda	#$ff
     65  f000				  -	      rts
     66  f000				  -
     67  f000				  -AVoxDetect
     68  f000				  -
     69  f000				  -	      jsr	i2c_startwrite
     70  f000				  -	      bcs	eeprom_error
     71  f000				  -	      lda	#$30
     72  f000				  -	      jsr	i2c_txbyte
     73  f000				  -	      lda	#$00
     74  f000				  -	      jsr	i2c_txbyte
     75  f000				  -	      jsr	i2c_stopwrite
     76  f000				  -	      rts
     77  f000				  -
     78  f000				  -	      include	"i2c7800.inc"
     79  f000				  -	      I2C_SUBS	temp9
     80  f000				  -
     81  f000				  -_7800voxend
     82  f000				  -
     83  f000				  -	      echo	"  (7800vox module is using ",[(_7800voxend-_7800voxstart)]d," bytes)"
     84  f000				  -
     85  f000					      endif
     86  f000
------- FILE test320c.78b.asm
   1021  f000					      endif
   1022  f000					      ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  f000					      include	pokeysound.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000
      4  f000				  -	      ifconst	pokeysupport
      5  f000				  -
      6  f000				  -pokeysoundmodulestart
      7  f000				  -
      8  f000				  -mutepokey
      9  f000				  -	      lda	#0
     10  f000				  -	      ldy	#7
     11  f000				  -mutepokeyloop
     12  f000				  -	      sta	pokey1pointlo,y
     13  f000				  -	      sta	(pokeybaselo),y
     14  f000				  -	      dey
     15  f000				  -	      bpl	mutepokeyloop
     16  f000				  -	      rts
     17  f000				  -
     18  f000				  -checkpokeyplaying
     19  f000				  -	      ldx	#6
     20  f000				  -checkpokeyplayingloop
     21  f000				  -	      lda	pokey1pointlo,x
     22  f000				  -	      ora	pokey1pointhi,x
     23  f000				  -	      beq	pokeychannelinactive
     24  f000				  -	      jsr	playpokeysfxA	; x=channel*2
     25  f000				  -pokeychannelinactive
     26  f000				  -	      dex
     27  f000				  -	      dex
     28  f000				  -	      bpl	checkpokeyplayingloop
     29  f000				  -	      rts
     30  f000				  -
     31  f000				  -playpokeysfxA
     32  f000				  -	      txa
     33  f000				  -	      tay
     34  f000				  -	      lda	pokey1tick,x
     35  f000				  -	      beq	playpokeysfxAcont
     36  f000				  -	      sec
     37  f000				  -	      sbc	#1
     38  f000				  -	      sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     39  f000				  -	      rts
     40  f000				  -
     41  f000				  -playpokeysfxAcont
     42  f000				  -	      lda	pokey1frames,x	; set the frame countdown for this sound chunk
     43  f000				  -	      sta	pokey1tick,x
     44  f000				  -
     45  f000				  -	      lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     46  f000				  -	      beq	playpokeysfxAcont2
     47  f000				  -	      sec
     48  f000				  -	      sbc	#1
     49  f000				  -	      sta	pokey1priority,x
     50  f000				  -playpokeysfxAcont2
     51  f000				  -
     52  f000				  -			; *** FREQUENCY
     53  f000				  -	      lda	(pokey1pointlo,x)
     54  f000				  -	      sta	inttemp1
     55  f000				  -	      clc
     56  f000				  -	      adc	pokey1offset,x	; take into account any pitch modification
     57  f000				  -	      sta	(pokeybaselo),y	; PAUDF0,0
     58  f000				  -
     59  f000				  -			;advance the data pointer +1
     60  f000				  -	      inc	pokey1pointlo,x
     61  f000				  -	      bne	skippokeyhiinc1
     62  f000				  -	      inc	pokey1pointhi,x
     63  f000				  -skippokeyhiinc1
     64  f000				  -
     65  f000				  -			; *** WAVE
     66  f000				  -	      lda	(pokey1pointlo,x)
     67  f000				  -	      asl
     68  f000				  -	      asl
     69  f000				  -	      asl
     70  f000				  -	      asl		; x16
     71  f000				  -
     72  f000				  -			;advance the data pointer +1
     73  f000				  -	      inc	pokey1pointlo,x
     74  f000				  -	      bne	skippokeyhiinc2
     75  f000				  -	      inc	pokey1pointhi,x
     76  f000				  -skippokeyhiinc2
     77  f000				  -
     78  f000				  -	      ora	(pokey1pointlo,x)
     79  f000				  -	      iny
     80  f000				  -	      sta	(pokeybaselo),y
     81  f000				  -
     82  f000				  -	      ora	inttemp1	; check if F|C|V=0
     83  f000				  -	      beq	zeropokeypoint	; if so, we're at the end of the sound.
     84  f000				  -
     85  f000				  -			; advance the pointer +1, on to the next sound chunk
     86  f000				  -	      inc	pokey1pointlo,x
     87  f000				  -	      bne	skippokeyhiinc3
     88  f000				  -	      inc	pokey1pointhi,x
     89  f000				  -skippokeyhiinc3
     90  f000				  -	      rts
     91  f000				  -
     92  f000				  -zeropokeypoint
     93  f000				  -	      sta	pokey1pointlo,x
     94  f000				  -	      sta	pokey1pointhi,x
     95  f000				  -	      sta	pokey1priority,x
     96  f000				  -	      rts
     97  f000				  -
     98  f000				  -schedulepokeysfx
     99  f000				  -	      ldx	#6
    100  f000				  -schedulepokeysfxloop
    101  f000				  -	      lda	pokey1pointlo,x
    102  f000				  -	      ora	pokey1pointhi,x
    103  f000				  -	      bne	schedulespokeysearch
    104  f000				  -	      jmp	schedulepokeyX	; we found an unused channel, so use it...
    105  f000				  -schedulespokeysearch
    106  f000				  -	      dex
    107  f000				  -	      dex
    108  f000				  -	      bpl	schedulepokeysfxloop
    109  f000				  -
    110  f000				  -			; if we're here, all 4 channels are presently playing a sound...
    111  f000				  -	      ldy	#1
    112  f000				  -	      lda	(sfxinstrumentlo),y	; peek at the priority of this sfx...
    113  f000				  -	      bne	schedulepokeysfxcont1
    114  f000				  -	      rts		; ...and skip it if it's 0 priority
    115  f000				  -schedulepokeysfxcont1
    116  f000				  -
    117  f000				  -			; figure out which current sound has the lowest priority...
    118  f000				  -	      lda	#0
    119  f000				  -	      sta	temp8
    120  f000				  -	      lda	pokey1priority
    121  f000				  -	      sta	temp9
    122  f000				  -	      ldx	#6
    123  f000				  -findlowprioritypokeyloop
    124  f000				  -	      lda	pokey1priority,x
    125  f000				  -	      cmp	temp9
    126  f000				  -	      bcs	findlowprioritypokeyloopcontinue
    127  f000				  -	      sta	temp9
    128  f000				  -	      stx	temp8
    129  f000				  -findlowprioritypokeyloopcontinue
    130  f000				  -	      dex
    131  f000				  -	      dex
    132  f000				  -	      bne	findlowprioritypokeyloop
    133  f000				  -	      ldx	temp8	; the low priority channel we'll interrupt
    134  f000				  -
    135  f000				  -schedulepokeyX
    136  f000				  -			;called with X=2*pokey channel to play on...
    137  f000				  -	      ldy	#1	; get priority and sound-resolution (in frames)
    138  f000				  -	      lda	(sfxinstrumentlo),y
    139  f000				  -	      sta	pokey1priority,x
    140  f000				  -	      iny
    141  f000				  -	      lda	(sfxinstrumentlo),y
    142  f000				  -	      sta	pokey1frames,x
    143  f000				  -
    144  f000				  -	      lda	sfxinstrumentlo
    145  f000				  -	      clc
    146  f000				  -	      adc	#3
    147  f000				  -	      sta	pokey1pointlo,x
    148  f000				  -	      lda	sfxinstrumenthi
    149  f000				  -	      adc	#0
    150  f000				  -	      sta	pokey1pointhi,x
    151  f000				  -	      lda	sfxpitchoffset
    152  f000				  -	      sta	pokey1offset,x
    153  f000				  -	      lda	#0
    154  f000				  -	      sta	pokey1tick,x
    155  f000				  -	      rts
    156  f000				  -
    157  f000				  -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    158  f000				  -			; and the standard $4000 location.
    159  f000				  -			; if pokey the pokey is present, this routine will reset it.
    160  f000				  -	      ifconst	pokeyaddress
    161  f000				  -detectpokeylocation
    162  f000				  -	      lda	#<pokeyaddress
    163  f000				  -	      sta	pokeybaselo
    164  f000				  -	      lda	#>pokeyaddress
    165  f000				  -	      sta	pokeybasehi
    166  f000				  -	      lda	#$ff
    167  f000				  -	      sta	pokeydetected
    168  f000				  -
    169  f000				  -	      if	pokeyaddress = $450
    170  f000				  -	      lda	XCTRL1s
    171  f000				  -	      ora	#%00010100
    172  f000				  -	      sta	XCTRL1s
    173  f000				  -	      sta	XCTRL1
    174  f000				  -	      endif
    175  f000				  -
    176  f000				  -
    177  f000				  -	      lda	#0
    178  f000				  -	      ldy	#15
    179  f000				  -clearpokeyloop
    180  f000				  -	      sta	(pokeybase),y
    181  f000				  -	      dey
    182  f000				  -	      bpl	clearpokeyloop
    183  f000				  -			; take pokey out of reset...
    184  f000				  -	      ldy	#PSKCTL
    185  f000				  -	      lda	#3
    186  f000				  -	      sta	(pokeybase),y
    187  f000				  -	      ldy	#PAUDCTL
    188  f000				  -	      lda	#0
    189  f000				  -	      sta	(pokeybase),y
    190  f000				  -	      rts
    191  f000				  -	      else		; !pokeyaddress
    192  f000				  -detectpokeylocation
    193  f000				  -			;XBoard/XM...
    194  f000				  -	      ldx	#2
    195  f000				  -detectpokeyloop
    196  f000				  -	      lda	XCTRL1s
    197  f000				  -	      ora	#%00010100
    198  f000				  -	      and	POKEYXMMASK,x
    199  f000				  -	      sta	XCTRL1s
    200  f000				  -	      sta	XCTRL1
    201  f000				  -
    202  f000				  -	      lda	POKEYCHECKLO,x
    203  f000				  -	      sta	pokeybaselo
    204  f000				  -	      lda	POKEYCHECKHI,x
    205  f000				  -	      sta	pokeybasehi
    206  f000				  -	      jsr	checkforpokey
    207  f000				  -	      lda	pokeydetected
    208  f000				  -	      beq	foundpokeychip
    209  f000				  -	      dex
    210  f000				  -	      bpl	detectpokeyloop
    211  f000				  -foundpokeychip
    212  f000				  -	      eor	#$ff	; invert state for 7800basic if...then test
    213  f000				  -	      sta	pokeydetected
    214  f000				  -	      rts
    215  f000				  -
    216  f000				  -POKEYXMMASK
    217  f000				  -			;     XM POKEY on    XM POKEY off   XM POKEY off
    218  f000				  -	      .byte	%11111111, %11101111, %11101111
    219  f000				  -
    220  f000				  -POKEYCHECKLO
    221  f000				  -	      .byte	<$0450, <$0450, <$4000
    222  f000				  -POKEYCHECKHI
    223  f000				  -	      .byte	>$0450, >$0450, >$4000
    224  f000				  -
    225  f000				  -checkforpokey
    226  f000				  -	      ldy	#$0f
    227  f000				  -	      lda	#$00
    228  f000				  -	      sta	pokeydetected	; start off by assuming pokey will be detected
    229  f000				  -resetpokeyregistersloop
    230  f000				  -	      sta	(pokeybase),y
    231  f000				  -	      dey
    232  f000				  -	      bpl	resetpokeyregistersloop
    233  f000				  -
    234  f000				  -	      ldy	#PAUDCTL
    235  f000				  -	      sta	(pokeybase),y
    236  f000				  -	      ldy	#PSKCTL
    237  f000				  -	      sta	(pokeybase),y
    238  f000				  -
    239  f000				  -			; let the dust settle...
    240  f000				  -	      nop
    241  f000				  -	      nop
    242  f000				  -	      nop
    243  f000				  -
    244  f000				  -	      lda	#4
    245  f000				  -	      sta	temp9
    246  f000				  -pokeycheckloop1
    247  f000				  -			; we're in reset, so the RANDOM register should read $ff...
    248  f000				  -	      ldy	#PRANDOM
    249  f000				  -	      lda	(pokeybase),y
    250  f000				  -	      cmp	#$ff
    251  f000				  -	      bne	nopokeydetected
    252  f000				  -	      dec	temp9
    253  f000				  -	      bne	pokeycheckloop1
    254  f000				  -
    255  f000				  -			; take pokey out of reset...
    256  f000				  -	      ldy	#PSKCTL
    257  f000				  -	      lda	#3
    258  f000				  -	      sta	(pokeybase),y
    259  f000				  -	      ldy	#PAUDCTL
    260  f000				  -	      lda	#0
    261  f000				  -	      sta	(pokeybase),y
    262  f000				  -
    263  f000				  -			; let the dust settle again...
    264  f000				  -	      nop
    265  f000				  -	      nop
    266  f000				  -	      nop
    267  f000				  -
    268  f000				  -	      lda	#4
    269  f000				  -	      sta	temp9
    270  f000				  -pokeycheckloop2
    271  f000				  -			; we're out of reset, so RANDOM should read non-$ff...
    272  f000				  -	      ldy	#PRANDOM
    273  f000				  -	      lda	(pokeybase),y
    274  f000				  -	      cmp	#$ff
    275  f000				  -	      beq	skippokeycheckreturn
    276  f000				  -	      rts
    277  f000				  -skippokeycheckreturn
    278  f000				  -	      dec	temp9
    279  f000				  -	      bne	pokeycheckloop2
    280  f000				  -nopokeydetected
    281  f000				  -	      dec	pokeydetected	; pokeydetected=#$ff
    282  f000				  -	      rts
    283  f000				  -
    284  f000				  -	      endif		; !pokeyaddress
    285  f000				  -
    286  f000				  -pokeysoundmoduleend
    287  f000				  -
    288  f000				  -	      echo	"  (pokeysound module is using ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes)"
    289  f000				  -
    290  f000					      endif
------- FILE test320c.78b.asm
   1024  f000					      endif
   1025  f000					      ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  f000					      include	tracker.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000
      4  f000				  -	      ifconst	MUSICTRACKER
      5  f000				  -
      6  f000				  -trackerstart
      7  f000				  -
      8  f000				  -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      9  f000				  -			; ** the player operates on a 16th note grid.
     10  f000				  -
     11  f000				  -servicesongover
     12  f000				  -	      rts
     13  f000				  -servicesong
     14  f000				  -	      lda	songtempo
     15  f000				  -	      beq	servicesongover	; ** if song is off/paused then return
     16  f000				  -servicesongcontinue
     17  f000				  -	      lda	sfxschedulelock
     18  f000				  -	      sta	sfxschedulemissed
     19  f000				  -	      bne	servicesongover
     20  f000				  -	      lda	songtempo
     21  f000				  -	      clc
     22  f000				  -	      adc	songtick	; add songtempo to songtick until it rolls over
     23  f000				  -	      sta	songtick	; this is how we break away from 50/60Hz timing.
     24  f000				  -	      bcc	servicesongover
     25  f000				  -			; ** if we're here a new 16th note has passed
     26  f000				  -			; ** check if a new note is due on any of the 4 channels
     27  f000				  -servicesongredo
     28  f000				  -	      ldx	#3
     29  f000				  -checkchannelloop
     30  f000				  -	      dec	songchannel1busywait,x
     31  f000				  -	      bpl	carryoncheckingchannel
     32  f000				  -	      txa
     33  f000				  -	      pha		; save X for the loop
     34  f000				  -	      jsr	processsongdata
     35  f000				  -	      pla		; restore X for the loop
     36  f000				  -	      tax
     37  f000				  -carryoncheckingchannel
     38  f000				  -	      dex
     39  f000				  -	      bpl	checkchannelloop
     40  f000				  -	      lda	inactivechannelcount
     41  f000				  -	      cmp	#15
     42  f000				  -	      bne	skipstopsong
     43  f000				  -	      lda	songloops
     44  f000				  -	      bne	doasongloop
     45  f000				  -			;lda #0
     46  f000				  -	      sta	songtempo	; all channels are done. stop the song
     47  f000				  -	      rts
     48  f000				  -doasongloop
     49  f000				  -	      bmi	skipsongloopadjust
     50  f000				  -	      dec	songloops
     51  f000				  -skipsongloopadjust
     52  f000				  -	      jsr	setsongchannels
     53  f000				  -	      jmp	servicesongredo
     54  f000				  -skipstopsong
     55  f000				  -	      rts
     56  f000				  -
     57  f000				  -processsongdata
     58  f000				  -			; channel needs processing
     59  f000				  -			; X=channel #
     60  f000				  -
     61  f000				  -	      txa
     62  f000				  -	      clc
     63  f000				  -	      adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     64  f000				  -	      tay
     65  f000				  -
     66  f000				  -
     67  f000				  -			; ** indirect x is cumbersome with mult-byte commands.
     68  f000				  -			; ** setup a pointer to the song data for indirect y addressing.
     69  f000				  -	      lda	songchannel1layer1lo,y
     70  f000				  -	      sta	songdatalo
     71  f000				  -	      lda	songchannel1layer1hi,y
     72  f000				  -	      sta	songdatahi
     73  f000				  -	      ora	songdatalo
     74  f000				  -	      bne	channelhasdata
     75  f000				  -			;channel data is pointing at $0000
     76  f000				  -	      lda	#$7F
     77  f000				  -	      sta	songchannel1busywait,x	; skip a bunch of notes
     78  f000				  -setchannelcountbits
     79  f000				  -	      lda	channel2bits,x
     80  f000				  -	      ora	inactivechannelcount
     81  f000				  -	      sta	inactivechannelcount
     82  f000				  -	      rts
     83  f000				  -channelhasdata
     84  f000				  -
     85  f000				  -	      sty	songstackindex
     86  f000				  -	      ldy	#0
     87  f000				  -	      lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     88  f000				  -	      cmp	#$ff
     89  f000				  -	      bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     90  f000				  -	      jmp	handlechannelEOD
     91  f000				  -
     92  f000				  -carryoncheckingdatatype
     93  f000				  -	      and	#$F0
     94  f000				  -	      cmp	#$C0
     95  f000				  -	      beq	handlechannelrest	; 0000XXXX=rest
     96  f000				  -	      cmp	#$F0
     97  f000				  -	      beq	handlemultibytecommand
     98  f000				  -	      cmp	#$D0
     99  f000				  -	      beq	handlesemiup
    100  f000				  -	      cmp	#$E0
    101  f000				  -	      beq	handlesemidown
    102  f000				  -handlenotedata
    103  f000				  -			; ** TODO: note playing is a terrible choice for fall-through
    104  f000				  -
    105  f000				  -			; ** its simple note data, prepare arguments for schedulesfx
    106  f000				  -
    107  f000				  -			; ** set the note length
    108  f000				  -	      lda	(songdatalo),y
    109  f000				  -	      and	#$0F
    110  f000				  -	      sta	songchannel1busywait,x
    111  f000				  -
    112  f000				  -			; ** load the instrument
    113  f000				  -	      lda	songchannel1instrumentlo,x
    114  f000				  -	      sta	sfxinstrumentlo
    115  f000				  -	      lda	songchannel1instrumenthi,x
    116  f000				  -	      sta	sfxinstrumenthi
    117  f000				  -
    118  f000				  -			; ** get the note, and transpose
    119  f000				  -	      lda	(songdatalo),y
    120  f000				  -	      lsr
    121  f000				  -	      lsr
    122  f000				  -	      lsr
    123  f000				  -	      lsr
    124  f000				  -	      clc
    125  f000				  -	      adc	songchannel1transpose,x	; ** add it to the transpose index
    126  f000				  -			; ** its up the respective SFX scheduler to handle and save the note data
    127  f000				  -	      sta	sfxnoteindex
    128  f000				  -
    129  f000				  -	      lda	#0
    130  f000				  -	      sta	sfxpitchoffset
    131  f000				  -
    132  f000				  -	      jsr	schedulesfx
    133  f000				  -
    134  f000				  -	      jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    135  f000				  -
    136  f000				  -handlechannelrest
    137  f000				  -			; ** set the note length
    138  f000				  -	      lda	(songdatalo),y
    139  f000				  -	      and	#$0F
    140  f000				  -	      sta	songchannel1busywait,x
    141  f000				  -	      jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    142  f000				  -
    143  f000				  -handlesemiup
    144  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    145  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    146  f000				  -	      clc
    147  f000				  -handlesemidownentry
    148  f000				  -	      adc	songchannel1transpose,x	; ** add it to the transpose index
    149  f000				  -	      sta	songchannel1transpose,x
    150  f000				  -	      jsr	advancethesongpointer1byte
    151  f000				  -	      jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    152  f000				  -
    153  f000				  -handlesemidown
    154  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    155  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    156  f000				  -	      eor	#$ff	; ** its easier if we negate it, and then add it instead.
    157  f000				  -	      sec
    158  f000				  -	      jmp	handlesemidownentry
    159  f000				  -
    160  f000				  -handlemultibytecommand
    161  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    162  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    163  f000				  -	      cmp	#$08	; ** load new instrument?
    164  f000				  -	      bne	nothandleinstrumentchange
    165  f000				  -handleinstrumentchange
    166  f000				  -	      iny
    167  f000				  -	      lda	(songdatalo),y
    168  f000				  -	      sta	songchannel1instrumentlo,x
    169  f000				  -	      iny
    170  f000				  -	      lda	(songdatalo),y
    171  f000				  -	      sta	songchannel1instrumenthi,x
    172  f000				  -	      lda	#3
    173  f000				  -	      jsr	advancethesongpointerNbytes	; advance 3 bytes
    174  f000				  -	      jmp	processsongdata
    175  f000				  -
    176  f000				  -nothandleinstrumentchange
    177  f000				  -	      cmp	#$09	; ** absolute tempo change?
    178  f000				  -	      bne	nothandletempochange
    179  f000				  -	      lda	#0
    180  f000				  -	      sta	songtempo
    181  f000				  -handlerelativetempochange
    182  f000				  -	      iny
    183  f000				  -	      lda	(songdatalo),y
    184  f000				  -	      clc
    185  f000				  -	      adc	songtempo
    186  f000				  -	      sta	songtempo
    187  f000				  -	      lda	#2
    188  f000				  -	      jsr	advancethesongpointerNbytes	; advance 2 bytes
    189  f000				  -	      jmp	processsongdata
    190  f000				  -
    191  f000				  -nothandletempochange
    192  f000				  -	      cmp	#$0A	; ** relative tempo change?:
    193  f000				  -	      beq	handlerelativetempochange
    194  f000				  -	      cmp	#$0B	; ** octave/semi change?
    195  f000				  -	      beq	handleoctavesemichange
    196  f000				  -handlepatterndata
    197  f000				  -			; ** if we're here its a pattern/loop "subroutine"
    198  f000				  -			; ** move the channel's "stack" pointer and populate the new stack level
    199  f000				  -
    200  f000				  -	      lda	#4
    201  f000				  -	      clc
    202  f000				  -	      adc	songchannel1stackdepth,x
    203  f000				  -	      sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    204  f000				  -
    205  f000				  -	      stx	inttemp6	; about to invalidate x. save it.
    206  f000				  -	      lda	songstackindex
    207  f000				  -	      adc	#4
    208  f000				  -	      tax
    209  f000				  -
    210  f000				  -	      lda	(songdatalo),y
    211  f000				  -	      and	#$7
    212  f000				  -	      sta	songchannel1layer1loops,x
    213  f000				  -	      iny
    214  f000				  -	      lda	(songdatalo),y
    215  f000				  -	      sta	songchannel1layer1lo,x
    216  f000				  -	      iny
    217  f000				  -	      lda	(songdatalo),y
    218  f000				  -	      sta	songchannel1layer1hi,x
    219  f000				  -
    220  f000				  -	      ldx	inttemp6	; restore x with the channel #
    221  f000				  -
    222  f000				  -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    223  f000				  -	      lda	#3
    224  f000				  -	      jsr	advancethesongpointerNbytes	; advance 3 bytes
    225  f000				  -
    226  f000				  -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    227  f000				  -	      jmp	processsongdata
    228  f000				  -
    229  f000				  -handlechannelEOD
    230  f000				  -			; ** check if there are loops remaining on the pattern
    231  f000				  -	      stx	inttemp6
    232  f000				  -	      ldx	songstackindex
    233  f000				  -	      dec	songchannel1layer1loops,x
    234  f000				  -	      bmi	handlechannelEODnoloop
    235  f000				  -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    236  f000				  -	      iny
    237  f000				  -	      lda	(songdatalo),y
    238  f000				  -	      sta	songchannel1layer1lo,x
    239  f000				  -	      iny
    240  f000				  -	      lda	(songdatalo),y
    241  f000				  -	      sta	songchannel1layer1hi,x
    242  f000				  -	      ldx	inttemp6
    243  f000				  -	      jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    244  f000				  -
    245  f000				  -handlechannelEODnoloop
    246  f000				  -			; this pattern/loop is done playing. "pop" the stack
    247  f000				  -	      ldx	inttemp6
    248  f000				  -	      lda	songchannel1stackdepth,x
    249  f000				  -	      beq	handlerootchannelEOD
    250  f000				  -	      sec
    251  f000				  -	      sbc	#4
    252  f000				  -	      sta	songchannel1stackdepth,x
    253  f000				  -	      jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    254  f000				  -
    255  f000				  -handlerootchannelEOD
    256  f000				  -			; this channel is done. point it to $ff data so we no longer process this channel.
    257  f000				  -	      lda	#0
    258  f000				  -	      sta	songchannel1layer1lo,x
    259  f000				  -	      sta	songchannel1layer1hi,x
    260  f000				  -	      sta	songchannel1busywait,x
    261  f000				  -	      jmp	setchannelcountbits
    262  f000				  -	      rts
    263  f000				  -
    264  f000				  -nothandlepatternchange
    265  f000				  -handleoctavesemichange
    266  f000				  -	      iny
    267  f000				  -	      lda	(songdatalo),y
    268  f000				  -	      sta	songchannel1transpose,x
    269  f000				  -	      lda	#2
    270  f000				  -	      jsr	advancethesongpointerNbytes	; advance 2 bytes
    271  f000				  -	      jmp	processsongdata
    272  f000				  -
    273  f000				  -advancethesongpointer1byte
    274  f000				  -	      txa
    275  f000				  -	      ldx	songstackindex
    276  f000				  -	      inc	songchannel1layer1lo,x
    277  f000				  -	      bne	skiphiadvancethesongpointer1byte
    278  f000				  -	      inc	songchannel1layer1hi,x
    279  f000				  -skiphiadvancethesongpointer1byte
    280  f000				  -	      tax
    281  f000				  -	      rts
    282  f000				  -
    283  f000				  -advancethesongpointerNbytes
    284  f000				  -			; entered with A=# of byte to advance
    285  f000				  -	      stx	inttemp6
    286  f000				  -	      ldx	songstackindex
    287  f000				  -	      clc
    288  f000				  -	      adc	songchannel1layer1lo,x
    289  f000				  -	      sta	songchannel1layer1lo,x
    290  f000				  -	      lda	#0
    291  f000				  -	      adc	songchannel1layer1hi,x
    292  f000				  -	      sta	songchannel1layer1hi,x
    293  f000				  -	      ldx	inttemp6
    294  f000				  -	      rts
    295  f000				  -
    296  f000				  -clearsongmemory
    297  f000				  -	      lda	#0
    298  f000				  -	      ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    299  f000				  -clearsongmemoryloop1
    300  f000				  -	      sta	songchannel1layer1lo,x
    301  f000				  -	      dex
    302  f000				  -	      bpl	clearsongmemoryloop1
    303  f000				  -
    304  f000				  -	      ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    305  f000				  -clearsongmemoryloop2
    306  f000				  -	      sta	songchannel1layer1loops,x
    307  f000				  -	      dex
    308  f000				  -	      bpl	clearsongmemoryloop2
    309  f000				  -
    310  f000				  -	      lda	#$ff
    311  f000				  -	      ldx	#3
    312  f000				  -clearsongmemoryloop3
    313  f000				  -	      sta	songchannel1busywait,x
    314  f000				  -	      dex
    315  f000				  -	      bpl	clearsongmemoryloop3
    316  f000				  -	      rts
    317  f000				  -
    318  f000				  -setsongchannels
    319  f000				  -	      jsr	clearsongmemory
    320  f000				  -	      ldy	#7
    321  f000				  -	      ldx	#3
    322  f000				  -setsongchannelsloop
    323  f000				  -	      lda	(songpointerlo),y
    324  f000				  -	      sta	songchannel1layer1hi,x
    325  f000				  -	      dey
    326  f000				  -	      lda	(songpointerlo),y
    327  f000				  -	      sta	songchannel1layer1lo,x
    328  f000				  -	      dex
    329  f000				  -	      dey
    330  f000				  -	      bpl	setsongchannelsloop
    331  f000				  -	      rts
    332  f000				  -
    333  f000				  -channel2bits
    334  f000				  -	      .byte	1,2,4,8
    335  f000				  -
    336  f000				  -tiatrackeroctavenotes
    337  f000				  -	      ifconst	BUZZBASS
    338  f000				  -LOWC       =	15
    339  f000				  -	      else
    340  f000				  -LOWC       =	14
    341  f000				  -	      endif
    342  f000				  -			; ****** ELECTRONIC (0 to 11)
    343  f000				  -	      .byte	LOWC,20	; c0	 16.1Hz
    344  f000				  -	      .byte	LOWC,18	; c#0
    345  f000				  -	      .byte	LOWC,17	; d0
    346  f000				  -	      .byte	LOWC,16	; d#0
    347  f000				  -	      .byte	LOWC,15	; e0
    348  f000				  -	      .byte	LOWC,14	; f0  (very off)
    349  f000				  -	      .byte	LOWC,14	; f#0
    350  f000				  -	      .byte	LOWC,13	; g0
    351  f000				  -	      .byte	LOWC,12	; g#0
    352  f000				  -	      .byte	LOWC,11	; a0
    353  f000				  -	      .byte	LOWC,11	; a#0 (very off)
    354  f000				  -	      .byte	LOWC,10	; b0	 30.7Hz
    355  f000				  -
    356  f000				  -			; ****** SLIGHTLY BUZZY (12 to 23)
    357  f000				  -	      .byte	6,30	; c1	 32.7Hz
    358  f000				  -	      .byte	6,28	; c#1
    359  f000				  -	      .byte	6,27	; d1
    360  f000				  -	      .byte	6,25	; d#1
    361  f000				  -	      .byte	6,24	; e1
    362  f000				  -	      .byte	6,22	; f1
    363  f000				  -	      .byte	6,21	; f#1
    364  f000				  -	      .byte	6,20	; g1
    365  f000				  -	      .byte	6,18	; g#1
    366  f000				  -	      .byte	6,17	; a1
    367  f000				  -	      .byte	6,16	; a#1
    368  f000				  -	      .byte	6,15	; b1	 63.4Hz
    369  f000				  -
    370  f000				  -			; ****** BUZZY (24 to 39)
    371  f000				  -	      .byte	1,31	; c2	 65.5
    372  f000				  -	      .byte	1,30	; c#2	 67.6
    373  f000				  -	      .byte	1,27	; d2	 72.3
    374  f000				  -	      .byte	1,26	; d#2	 77.6
    375  f000				  -	      .byte	1,24	; e2
    376  f000				  -	      .byte	1,23	; f2
    377  f000				  -	      .byte	1,22	; f#2
    378  f000				  -	      .byte	1,20	; g2
    379  f000				  -	      .byte	1,19	; g#2
    380  f000				  -	      .byte	1,18	; a2
    381  f000				  -	      .byte	1,17	; a#2
    382  f000				  -	      .byte	1,16	; b2
    383  f000				  -	      .byte	1,15	; c3	126.8Hz
    384  f000				  -	      .byte	1,14	; c#3
    385  f000				  -	      .byte	1,13	; d3	149.7Hz
    386  f000				  -	      .byte	1,12	; d#3	161.2Hz (very off)
    387  f000				  -			; ****** PURE (40 to 71) - best key is A3 Major
    388  f000				  -	      .byte	12,31	; e3	163.8Hz
    389  f000				  -	      .byte	12,29	; f3
    390  f000				  -	      .byte	12,28	; f#3
    391  f000				  -	      .byte	12,26	; g3
    392  f000				  -	      .byte	12,24	; g#3
    393  f000				  -	      .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    394  f000				  -	      .byte	12,22	; a#3
    395  f000				  -	      .byte	12,20	; b3
    396  f000				  -	      .byte	12,19	; c4  (middle C)
    397  f000				  -	      .byte	12,18	; c#4
    398  f000				  -	      .byte	12,17	; d4
    399  f000				  -	      .byte	12,16	; d#4
    400  f000				  -	      .byte	12,15	; e4
    401  f000				  -	      .byte	12,14	; f4
    402  f000				  -	      .byte	12,13	; f#4
    403  f000				  -	      .byte	12,12	; g4  (very off)
    404  f000				  -	      .byte	12,12	; g#4
    405  f000				  -	      .byte	12,11	; a4
    406  f000				  -	      .byte	12,10	; a#4
    407  f000				  -	      .byte	4,31	; b4
    408  f000				  -	      .byte	4,29	; c5
    409  f000				  -	      .byte	4,28	; c#5
    410  f000				  -	      .byte	4,26	; d5
    411  f000				  -	      .byte	4,24	; d#5
    412  f000				  -	      .byte	4,23	; e5
    413  f000				  -	      .byte	4,22	; f5
    414  f000				  -	      .byte	4,20	; f#5
    415  f000				  -	      .byte	4,19	; g5
    416  f000				  -	      .byte	4,18	; g#5
    417  f000				  -	      .byte	4,17	; a5
    418  f000				  -	      .byte	4,16	; a#5
    419  f000				  -	      .byte	4,15	; b5
    420  f000				  -
    421  f000				  -			; ****** TUNED WIND (72 to 83)
    422  f000				  -	      .byte	8,30	; c
    423  f000				  -	      .byte	8,28	; c#
    424  f000				  -	      .byte	8,27	; d
    425  f000				  -	      .byte	8,25	; d#
    426  f000				  -	      .byte	8,24	; e
    427  f000				  -	      .byte	8,22	; f
    428  f000				  -	      .byte	8,21	; f#
    429  f000				  -	      .byte	8,20	; g
    430  f000				  -	      .byte	8,18	; g#
    431  f000				  -	      .byte	8,17	; a
    432  f000				  -	      .byte	8,16	; a#
    433  f000				  -	      .byte	8,15	; b
    434  f000				  -
    435  f000				  -	      include	"tiadrumkit.asm"
    436  f000				  -
    437  f000				  -trackerend
    438  f000				  -
    439  f000				  -	      echo	"  (tracker module is using ",[(trackerend-trackerstart)]d," bytes)"
    440  f000				  -
    441  f000					      endif		;MUSICTRACKER
------- FILE test320c.78b.asm
   1027  f000					      endif
   1028  f000					      ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  f000					      include	hiscore.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000				  -	      ifconst	HSSUPPORT
      4  f000				  -
      5  f000				  -	      ifconst	BANKSETROM
      6  f000				  -	      ifconst	isBANKSETBANK
      7  f000				  -HSCHARSHERE =	1
      8  f000				  -	      endif
      9  f000				  -	      else		; !BANKSETROM so embed the character strings
     10  f000				  -HSCHARSHERE =	1
     11  f000				  -	      endif
     12  f000				  -
     13  f000				  -	      ifnconst	isBANKSETBANK
     14  f000				  -hiscorestart
     15  f000				  -
     16  f000				  -detectatarivoxeeprom
     17  f000				  -hiscoremodulestart
     18  f000				  -			; do a test to see if atarivox eeprom can be accessed, and save results
     19  f000				  -	      jsr	AVoxDetect
     20  f000				  -	      eor	#$ff	; invert for easy 7800basic if...then logic
     21  f000				  -	      sta	avoxdetected
     22  f000				  -	      lda	#$0
     23  f000				  -	      sta	SWACNT
     24  f000				  -	      lda	avoxdetected
     25  f000				  -	      rts
     26  f000				  -
     27  f000				  -detecthsc
     28  f000				  -			; check for the HSC ROM signature...
     29  f000				  -	      lda	XCTRL1s
     30  f000				  -	      ora	#%00001100
     31  f000				  -	      sta	XCTRL1s
     32  f000				  -	      sta	XCTRL1
     33  f000				  -	      lda	$3900
     34  f000				  -	      eor	#$C6
     35  f000				  -	      bne	detecthscfail
     36  f000				  -	      lda	$3904
     37  f000				  -	      eor	#$FE
     38  f000				  -	      bne	detecthscfail
     39  f000				  -			; check if it's initialized...
     40  f000				  -	      ldy	#0
     41  f000				  -	      lda	#$ff
     42  f000				  -checkhscinit
     43  f000				  -	      and	$1000,y
     44  f000				  -	      dey
     45  f000				  -	      bpl	checkhscinit
     46  f000				  -	      cmp	#$ff
     47  f000				  -	      bne	hscisalreadyinit
     48  f000				  -			; if we're here, we need to do a minimal HSC init...
     49  f000				  -	      ldy	#$28
     50  f000				  -hscinitloop1
     51  f000				  -	      lda	hscheader,y
     52  f000				  -	      sta	$1000,y
     53  f000				  -	      dey
     54  f000				  -	      bpl	hscinitloop1
     55  f000				  -	      ldy	#$89
     56  f000				  -	      lda	#$7F
     57  f000				  -hscinitloop2
     58  f000				  -	      sta	$10B3,y
     59  f000				  -	      dey
     60  f000				  -	      cpy	#$ff
     61  f000				  -	      bne	hscinitloop2
     62  f000				  -hscisalreadyinit
     63  f000				  -	      lda	#$ff
     64  f000				  -	      rts
     65  f000				  -hscheader
     66  f000				  -	      .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     67  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     68  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     69  f000				  -detecthscfail
     70  f000				  -	      lda	XCTRL1s
     71  f000				  -	      and	#%11110111
     72  f000				  -	      sta	XCTRL1s
     73  f000				  -	      lda	#0
     74  f000				  -	      rts
     75  f000				  -	      endif		; isBANKSETBANK
     76  f000				  -
     77  f000				  -	      ifnconst	hiscorefont
     78  f000				  -	      echo	""
     79  f000				  -	      echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     80  f000				  -	      echo	" NOT imported with incgraphic. The high score display code"
     81  f000				  -	      echo	" has been omitted from this build."
     82  f000				  -	      echo	""
     83  f000				  -	      else		; hiscorefont
     84  f000				  -	      ifnconst	isBANKSETBANK
     85  f000				  -hscdrawscreen
     86  f000				  -
     87  f000				  -			; we use 20 lines on a 24 line display
     88  f000				  -			; HSSCOREY to dynamically centers based on
     89  f000				  -			;HSSCOREY = 0
     90  f000				  -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     91  f000				  -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
     92  f000				  -
     93  f000				  -	      ifconst	HSSCORESIZE
     94  f000				  -SCORESIZE  =	HSSCORESIZE
     95  f000				  -	      else
     96  f000				  -SCORESIZE  =	6
     97  f000				  -	      endif
     98  f000				  -
     99  f000				  -			;save shadow registers for later return...
    100  f000				  -	      lda	sCTRL
    101  f000				  -	      sta	ssCTRL
    102  f000				  -	      lda	sCHARBASE
    103  f000				  -	      sta	ssCHARBASE
    104  f000				  -	      lda	#$60
    105  f000				  -	      sta	charactermode
    106  f000				  -	      jsr	drawwait
    107  f000				  -	      jsr	blacken320colors
    108  f000				  -	      jsr	clearscreen
    109  f000				  -
    110  f000				  -			;set the character base to the HSC font
    111  f000				  -	      lda	#>hiscorefont
    112  f000				  -	      sta	CHARBASE
    113  f000				  -	      sta	sCHARBASE
    114  f000				  -	      lda	#%01000011	;Enable DMA, mode=320A
    115  f000				  -	      sta	CTRL
    116  f000				  -	      sta	sCTRL
    117  f000				  -
    118  f000				  -	      lda	#60
    119  f000				  -	      sta	hsjoydebounce
    120  f000				  -
    121  f000				  -	      lda	#0
    122  f000				  -	      sta	hscursorx
    123  f000				  -	      sta	framecounter
    124  f000				  -	      ifnconst	HSCOLORCHASESTART
    125  f000				  -	      lda	#$8D	; default is blue. why not?
    126  f000				  -	      else
    127  f000				  -	      lda	#HSCOLORCHASESTART
    128  f000				  -	      endif
    129  f000				  -	      sta	hscolorchaseindex
    130  f000				  -
    131  f000				  -	      lda	#$0F
    132  f000				  -	      sta	P0C2	; base text is white
    133  f000				  -
    134  f000				  -	      jsr	hschasecolors
    135  f000				  -			; ** plot all of the initials
    136  f000				  -	      lda	#<HSRAMInitials
    137  f000				  -	      sta	temp1	; charmaplo
    138  f000				  -	      lda	#>HSRAMInitials
    139  f000				  -	      sta	temp2	; charmaphi
    140  f000				  -	      lda	#32+29	; palette=0-29 | 32-(width=3)
    141  f000				  -	      sta	temp3	; palette/width
    142  f000				  -	      lda	#104
    143  f000				  -	      sta	temp4	; X
    144  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    145  f000				  -	      sta	temp5	; Y
    146  f000				  -plothsinitialsloop
    147  f000				  -	      jsr	plotcharacters
    148  f000				  -	      clc
    149  f000				  -	      lda	temp3
    150  f000				  -	      adc	#32
    151  f000				  -	      sta	temp3
    152  f000				  -	      inc	temp5
    153  f000				  -	      if	WZONEHEIGHT = 8
    154  f000				  -	      inc	temp5
    155  f000				  -	      endif
    156  f000				  -	      clc
    157  f000				  -	      lda	#3
    158  f000				  -	      adc	temp1
    159  f000				  -	      sta	temp1
    160  f000				  -	      cmp	#(<(HSRAMInitials+15))
    161  f000				  -	      bcc	plothsinitialsloop
    162  f000				  -
    163  f000				  -	      ifconst	HSGAMENAMELEN
    164  f000				  -			;plot the game name...
    165  f000				  -	      lda	#<HSGAMENAMEtable
    166  f000				  -	      sta	temp1	; charmaplo
    167  f000				  -	      lda	#>HSGAMENAMEtable
    168  f000				  -	      sta	temp2	; charmaphi
    169  f000				  -	      lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    170  f000				  -	      sta	temp3	; palette/width
    171  f000				  -	      lda	#(80-(HSGAMENAMELEN*2))
    172  f000				  -	      sta	temp4	; X
    173  f000				  -	      lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    174  f000				  -	      sta	temp5	; Y
    175  f000				  -	      jsr	plotcharacters
    176  f000				  -	      endif		; HSGAMENAMELEN
    177  f000				  -
    178  f000				  -			;plot "difficulty"...
    179  f000				  -	      ldy	gamedifficulty
    180  f000				  -	      ifnconst	HSNOLEVELNAMES
    181  f000				  -	      lda	highscoredifficultytextlo,y
    182  f000				  -	      sta	temp1
    183  f000				  -	      lda	highscoredifficultytexthi,y
    184  f000				  -	      sta	temp2
    185  f000				  -	      sec
    186  f000				  -	      lda	#32
    187  f000				  -	      sbc	highscoredifficultytextlen,y
    188  f000				  -	      sta	temp3	; palette/width
    189  f000				  -	      sec
    190  f000				  -	      lda	#40
    191  f000				  -	      sbc	highscoredifficultytextlen,y
    192  f000				  -	      asl
    193  f000				  -	      sta	temp4	; X
    194  f000				  -	      else
    195  f000				  -	      lda	#<HSHIGHSCOREStext
    196  f000				  -	      sta	temp1	; charmaplo
    197  f000				  -	      lda	#>HSHIGHSCOREStext
    198  f000				  -	      sta	temp2	; charmaphi
    199  f000				  -	      lda	#(32-11)	; palette=0*29 | 32-(width=3)
    200  f000				  -	      sta	temp3	; palette/width
    201  f000				  -	      lda	#(80-(11*2))
    202  f000				  -	      sta	temp4	; X
    203  f000				  -	      endif		; HSNOLEVELNAMES
    204  f000				  -
    205  f000				  -	      lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    206  f000				  -	      sta	temp5	; Y
    207  f000				  -	      jsr	plotcharacters
    208  f000				  -	      ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    209  f000				  -	      bne	carronwithscoreevaluation
    210  f000				  -	      jmp	donoscoreevaluation
    211  f000				  -carronwithscoreevaluation
    212  f000				  -	      dey
    213  f000				  -	      lda	highscorelabeltextlo,y
    214  f000				  -	      sta	temp1
    215  f000				  -	      lda	highscorelabeltexthi,y
    216  f000				  -	      sta	temp2
    217  f000				  -	      sec
    218  f000				  -	      lda	#(32-15)	; palette=0*29 | 32-(width=3)
    219  f000				  -	      sta	temp3	; palette/width
    220  f000				  -	      lda	highscorelabeladjust1,y
    221  f000				  -	      sta	temp4	; X
    222  f000				  -	      lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    223  f000				  -	      sta	temp5	; Y
    224  f000				  -	      jsr	plotcharacters
    225  f000				  -
    226  f000				  -	      ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    227  f000				  -	      dey
    228  f000				  -			;plot the current player score...
    229  f000				  -	      lda	#(32-SCORESIZE)	; palette=0*32
    230  f000				  -	      sta	temp3	; palette/width
    231  f000				  -	      lda	highscorelabeladjust2,y
    232  f000				  -	      sta	temp4	; X
    233  f000				  -	      lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    234  f000				  -	      sta	temp5	; Y
    235  f000				  -
    236  f000				  -	      lda	scorevarlo,y
    237  f000				  -	      sta	temp7	; score variable lo
    238  f000				  -	      lda	scorevarhi,y
    239  f000				  -	      sta	temp8	; score variable hi
    240  f000				  -
    241  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    242  f000				  -	      sta	temp9
    243  f000				  -
    244  f000				  -	      lda	#<(hiscorefont+33)	; +33 to get to '0' character
    245  f000				  -	      sta	temp1	; charmaplo
    246  f000				  -	      lda	#>(hiscorefont+33)
    247  f000				  -	      sta	temp2	; charmaphi
    248  f000				  -	      lda	#SCORESIZE
    249  f000				  -	      sta	temp6
    250  f000				  -	      ifnconst	DOUBLEWIDE
    251  f000				  -	      jsr	plotvalue
    252  f000				  -	      else
    253  f000				  -	      jsr	plotvaluedw
    254  f000				  -	      endif
    255  f000				  -
    256  f000				  -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    257  f000				  -
    258  f000				  -	      ifconst	HSGAMERANKS
    259  f000				  -
    260  f000				  -	      ldx	#$ff	; start at 0 after the inx...
    261  f000				  -comparescore2rankloop
    262  f000				  -	      inx
    263  f000				  -	      ldy	#0
    264  f000				  -	      lda	rankvalue_0,x
    265  f000				  -	      cmp	(temp7),y
    266  f000				  -	      bcc	score2rankloopdone
    267  f000				  -	      bne	comparescore2rankloop
    268  f000				  -	      iny
    269  f000				  -	      lda	rankvalue_1,x
    270  f000				  -	      cmp	(temp7),y
    271  f000				  -	      bcc	score2rankloopdone
    272  f000				  -	      bne	comparescore2rankloop
    273  f000				  -	      iny
    274  f000				  -	      lda	(temp7),y
    275  f000				  -	      cmp	rankvalue_2,x
    276  f000				  -	      bcs	score2rankloopdone
    277  f000				  -	      jmp	comparescore2rankloop
    278  f000				  -score2rankloopdone
    279  f000				  -	      stx	hsnewscorerank
    280  f000				  -
    281  f000				  -	      lda	ranklabello,x
    282  f000				  -	      sta	temp1
    283  f000				  -	      lda	ranklabelhi,x
    284  f000				  -	      sta	temp2
    285  f000				  -	      sec
    286  f000				  -	      lda	#32	; palette=0*29 | 32-(width=3)
    287  f000				  -	      sbc	ranklabellengths,x
    288  f000				  -	      sta	temp3	; palette/width
    289  f000				  -	      sec
    290  f000				  -	      lda	#(40+6)
    291  f000				  -	      sbc	ranklabellengths,x
    292  f000				  -	      asl
    293  f000				  -	      sta	temp4	; X
    294  f000				  -	      lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    295  f000				  -	      sta	temp5	; Y
    296  f000				  -	      jsr	plotcharacters
    297  f000				  -
    298  f000				  -	      ldx	hsnewscorerank
    299  f000				  -
    300  f000				  -	      lda	#<highscoreranklabel
    301  f000				  -	      sta	temp1
    302  f000				  -	      lda	#>highscoreranklabel
    303  f000				  -	      sta	temp2
    304  f000				  -
    305  f000				  -	      lda	#(32-5)	; palette=0*29 | 32-(width=3)
    306  f000				  -	      sta	temp3	; palette/width
    307  f000				  -	      lda	#(40-6)
    308  f000				  -	      sec
    309  f000				  -	      sbc	ranklabellengths,x
    310  f000				  -	      asl
    311  f000				  -	      sta	temp4	; X
    312  f000				  -	      lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    313  f000				  -	      sta	temp5	; Y
    314  f000				  -	      jsr	plotcharacters
    315  f000				  -	      endif		; HSGAMERANKS
    316  f000				  -
    317  f000				  -
    318  f000				  -			; ** which line did this player beat?
    319  f000				  -	      lda	#$ff
    320  f000				  -	      sta	hsnewscoreline
    321  f000				  -	      ldx	#$fd
    322  f000				  -comparescoreadd2x
    323  f000				  -	      inx
    324  f000				  -comparescoreadd1x
    325  f000				  -	      inx
    326  f000				  -comparescore2lineloop
    327  f000				  -	      inc	hsnewscoreline
    328  f000				  -	      inx		; initialrun, x=0
    329  f000				  -	      cpx	#15
    330  f000				  -	      beq	nohighscoreforyou
    331  f000				  -	      ldy	#0
    332  f000				  -	      lda	HSRAMScores,x
    333  f000				  -	      cmp	(temp7),y	; first score digit
    334  f000				  -	      bcc	score2lineloopdonedel1x
    335  f000				  -	      bne	comparescoreadd2x
    336  f000				  -	      iny
    337  f000				  -	      inx
    338  f000				  -	      lda	HSRAMScores,x
    339  f000				  -	      cmp	(temp7),y
    340  f000				  -	      bcc	score2lineloopdonedel2x
    341  f000				  -	      bne	comparescoreadd1x
    342  f000				  -	      iny
    343  f000				  -	      inx
    344  f000				  -	      lda	(temp7),y
    345  f000				  -	      cmp	HSRAMScores,x
    346  f000				  -	      bcs	score2lineloopdonedel3x
    347  f000				  -	      jmp	comparescore2lineloop
    348  f000				  -nohighscoreforyou
    349  f000				  -	      lda	#$ff
    350  f000				  -	      sta	hsnewscoreline
    351  f000				  -	      sta	countdownseconds
    352  f000				  -	      jmp	donoscoreevaluation
    353  f000				  -score2lineloopdonedel3x
    354  f000				  -	      dex
    355  f000				  -score2lineloopdonedel2x
    356  f000				  -	      dex
    357  f000				  -score2lineloopdonedel1x
    358  f000				  -	      dex
    359  f000				  -
    360  f000				  -			; 0 1 2
    361  f000				  -			; 3 4 5
    362  f000				  -			; 6 7 8
    363  f000				  -			; 9 0 1
    364  f000				  -			; 2 3 4
    365  f000				  -
    366  f000				  -	      stx	temp9
    367  f000				  -	      cpx	#11
    368  f000				  -	      beq	postsortscoresuploop
    369  f000				  -	      ldx	#11
    370  f000				  -sortscoresuploop
    371  f000				  -	      lda	HSRAMScores,x
    372  f000				  -	      sta	HSRAMScores+3,x
    373  f000				  -	      lda	HSRAMInitials,x
    374  f000				  -	      sta	HSRAMInitials+3,x
    375  f000				  -	      dex
    376  f000				  -	      cpx	temp9
    377  f000				  -	      bne	sortscoresuploop
    378  f000				  -postsortscoresuploop
    379  f000				  -
    380  f000				  -			;stick the score and cleared initials in the slot...
    381  f000				  -	      inx
    382  f000				  -	      ldy	#0
    383  f000				  -	      sty	hsinitialhold
    384  f000				  -	      lda	(temp7),y
    385  f000				  -	      sta	HSRAMScores,x
    386  f000				  -	      iny
    387  f000				  -	      lda	(temp7),y
    388  f000				  -	      sta	HSRAMScores+1,x
    389  f000				  -	      iny
    390  f000				  -	      lda	(temp7),y
    391  f000				  -	      sta	HSRAMScores+2,x
    392  f000				  -	      lda	#0
    393  f000				  -	      sta	HSRAMInitials,x
    394  f000				  -	      lda	#29
    395  f000				  -	      sta	HSRAMInitials+1,x
    396  f000				  -	      sta	HSRAMInitials+2,x
    397  f000				  -
    398  f000				  -	      stx	hsinitialpos
    399  f000				  -
    400  f000				  -	      ifconst	vox_highscore
    401  f000				  -	      lda	<#vox_highscore
    402  f000				  -	      sta	speech_addr
    403  f000				  -	      lda	>#vox_highscore
    404  f000				  -	      sta	speech_addr+1
    405  f000				  -	      endif		; vox_highscore
    406  f000				  -	      ifconst	sfx_highscore
    407  f000				  -	      lda	<#sfx_highscore
    408  f000				  -	      sta	temp1
    409  f000				  -	      lda	>#sfx_highscore
    410  f000				  -	      sta	temp2
    411  f000				  -	      lda	#0
    412  f000				  -	      sta	temp3
    413  f000				  -	      jsr	schedulesfx
    414  f000				  -	      endif		; sfx_highscore
    415  f000				  -	      ifconst	songdatastart_song_highscore
    416  f000				  -	      lda	#<songchanneltable_song_highscore
    417  f000				  -	      sta	songpointerlo
    418  f000				  -	      lda	#>songchanneltable_song_highscore
    419  f000				  -	      sta	songpointerhi
    420  f000				  -	      lda	#73
    421  f000				  -	      sta	songtempo
    422  f000				  -	      jsr	setsongchannels
    423  f000				  -	      endif		; songdatastart_song_highscore
    424  f000				  -
    425  f000				  -
    426  f000				  -donoscoreevaluation
    427  f000				  -
    428  f000				  -	      lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    429  f000				  -	      sta	temp3	; palette/width
    430  f000				  -	      lda	#(72+(4*(6-SCORESIZE)))
    431  f000				  -	      sta	temp4	; X
    432  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    433  f000				  -	      sta	temp5	; Y
    434  f000				  -	      lda	#<HSRAMScores
    435  f000				  -	      sta	temp7	; score variable lo
    436  f000				  -	      lda	#>HSRAMScores
    437  f000				  -	      sta	temp8	; score variable hi
    438  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    439  f000				  -	      sta	temp9
    440  f000				  -plothsscoresloop
    441  f000				  -	      lda	#<(hiscorefont+33)	; +33 to get to '0' character
    442  f000				  -	      sta	temp1	; charmaplo
    443  f000				  -	      lda	#>(hiscorefont+33)
    444  f000				  -	      sta	temp2	; charmaphi
    445  f000				  -	      lda	#6
    446  f000				  -	      sta	temp6
    447  f000				  -	      ifnconst	DOUBLEWIDE
    448  f000				  -	      jsr	plotvalue
    449  f000				  -	      else
    450  f000				  -	      jsr	plotvaluedw
    451  f000				  -	      endif
    452  f000				  -	      clc
    453  f000				  -	      lda	temp3
    454  f000				  -	      adc	#32
    455  f000				  -	      sta	temp3
    456  f000				  -	      inc	temp5
    457  f000				  -	      if	WZONEHEIGHT = 8
    458  f000				  -	      inc	temp5
    459  f000				  -	      endif
    460  f000				  -	      clc
    461  f000				  -	      lda	#3
    462  f000				  -	      adc	temp7
    463  f000				  -	      sta	temp7
    464  f000				  -	      cmp	#(<(HSRAMScores+15))
    465  f000				  -	      bcc	plothsscoresloop
    466  f000				  -plothsindex
    467  f000				  -	      lda	#32+31	; palette=0*32 | 32-(width=1)
    468  f000				  -	      sta	temp3	; palette/width
    469  f000				  -	      lda	#44
    470  f000				  -	      sta	temp4	; X
    471  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    472  f000				  -	      sta	temp5	; Y
    473  f000				  -	      lda	#<hsgameslotnumbers
    474  f000				  -	      sta	temp7	; score variable lo
    475  f000				  -	      lda	#>hsgameslotnumbers
    476  f000				  -	      sta	temp8	; score variable hi
    477  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    478  f000				  -	      sta	temp9
    479  f000				  -plothsindexloop
    480  f000				  -	      lda	#<(hiscorefont+33)
    481  f000				  -	      sta	temp1	; charmaplo
    482  f000				  -	      lda	#>(hiscorefont+33)
    483  f000				  -	      sta	temp2	; charmaphi
    484  f000				  -	      lda	#1
    485  f000				  -	      sta	temp6	; number of characters
    486  f000				  -	      ifnconst	DOUBLEWIDE
    487  f000				  -	      jsr	plotvalue
    488  f000				  -	      else
    489  f000				  -	      jsr	plotvaluedw
    490  f000				  -	      endif
    491  f000				  -	      clc
    492  f000				  -	      lda	temp3
    493  f000				  -	      adc	#32
    494  f000				  -	      sta	temp3
    495  f000				  -	      inc	temp5
    496  f000				  -	      if	WZONEHEIGHT = 8
    497  f000				  -	      inc	temp5
    498  f000				  -	      endif
    499  f000				  -	      inc	temp7
    500  f000				  -	      lda	temp7
    501  f000				  -	      cmp	#(<(hsgameslotnumbers+5))
    502  f000				  -	      bcc	plothsindexloop
    503  f000				  -
    504  f000				  -	      jsr	savescreen
    505  f000				  -	      ifnconst	HSSECONDS
    506  f000				  -	      lda	#6
    507  f000				  -	      else
    508  f000				  -	      lda	#HSSECONDS
    509  f000				  -	      endif
    510  f000				  -
    511  f000				  -	      sta	countdownseconds
    512  f000				  -
    513  f000				  -keepdisplayinghs
    514  f000				  -	      jsr	restorescreen
    515  f000				  -
    516  f000				  -	      jsr	setuphsinpt1
    517  f000				  -
    518  f000				  -	      lda	hsnewscoreline
    519  f000				  -	      bpl	carryonkeepdisplayinghs
    520  f000				  -	      jmp	skipenterscorecontrol
    521  f000				  -carryonkeepdisplayinghs
    522  f000				  -
    523  f000				  -
    524  f000				  -	      ifnconst	HSSECONDS
    525  f000				  -	      lda	#6
    526  f000				  -	      else
    527  f000				  -	      lda	#HSSECONDS
    528  f000				  -	      endif
    529  f000				  -
    530  f000				  -	      sta	countdownseconds
    531  f000				  -
    532  f000				  -			;plot the "cursor" initial sprite...
    533  f000				  -	      lda	hsinitialhold
    534  f000				  -
    535  f000				  -	      sta	temp1
    536  f000				  -	      lda	#>(hiscorefont+32)
    537  f000				  -	      sta	temp2
    538  f000				  -	      lda	#31	; palette=0*32 | 32-(width=1)
    539  f000				  -	      sta	temp3	; palette/width
    540  f000				  -	      lda	hscursorx
    541  f000				  -	      asl
    542  f000				  -	      asl
    543  f000				  -	      clc
    544  f000				  -	      adc	#104
    545  f000				  -	      sta	temp4	; X
    546  f000				  -	      lda	hsnewscoreline
    547  f000				  -	      asl
    548  f000				  -	      asl
    549  f000				  -	      asl
    550  f000				  -	      asl
    551  f000				  -	      adc	#((3*16)+HSCURSORY)
    552  f000				  -	      sta	temp5	; Y
    553  f000				  -	      lda	#%01000000
    554  f000				  -	      sta	temp6
    555  f000				  -	      jsr	plotsprite
    556  f000				  -
    557  f000				  -	      ldx	hscursorx
    558  f000				  -	      ldy	hsdisplaymode
    559  f000				  -	      ifnconst	.HSup
    560  f000				  -	      lda	SWCHA
    561  f000				  -	      cpy	#3
    562  f000				  -	      bne	hsskipadjustjoystick1
    563  f000				  -	      asl
    564  f000				  -	      asl
    565  f000				  -	      asl
    566  f000				  -	      asl
    567  f000				  -hsskipadjustjoystick1
    568  f000				  -	      sta	hsswcha
    569  f000				  -	      else		; there are user-defined routines!
    570  f000				  -	      jsr	.HSdown
    571  f000				  -	      lda	hsreturn	; b0
    572  f000				  -	      asl
    573  f000				  -	      pha
    574  f000				  -	      jsr	.HSup
    575  f000				  -	      pla
    576  f000				  -	      ora	hsreturn
    577  f000				  -	      asl
    578  f000				  -	      asl
    579  f000				  -	      asl
    580  f000				  -	      asl
    581  f000				  -	      eor	#$FF
    582  f000				  -	      sta	hsswcha
    583  f000				  -	      endif
    584  f000				  -	      lda	SWCHB
    585  f000				  -	      and	#%00000010
    586  f000				  -	      bne	hsskipselectswitch
    587  f000				  -	      lda	#%00010000
    588  f000				  -	      sta	hsswcha
    589  f000				  -	      bne	hsdodebouncecheck
    590  f000				  -hsskipselectswitch
    591  f000				  -	      lda	hsswcha
    592  f000				  -	      and	#%00110000
    593  f000				  -	      cmp	#%00110000
    594  f000				  -	      beq	hsjoystickskipped
    595  f000				  -hsdodebouncecheck
    596  f000				  -	      lda	hsjoydebounce
    597  f000				  -	      beq	hsdontdebounce
    598  f000				  -	      jmp	hspostjoystick
    599  f000				  -hsdontdebounce
    600  f000				  -	      ldx	#1	; small tick sound
    601  f000				  -	      jsr	playhssfx
    602  f000				  -	      lda	hsswcha
    603  f000				  -	      and	#%00110000
    604  f000				  -	      ldx	hscursorx
    605  f000				  -	      cmp	#%00100000	; check down
    606  f000				  -	      bne	hsjoycheckup
    607  f000				  -	      ldy	hsinitialhold
    608  f000				  -	      cpx	#0
    609  f000				  -	      bne	skipavoid31_1
    610  f000				  -	      cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    611  f000				  -	      bne	skipavoid31_1
    612  f000				  -	      dey
    613  f000				  -skipavoid31_1
    614  f000				  -	      dey
    615  f000				  -	      jmp	hssetdebounce
    616  f000				  -hsjoycheckup
    617  f000				  -	      cmp	#%00010000	; check up
    618  f000				  -	      bne	hsjoystickskipped
    619  f000				  -	      ldy	hsinitialhold
    620  f000				  -	      cpx	#0
    621  f000				  -	      bne	skipavoid31_2
    622  f000				  -	      cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    623  f000				  -	      bne	skipavoid31_2
    624  f000				  -	      iny
    625  f000				  -skipavoid31_2
    626  f000				  -	      iny
    627  f000				  -hssetdebounce
    628  f000				  -	      tya
    629  f000				  -	      and	#31
    630  f000				  -	      sta	hsinitialhold
    631  f000				  -	      lda	#15
    632  f000				  -	      sta	hsjoydebounce
    633  f000				  -	      bne	hspostjoystick
    634  f000				  -hsjoystickskipped
    635  f000				  -			; check the fire button only when the stick isn't engaged
    636  f000				  -	      lda	hsinpt1
    637  f000				  -	      bpl	hsbuttonskipped
    638  f000				  -	      lda	hsjoydebounce
    639  f000				  -	      bne	hspostjoystick
    640  f000				  -hsfiredontdebounce
    641  f000				  -	      lda	hsinitialhold
    642  f000				  -	      cmp	#31
    643  f000				  -	      beq	hsmovecursorback
    644  f000				  -	      inc	hscursorx
    645  f000				  -	      inc	hsinitialpos
    646  f000				  -	      lda	hscursorx
    647  f000				  -	      cmp	#3
    648  f000				  -	      bne	skiphsentryisdone
    649  f000				  -	      lda	#0
    650  f000				  -	      sta	framecounter
    651  f000				  -	      lda	#$ff
    652  f000				  -	      sta	hsnewscoreline
    653  f000				  -	      dec	hsinitialpos
    654  f000				  -	      bne	skiphsentryisdone
    655  f000				  -hsmovecursorback
    656  f000				  -	      lda	hscursorx
    657  f000				  -	      beq	skiphsmovecursorback
    658  f000				  -	      lda	#29
    659  f000				  -	      ldx	hsinitialpos
    660  f000				  -	      sta	HSRAMInitials,x
    661  f000				  -	      dec	hsinitialpos
    662  f000				  -	      dec	hscursorx
    663  f000				  -	      dex
    664  f000				  -	      lda	HSRAMInitials,x
    665  f000				  -	      sta	hsinitialhold
    666  f000				  -skiphsmovecursorback
    667  f000				  -skiphsentryisdone
    668  f000				  -	      ldx	#0
    669  f000				  -	      jsr	playhssfx
    670  f000				  -	      lda	#20
    671  f000				  -	      sta	hsjoydebounce
    672  f000				  -	      bne	hspostjoystick
    673  f000				  -
    674  f000				  -hsbuttonskipped
    675  f000				  -	      lda	#0
    676  f000				  -	      sta	hsjoydebounce
    677  f000				  -hspostjoystick
    678  f000				  -
    679  f000				  -	      ldx	hsinitialpos
    680  f000				  -	      lda	hsinitialhold
    681  f000				  -	      sta	HSRAMInitials,x
    682  f000				  -
    683  f000				  -	      jmp	skiphschasecolors
    684  f000				  -
    685  f000				  -skipenterscorecontrol
    686  f000				  -	      jsr	hschasecolors
    687  f000				  -	      jsr	setuphsinpt1
    688  f000				  -	      lda	hsjoydebounce
    689  f000				  -	      bne	skiphschasecolors
    690  f000				  -	      lda	hsinpt1
    691  f000				  -	      bmi	returnfromhs
    692  f000				  -skiphschasecolors
    693  f000				  -
    694  f000				  -	      jsr	drawscreen
    695  f000				  -
    696  f000				  -	      lda	countdownseconds
    697  f000				  -	      beq	returnfromhs
    698  f000				  -	      jmp	keepdisplayinghs
    699  f000				  -returnfromhs
    700  f000				  -
    701  f000				  -	      ifconst	songdatastart_song_highscore
    702  f000				  -	      lda	hsdisplaymode
    703  f000				  -	      beq	skipclearHSCsong
    704  f000				  -	      lda	#0
    705  f000				  -	      sta	songtempo
    706  f000				  -skipclearHSCsong
    707  f000				  -	      endif
    708  f000				  -	      jsr	drawwait
    709  f000				  -	      jsr	clearscreen
    710  f000				  -	      lda	#0
    711  f000				  -	      ldy	#7
    712  f000				  -	      jsr	blacken320colors
    713  f000				  -	      lda	ssCTRL
    714  f000				  -	      sta	sCTRL
    715  f000				  -	      lda	ssCHARBASE
    716  f000				  -	      sta	sCHARBASE
    717  f000				  -	      rts
    718  f000				  -
    719  f000				  -setuphsinpt1
    720  f000				  -	      lda	#$ff
    721  f000				  -	      sta	hsinpt1
    722  f000				  -	      lda	hsjoydebounce
    723  f000				  -	      beq	skipdebounceadjust
    724  f000				  -	      dec	hsjoydebounce
    725  f000				  -	      bne	skipstorefirebuttonstatus
    726  f000				  -skipdebounceadjust
    727  f000				  -	      lda	SWCHB
    728  f000				  -	      and	#%00000001
    729  f000				  -	      bne	hscheckresetover
    730  f000				  -	      lda	#$ff
    731  f000				  -	      sta	hsinpt1
    732  f000				  -	      rts
    733  f000				  -hscheckresetover
    734  f000				  -	      ifnconst	.HSup
    735  f000				  -	      ldx	hsdisplaymode
    736  f000				  -	      cpx	#3
    737  f000				  -	      bne	hsskipadjustjoyfire1
    738  f000				  -	      lda	sINPT3
    739  f000				  -	      jmp	hsskipadjustjoyfire1done
    740  f000				  -hsskipadjustjoyfire1
    741  f000				  -	      lda	sINPT1
    742  f000				  -hsskipadjustjoyfire1done
    743  f000				  -	      sta	hsinpt1
    744  f000				  -	      else		; there are user-defined routines!
    745  f000				  -	      jsr	.HSselect
    746  f000				  -	      lda	hsreturn
    747  f000				  -	      ror		; carry
    748  f000				  -	      ror		; b7
    749  f000				  -	      sta	hsinpt1
    750  f000				  -	      endif	.HSup
    751  f000				  -skipstorefirebuttonstatus
    752  f000				  -	      rts
    753  f000				  -
    754  f000				  -blacken320colors
    755  f000				  -	      ldy	#7
    756  f000				  -blacken320colorsloop
    757  f000				  -	      sta	P0C2,y
    758  f000				  -	      dey
    759  f000				  -	      bpl	blacken320colorsloop
    760  f000				  -	      rts
    761  f000				  -
    762  f000				  -hschasecolors
    763  f000				  -	      lda	framecounter
    764  f000				  -	      and	#3
    765  f000				  -	      bne	hschasecolorsreturn
    766  f000				  -	      inc	hscolorchaseindex
    767  f000				  -	      lda	hscolorchaseindex
    768  f000				  -
    769  f000				  -	      sta	P5C2
    770  f000				  -	      sbc	#$02
    771  f000				  -	      sta	P4C2
    772  f000				  -	      sbc	#$02
    773  f000				  -	      sta	P3C2
    774  f000				  -	      sbc	#$02
    775  f000				  -	      sta	P2C2
    776  f000				  -	      sbc	#$02
    777  f000				  -	      sta	P1C2
    778  f000				  -hschasecolorsreturn
    779  f000				  -	      rts
    780  f000				  -
    781  f000				  -playhssfx
    782  f000				  -	      lda	hssfx_lo,x
    783  f000				  -	      sta	temp1
    784  f000				  -	      lda	hssfx_hi,x
    785  f000				  -	      sta	temp2
    786  f000				  -	      lda	#0
    787  f000				  -	      sta	temp3
    788  f000				  -	      jmp	schedulesfx
    789  f000				  -
    790  f000				  -hssfx_lo
    791  f000				  -	      .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    792  f000				  -hssfx_hi
    793  f000				  -	      .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    794  f000				  -
    795  f000				  -sfx_hsletterpositionchange
    796  f000				  -	      .byte	$10,$18,$00
    797  f000				  -	      .byte	$02,$06,$08
    798  f000				  -	      .byte	$02,$06,$04
    799  f000				  -	      .byte	$00,$00,$00
    800  f000				  -sfx_hslettertick
    801  f000				  -	      .byte	$10,$18,$00
    802  f000				  -	      .byte	$00,$00,$0a
    803  f000				  -	      .byte	$00,$00,$00
    804  f000				  -
    805  f000				  -highscorelabeladjust1
    806  f000				  -	      .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    807  f000				  -highscorelabeladjust2
    808  f000				  -	      .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    809  f000				  -
    810  f000				  -scorevarlo
    811  f000				  -	      .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    812  f000				  -scorevarhi
    813  f000				  -	      .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    814  f000				  -
    815  f000				  -	      endif		; !isBANKSETBANK
    816  f000				  -
    817  f000				  -	      ifnconst	HSNOLEVELNAMES
    818  f000				  -	      ifnconst	isBANKSETBANK
    819  f000				  -highscoredifficultytextlo
    820  f000				  -	      .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    821  f000				  -highscoredifficultytexthi
    822  f000				  -	      .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    823  f000				  -	      endif		; !isBANKSETBANK
    824  f000				  -
    825  f000				  -	      ifnconst	HSCUSTOMLEVELNAMES
    826  f000				  -	      ifnconst	isBANKSETBANK
    827  f000				  -highscoredifficultytextlen
    828  f000				  -	      .byte	22, 30, 26, 24
    829  f000				  -	      endif		; !isBANKSETBANK
    830  f000				  -
    831  f000				  -	      ifconst	HSCHARSHERE
    832  f000				  -
    833  f000				  -easylevelname
    834  f000				  -	      .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    835  f000				  -mediumlevelname
    836  f000				  -	      .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    837  f000				  -hardlevelname
    838  f000				  -	      .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    839  f000				  -expertlevelname
    840  f000				  -	      .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    841  f000				  -	      endif		; HSCHARSHERE
    842  f000				  -	      else		; HSCUSTOMLEVELNAMES
    843  f000				  -	      include	"7800hsgamediffnames.asm"
    844  f000				  -	      endif		; HSCUSTOMLEVELNAMES
    845  f000				  -	      else		; HSNOLEVELNAMES
    846  f000				  -	      ifconst	HSCHARSHERE
    847  f000				  -HSHIGHSCOREStext
    848  f000				  -	      .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    849  f000				  -	      endif		; HSCHARSHERE
    850  f000				  -	      endif		; HSNOLEVELNAMES
    851  f000				  -
    852  f000				  -	      ifnconst	isBANKSETBANK
    853  f000				  -highscorelabeltextlo
    854  f000				  -	      .byte	<player0label, <player1label, <player2label, <player2label
    855  f000				  -highscorelabeltexthi
    856  f000				  -	      .byte	>player0label, >player1label, >player2label, >player2label
    857  f000				  -	      endif		; !isBANKSETBANK
    858  f000				  -
    859  f000				  -	      ifconst	HSCHARSHERE
    860  f000				  -player0label
    861  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    862  f000				  -
    863  f000				  -player1label
    864  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    865  f000				  -
    866  f000				  -player2label
    867  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    868  f000				  -	      endif		; HSCHARSHERE
    869  f000				  -
    870  f000				  -
    871  f000				  -	      ifconst	HSGAMENAMELEN
    872  f000				  -	      ifconst	HSCHARSHERE
    873  f000				  -HSGAMENAMEtable
    874  f000				  -	      include	"7800hsgamename.asm"
    875  f000				  -	      endif		; HSCHARSHERE
    876  f000				  -	      endif		; HSGAMENAMELEN
    877  f000				  -	      ifconst	HSGAMERANKS
    878  f000				  -	      include	"7800hsgameranks.asm"
    879  f000				  -	      ifconst	HSCHARSHERE
    880  f000				  -highscoreranklabel
    881  f000				  -	      .byte	$11,$00,$0d,$0a,$1a
    882  f000				  -	      endif		; HSCHARSHERE
    883  f000				  -	      endif		; HSGAMERANKS
    884  f000				  -
    885  f000				  -			;ensure our table doesn't wrap a page...
    886  f000				  -	      if	((<*)>251)
    887  f000				  -	      align	256
    888  f000				  -	      endif
    889  f000				  -hsgameslotnumbers
    890  f000				  -	      .byte	33,34,35,36,37
    891  f000				  -	      endif		; hiscorefont
    892  f000				  -
    893  f000				  -
    894  f000				  -	      ifnconst	isBANKSETBANK
    895  f000				  -loaddifficultytable
    896  f000				  -	      lda	gamedifficulty
    897  f000				  -	      and	#$03	; ensure the user hasn't selected an invalid difficulty
    898  f000				  -	      sta	gamedifficulty
    899  f000				  -	      cmp	hsdifficulty	; check game difficulty is the same as RAM table
    900  f000				  -	      bne	loaddifficultytablecontinue1
    901  f000				  -	      rts		; this high score difficulty table is already loaded
    902  f000				  -loaddifficultytablecontinue1
    903  f000				  -	      lda	gamedifficulty
    904  f000				  -	      sta	hsdifficulty
    905  f000				  -			;we need to check the device for the table
    906  f000				  -	      lda	hsdevice
    907  f000				  -	      bne	loaddifficultytablecontinue2
    908  f000				  -			; there's no save device. clear out this table.
    909  f000				  -	      jmp	cleardifficultytablemem
    910  f000				  -loaddifficultytablecontinue2
    911  f000				  -	      lda	hsdevice
    912  f000				  -	      and	#1
    913  f000				  -	      beq	memdeviceisntHSC
    914  f000				  -	      jmp	loaddifficultytableHSC
    915  f000				  -memdeviceisntHSC
    916  f000				  -	      jmp	loaddifficultytableAVOX
    917  f000				  -
    918  f000				  -savedifficultytable
    919  f000				  -			;*** we need to check which device we should use...
    920  f000				  -	      lda	hsdevice
    921  f000				  -	      bne	savedifficultytablerealdevice
    922  f000				  -	      rts		; its a ram device
    923  f000				  -savedifficultytablerealdevice
    924  f000				  -	      and	#1
    925  f000				  -	      beq	savememdeviceisntHSC
    926  f000				  -	      jmp	savedifficultytableHSC
    927  f000				  -savememdeviceisntHSC
    928  f000				  -	      jmp	savedifficultytableAVOX
    929  f000				  -
    930  f000				  -savedifficultytableAVOX
    931  f000				  -			; the load call already setup the memory structure and atarivox memory location
    932  f000				  -	      jsr	savealoadedHSCtablecontinue
    933  f000				  -savedifficultytableAVOXskipconvert
    934  f000				  -	      lda	#HSIDHI
    935  f000				  -	      sta	eeprombuffer
    936  f000				  -	      lda	#HSIDLO
    937  f000				  -	      sta	eeprombuffer+1
    938  f000				  -	      lda	hsdifficulty
    939  f000				  -	      sta	eeprombuffer+2
    940  f000				  -	      lda	#32
    941  f000				  -	      jsr	AVoxWriteBytes
    942  f000				  -	      rts
    943  f000				  -
    944  f000				  -savedifficultytableHSC
    945  f000				  -			;we always load a table before reaching here, so the
    946  f000				  -			;memory structures from the load should be intact...
    947  f000				  -	      ldy	hsgameslot
    948  f000				  -	      bpl	savealoadedHSCtable
    949  f000				  -	      rts
    950  f000				  -savealoadedHSCtable
    951  f000				  -	      lda	HSCGameDifficulty,y
    952  f000				  -	      cmp	#$7F
    953  f000				  -	      bne	savealoadedHSCtablecontinue
    954  f000				  -	      jsr	initializeHSCtableentry
    955  f000				  -savealoadedHSCtablecontinue
    956  f000				  -			;convert our RAM table to HSC format and write it out...
    957  f000				  -	      ldy	#0
    958  f000				  -	      ldx	#0
    959  f000				  -savedifficultytableScores
    960  f000				  -
    961  f000				  -	      lda	HSRAMInitials,x
    962  f000				  -	      sta	temp3
    963  f000				  -	      lda	HSRAMInitials+1,x
    964  f000				  -	      sta	temp4
    965  f000				  -	      lda	HSRAMInitials+2,x
    966  f000				  -	      sta	temp5
    967  f000				  -	      jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    968  f000				  -
    969  f000				  -	      lda	temp1
    970  f000				  -	      sta	(HSGameTableLo),y
    971  f000				  -	      iny
    972  f000				  -	      lda	temp2
    973  f000				  -	      sta	(HSGameTableLo),y
    974  f000				  -	      iny
    975  f000				  -
    976  f000				  -	      lda	HSRAMScores,x
    977  f000				  -	      sta	(HSGameTableLo),y
    978  f000				  -	      iny
    979  f000				  -	      lda	HSRAMScores+1,x
    980  f000				  -	      sta	(HSGameTableLo),y
    981  f000				  -	      iny
    982  f000				  -	      lda	HSRAMScores+2,x
    983  f000				  -	      sta	(HSGameTableLo),y
    984  f000				  -	      iny
    985  f000				  -	      inx
    986  f000				  -	      inx
    987  f000				  -	      inx		; +3
    988  f000				  -	      cpx	#15
    989  f000				  -	      bne	savedifficultytableScores
    990  f000				  -	      rts
    991  f000				  -
    992  f000				  -loaddifficultytableHSC
    993  f000				  -			; routine responsible for loading the difficulty table from HSC
    994  f000				  -	      jsr	findindexHSC
    995  f000				  -	      ldy	hsgameslot
    996  f000				  -	      lda	HSCGameDifficulty,y
    997  f000				  -	      cmp	#$7F
    998  f000				  -	      bne	loaddifficultytableHSCcontinue
    999  f000				  -			;there was an error. use a new RAM table instead...
   1000  f000				  -	      jsr	initializeHSCtableentry
   1001  f000				  -	      jmp	cleardifficultytablemem
   1002  f000				  -loaddifficultytableHSCcontinue
   1003  f000				  -			; parse the data into the HS memory...
   1004  f000				  -	      ldy	#0
   1005  f000				  -	      ldx	#0
   1006  f000				  -loaddifficultytableScores
   1007  f000				  -	      lda	(HSGameTableLo),y
   1008  f000				  -	      sta	temp1
   1009  f000				  -	      iny
   1010  f000				  -	      lda	(HSGameTableLo),y
   1011  f000				  -	      sta	temp2
   1012  f000				  -	      jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1013  f000				  -	      iny
   1014  f000				  -	      lda	(HSGameTableLo),y
   1015  f000				  -	      sta	HSRAMScores,x
   1016  f000				  -	      lda	temp3
   1017  f000				  -	      sta	HSRAMInitials,x
   1018  f000				  -	      inx
   1019  f000				  -	      iny
   1020  f000				  -	      lda	(HSGameTableLo),y
   1021  f000				  -	      sta	HSRAMScores,x
   1022  f000				  -	      lda	temp4
   1023  f000				  -	      sta	HSRAMInitials,x
   1024  f000				  -	      inx
   1025  f000				  -	      iny
   1026  f000				  -	      lda	(HSGameTableLo),y
   1027  f000				  -	      sta	HSRAMScores,x
   1028  f000				  -	      lda	temp5
   1029  f000				  -	      sta	HSRAMInitials,x
   1030  f000				  -	      inx
   1031  f000				  -	      iny
   1032  f000				  -	      cpx	#15
   1033  f000				  -	      bne	loaddifficultytableScores
   1034  f000				  -	      rts
   1035  f000				  -
   1036  f000				  -decodeHSCInitials
   1037  f000				  -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1038  f000				  -			; 2 bytes are packed in the form: 22211111 22_33333
   1039  f000				  -	      lda	#0
   1040  f000				  -	      sta	temp4
   1041  f000				  -	      lda	temp1
   1042  f000				  -	      and	#%00011111
   1043  f000				  -	      sta	temp3
   1044  f000				  -
   1045  f000				  -	      lda	temp2
   1046  f000				  -	      and	#%00011111
   1047  f000				  -	      sta	temp5
   1048  f000				  -
   1049  f000				  -	      lda	temp1
   1050  f000				  -	      asl
   1051  f000				  -	      rol	temp4
   1052  f000				  -	      asl
   1053  f000				  -	      rol	temp4
   1054  f000				  -	      asl
   1055  f000				  -	      rol	temp4
   1056  f000				  -	      lda	temp2
   1057  f000				  -	      asl
   1058  f000				  -	      rol	temp4
   1059  f000				  -	      asl
   1060  f000				  -	      rol	temp4
   1061  f000				  -	      rts
   1062  f000				  -encodeHSCInitials
   1063  f000				  -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1064  f000				  -			; 2 bytes are packed in the form: 22211111 22_33333
   1065  f000				  -			; start with packing temp1...
   1066  f000				  -	      lda	temp4
   1067  f000				  -	      and	#%00011100
   1068  f000				  -	      sta	temp1
   1069  f000				  -	      asl	temp1
   1070  f000				  -	      asl	temp1
   1071  f000				  -	      asl	temp1
   1072  f000				  -	      lda	temp3
   1073  f000				  -	      and	#%00011111
   1074  f000				  -	      ora	temp1
   1075  f000				  -	      sta	temp1
   1076  f000				  -			; ...temp1 is now packed, on to temp2...
   1077  f000				  -	      lda	temp5
   1078  f000				  -	      asl
   1079  f000				  -	      asl
   1080  f000				  -	      ror	temp4
   1081  f000				  -	      ror
   1082  f000				  -	      ror	temp4
   1083  f000				  -	      ror
   1084  f000				  -	      sta	temp2
   1085  f000				  -	      rts
   1086  f000				  -
   1087  f000				  -findindexHSCerror
   1088  f000				  -			;the HSC is stuffed. return the bad slot flag
   1089  f000				  -	      ldy	#$ff
   1090  f000				  -	      sty	hsgameslot
   1091  f000				  -	      rts
   1092  f000				  -
   1093  f000				  -findindexHSC
   1094  f000				  -HSCGameID1 =	$1029
   1095  f000				  -HSCGameID2 =	$106E
   1096  f000				  -HSCGameDifficulty =	$10B3
   1097  f000				  -HSCGameIndex =	$10F8
   1098  f000				  -			; routine responsible for finding the game index from HSC
   1099  f000				  -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1100  f000				  -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1101  f000				  -	      ldy	#69	; start +1 to account for the dey
   1102  f000				  -findindexHSCloop
   1103  f000				  -	      dey
   1104  f000				  -	      bmi	findindexHSCerror
   1105  f000				  -	      lda	HSCGameDifficulty,y
   1106  f000				  -	      cmp	#$7F
   1107  f000				  -	      beq	findourindexHSC
   1108  f000				  -	      cmp	gamedifficulty
   1109  f000				  -	      bne	findindexHSCloop
   1110  f000				  -	      lda	HSCGameID1,y
   1111  f000				  -	      cmp	#HSIDHI
   1112  f000				  -	      bne	findindexHSCloop
   1113  f000				  -	      lda	HSCGameID2,y
   1114  f000				  -	      cmp	#HSIDLO
   1115  f000				  -	      bne	findindexHSCloop
   1116  f000				  -findourindexHSC
   1117  f000				  -			; if we're here we found our index in the table
   1118  f000				  -			; or we found the first empty one
   1119  f000				  -	      sty	hsgameslot
   1120  f000				  -	      jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1121  f000				  -	      rts
   1122  f000				  -
   1123  f000				  -
   1124  f000				  -initializeHSCtableentry
   1125  f000				  -	      ldy	hsgameslot
   1126  f000				  -			; we need to make a new entry...
   1127  f000				  -	      lda	#HSIDHI
   1128  f000				  -	      sta	HSCGameID1,y
   1129  f000				  -	      lda	#HSIDLO
   1130  f000				  -	      sta	HSCGameID2,y
   1131  f000				  -	      lda	gamedifficulty
   1132  f000				  -	      sta	HSCGameDifficulty,y
   1133  f000				  -	      ldx	#0
   1134  f000				  -fixHSDGameDifficultylistLoop
   1135  f000				  -	      inx
   1136  f000				  -	      txa
   1137  f000				  -	      sta	HSCGameIndex,y
   1138  f000				  -	      iny
   1139  f000				  -	      cpy	#69
   1140  f000				  -	      bne	fixHSDGameDifficultylistLoop
   1141  f000				  -	      rts
   1142  f000				  -
   1143  f000				  -setupHSCGamepointer
   1144  f000				  -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1145  f000				  -	      lda	#$17
   1146  f000				  -	      sta	HSGameTableHi
   1147  f000				  -	      lda	#$FA
   1148  f000				  -	      sta	HSGameTableLo
   1149  f000				  -setupHSCGamepointerLoop
   1150  f000				  -	      lda	HSGameTableLo
   1151  f000				  -	      sec
   1152  f000				  -	      sbc	#25
   1153  f000				  -	      sta	HSGameTableLo
   1154  f000				  -	      lda	HSGameTableHi
   1155  f000				  -	      sbc	#0
   1156  f000				  -	      sta	HSGameTableHi
   1157  f000				  -	      iny
   1158  f000				  -	      cpy	#69
   1159  f000				  -	      bne	setupHSCGamepointerLoop
   1160  f000				  -	      rts
   1161  f000				  -
   1162  f000				  -loaddifficultytableAVOX
   1163  f000				  -			; routine responsible for loading the difficulty table from Avox
   1164  f000				  -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1165  f000				  -	      lda	#>(eeprombuffer+3)
   1166  f000				  -	      sta	HSGameTableHi
   1167  f000				  -	      lda	#<(eeprombuffer+3)
   1168  f000				  -	      sta	HSGameTableLo
   1169  f000				  -
   1170  f000				  -			; the start location in EEPROM, subtract 32...
   1171  f000				  -	      lda	#$5F
   1172  f000				  -	      sta	HSVoxHi
   1173  f000				  -	      lda	#$E0
   1174  f000				  -	      sta	HSVoxLo
   1175  f000				  -	      lda	#0
   1176  f000				  -	      sta	temp1
   1177  f000				  -loaddifficultytableAVOXloop
   1178  f000				  -	      inc	temp1
   1179  f000				  -	      beq	loaddifficultytableAVOXfull
   1180  f000				  -	      clc
   1181  f000				  -	      lda	HSVoxLo
   1182  f000				  -	      adc	#32
   1183  f000				  -	      sta	HSVoxLo
   1184  f000				  -	      lda	HSVoxHi
   1185  f000				  -	      adc	#0
   1186  f000				  -	      sta	HSVoxHi
   1187  f000				  -	      lda	#3
   1188  f000				  -	      jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1189  f000				  -	      lda	eeprombuffer
   1190  f000				  -	      cmp	#$FF
   1191  f000				  -	      beq	loaddifficultytableAVOXempty
   1192  f000				  -	      cmp	#HSIDHI
   1193  f000				  -	      bne	loaddifficultytableAVOXloop
   1194  f000				  -	      lda	eeprombuffer+1
   1195  f000				  -	      cmp	#HSIDLO
   1196  f000				  -	      bne	loaddifficultytableAVOXloop
   1197  f000				  -	      lda	eeprombuffer+2
   1198  f000				  -	      cmp	gamedifficulty
   1199  f000				  -	      bne	loaddifficultytableAVOXloop
   1200  f000				  -loaddifficultytableAVOXdone
   1201  f000				  -	      lda	#32
   1202  f000				  -	      jsr	AVoxReadBytes
   1203  f000				  -	      jsr	loaddifficultytableHSCcontinue
   1204  f000				  -	      rts
   1205  f000				  -loaddifficultytableAVOXfull
   1206  f000				  -	      lda	#0
   1207  f000				  -	      sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1208  f000				  -loaddifficultytableAVOXempty
   1209  f000				  -	      jmp	cleardifficultytablemem
   1210  f000				  -	      rts
   1211  f000				  -
   1212  f000				  -cleardifficultytablemem
   1213  f000				  -	      ldy	#29
   1214  f000				  -	      lda	#0
   1215  f000				  -cleardifficultytablememloop
   1216  f000				  -	      sta	HSRAMTable,y
   1217  f000				  -	      dey
   1218  f000				  -	      bpl	cleardifficultytablememloop
   1219  f000				  -	      rts
   1220  f000				  -hiscoremoduleend
   1221  f000				  -
   1222  f000				  -	      ifconst	DOUBLEWIDE
   1223  f000				  -plotvaluedw
   1224  f000				  -plotdigitcount =	temp6
   1225  f000				  -	      lda	#0
   1226  f000				  -	      tay
   1227  f000				  -	      ldx	valbufend
   1228  f000				  -
   1229  f000				  -	      lda	plotdigitcount
   1230  f000				  -	      and	#1
   1231  f000				  -	      beq	pvnibble2chardw
   1232  f000				  -	      lda	#0
   1233  f000				  -	      sta	VALBUFFER,x	; just in case we skip this digit
   1234  f000				  -	      beq	pvnibble2char_skipnibbledw
   1235  f000				  -
   1236  f000				  -pvnibble2chardw
   1237  f000				  -			; high nibble...
   1238  f000				  -	      lda	(temp7),y
   1239  f000				  -	      and	#$f0
   1240  f000				  -	      lsr
   1241  f000				  -	      lsr
   1242  f000				  -	      lsr
   1243  f000				  -	      lsr
   1244  f000				  -
   1245  f000				  -	      clc
   1246  f000				  -	      adc	temp1	; add the offset to character graphics to our value
   1247  f000				  -	      sta	VALBUFFER,x
   1248  f000				  -	      inx
   1249  f000				  -	      dec	plotdigitcount
   1250  f000				  -pvnibble2char_skipnibbledw
   1251  f000				  -			; low nibble...
   1252  f000				  -	      lda	(temp7),y
   1253  f000				  -	      and	#$0f
   1254  f000				  -	      clc
   1255  f000				  -	      adc	temp1	; add the offset to character graphics to our value
   1256  f000				  -	      sta	VALBUFFER,x
   1257  f000				  -	      inx
   1258  f000				  -	      iny
   1259  f000				  -
   1260  f000				  -	      dec	plotdigitcount
   1261  f000				  -	      bne	pvnibble2chardw
   1262  f000				  -			;point to the start of our valuebuffer
   1263  f000				  -	      clc
   1264  f000				  -	      lda	#<VALBUFFER
   1265  f000				  -	      adc	valbufend
   1266  f000				  -	      sta	temp1
   1267  f000				  -	      lda	#>VALBUFFER
   1268  f000				  -	      adc	#0
   1269  f000				  -	      sta	temp2
   1270  f000				  -
   1271  f000				  -			;advance valbufend to the end of our value buffer
   1272  f000				  -	      stx	valbufend
   1273  f000				  -
   1274  f000				  -	      ifnconst	plotvalueonscreen
   1275  f000				  -	      jmp	plotcharacters
   1276  f000				  -	      else
   1277  f000				  -	      jmp	plotcharacterslive
   1278  f000				  -	      endif
   1279  f000				  -	      endif		; DOUBLEWIDE
   1280  f000				  -
   1281  f000				  -hiscoreend
   1282  f000				  -	      echo	" (hiscore module is using ",[(hiscoreend-hiscorestart)]d," bytes)"
   1283  f000				  -	      endif		; !isBANKSETBANK
   1284  f000					      endif		; HSSUPPORT
   1285  f000
------- FILE test320c.78b.asm
   1030  f000					      endif
   1031  f000					      ifnconst	included.fourbitfade.asm
------- FILE fourbitfade.asm LEVEL 2 PASS 3
      0  f000					      include	fourbitfade.asm
      1  f000							; ** fourbit fade, which is useful for audio levels and brightness fades
      2  f000							; ** input:  A=value to fade, fourbitfadevalue=global fade value
      3  f000							; **	      N.B. the global fade value is in the upper nibble. i.e. $Fx-0x
      4  f000							; ** output: A=faded value in lo nibble. orig top nibble is preserved,
      5  f000							; **	      other registers are preserved
      6  f000
      7  f000				  -	      ifconst	FOURBITFADE
      8  f000				  -
      9  f000				  -			; non-interrupt routine
     10  f000				  -
     11  f000				  -fourbitfade
     12  f000				  -	      sty	fourbittemp1
     13  f000				  -	      pha
     14  f000				  -	      and	#$0F
     15  f000				  -	      ora	fourbitfadevalue
     16  f000				  -	      tay
     17  f000				  -	      pla
     18  f000				  -	      and	#$F0
     19  f000				  -	      ora	fourbitfadelut,y
     20  f000				  -	      ldy	fourbittemp1	; restore Y
     21  f000				  -	      rts
     22  f000				  -
     23  f000				  -			; interrupt routine
     24  f000				  -
     25  f000				  -fourbitfadeint
     26  f000				  -	      sty	fourbittemp1int
     27  f000				  -	      pha
     28  f000				  -	      and	#$0F
     29  f000				  -	      ora	fourbitfadevalueint
     30  f000				  -	      tay
     31  f000				  -	      pla
     32  f000				  -	      and	#$F0
     33  f000				  -	      ora	fourbitfadelut,y
     34  f000				  -	      ldy	fourbittemp1int	; restore Y
     35  f000				  -	      rts
     36  f000				  -
     37  f000				  -fourbitfadelut
     38  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     39  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
     40  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02
     41  f000				  -	      .byte	$00,$00,$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03
     42  f000				  -	      .byte	$00,$00,$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04
     43  f000				  -	      .byte	$00,$00,$00,$01,$01,$01,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
     44  f000				  -	      .byte	$00,$00,$00,$01,$01,$02,$02,$03,$03,$03,$04,$04,$05,$05,$06,$06
     45  f000				  -	      .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
     46  f000				  -	      .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$05,$05,$06,$06,$07,$07,$08
     47  f000				  -	      .byte	$00,$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$06,$07,$08,$08,$09
     48  f000				  -	      .byte	$00,$00,$01,$02,$02,$03,$04,$04,$05,$06,$06,$07,$08,$08,$09,$0a
     49  f000				  -	      .byte	$00,$00,$01,$02,$03,$03,$04,$05,$06,$06,$07,$08,$09,$09,$0a,$0b
     50  f000				  -	      .byte	$00,$00,$01,$02,$03,$04,$04,$05,$06,$07,$08,$08,$09,$0a,$0b,$0c
     51  f000				  -	      .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0a,$0b,$0c,$0d
     52  f000				  -	      .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e
     53  f000				  -	      .byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
     54  f000				  -
     55  f000				  -fourbitfadeend
     56  f000				  -
     57  f000				  -	      echo	"  (fourbitfade module is using ",[(fourbitfadeend-fourbitfade)]d," bytes)"
     58  f000				  -
     59  f000					      endif
------- FILE test320c.78b.asm
   1033  f000					      endif
   1034  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1035  f000
   1036  f000							;standard routimes needed for pretty much all games
   1037  f000
   1038  f000							; some definitions used with "set debug color"
   1039  f000		       00 91	   DEBUGCALC  =	$91
   1040  f000		       00 41	   DEBUGWASTE =	$41
   1041  f000		       00 c1	   DEBUGDRAW  =	$C1
   1042  f000
   1043  f000							;NMI and IRQ handlers
   1044  f000				   NMI
   1045  f000							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   1046  f000		       48		      pha		; save A
   1047  f001		       d8		      cld
   1048  f002		       a5 4d		      lda	visibleover
   1049  f004		       49 ff		      eor	#255
   1050  f006		       85 4d		      sta	visibleover
   1051  f008				  -	      ifconst	DEBUGINTERRUPT
   1052  f008				  -	      and	#$93
   1053  f008				  -	      sta	BACKGRND
   1054  f008					      endif
   1055  f008		       8a		      txa		; save X
   1056  f009		       48		      pha
   1057  f00a		       98		      tya		; save Y
   1058  f00b		       48		      pha
   1059  f00c		       ce b2 01 	      dec	interruptindex
   1060  f00f		       d0 03		      bne	skipreallyoffvisible
   1061  f011		       4c 6b f0 	      jmp	reallyoffvisible
   1062  f014				   skipreallyoffvisible
   1063  f014		       a5 4d		      lda	visibleover
   1064  f016		       d0 03		      bne	carryontopscreenroutine
   1065  f018				  -	      ifconst	.bottomscreenroutine
   1066  f018				  -	      lda	interrupthold
   1067  f018				  -	      beq	skipbottomroutine
   1068  f018				  -	      jsr	.bottomscreenroutine
   1069  f018				  -skipbottomroutine
   1070  f018					      endif
   1071  f018		       4c 79 f0 	      jmp	NMIexit
   1072  f01b				   carryontopscreenroutine
   1073  f01b				  -	      ifconst	.topscreenroutine
   1074  f01b				  -	      lda	interrupthold
   1075  f01b				  -	      beq	skiptoproutine
   1076  f01b				  -	      jsr	.topscreenroutine
   1077  f01b				  -skiptoproutine
   1078  f01b					      endif
   1079  f01b					      ifnconst	CANARYOFF
   1080  f01b		       ad c1 01 	      lda	canary
   1081  f01e		       f0 07		      beq	skipcanarytriggered
   1082  f020		       a9 45		      lda	#$45
   1083  f022		       85 20		      sta	BACKGRND
   1084  f024		       4c 63 f0 	      jmp	skipbrkolorset	; common crash dump routine, if available
   1085  f027				   skipcanarytriggered
   1086  f027					      endif
   1087  f027
   1088  f027		       ee 3e 21 	      inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   1089  f02a
   1090  f02a							; ** Other important routines that need to regularly run, and can run onscreen.
   1091  f02a							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   1092  f02a
   1093  f02a				  -	      ifconst	LONGCONTROLLERREAD
   1094  f02a				  -longcontrollerreads		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   1095  f02a				  -	      ldy	port1control
   1096  f02a				  -	      lda	longreadtype,y
   1097  f02a				  -	      beq	LLRET1
   1098  f02a				  -	      tay
   1099  f02a				  -	      lda	longreadroutinehiP1,y
   1100  f02a				  -	      sta	inttemp4
   1101  f02a				  -	      lda	longreadroutineloP1,y
   1102  f02a				  -	      sta	inttemp3
   1103  f02a				  -	      jmp	(inttemp3)
   1104  f02a				  -LLRET1
   1105  f02a				  -	      ldy	port0control
   1106  f02a				  -	      lda	longreadtype,y
   1107  f02a				  -	      beq	LLRET0
   1108  f02a				  -	      tay
   1109  f02a				  -	      lda	longreadroutinehiP0,y
   1110  f02a				  -	      sta	inttemp4
   1111  f02a				  -	      lda	longreadroutineloP0,y
   1112  f02a				  -	      sta	inttemp3
   1113  f02a				  -	      jmp	(inttemp3)
   1114  f02a				  -LLRET0
   1115  f02a				  -
   1116  f02a				  -
   1117  f02a				  -	      ifconst	PADDLERANGE
   1118  f02a				  -TIMEVAL    =	PADDLERANGE
   1119  f02a				  -	      else
   1120  f02a				  -TIMEVAL    =	160
   1121  f02a				  -	      endif
   1122  f02a				  -TIMEOFFSET =	10
   1123  f02a				  -
   1124  f02a					      endif		; LONGCONTROLLERREAD
   1125  f02a
   1126  f02a
   1127  f02a		       20 e7 f1 	      jsr	servicesfxchannels
   1128  f02d				  -	      ifconst	MUSICTRACKER
   1129  f02d				  -	      jsr	servicesong
   1130  f02d					      endif		; MUSICTRACKER
   1131  f02d				  -	      ifconst	RMT
   1132  f02d				  -	      lda	rasterpause
   1133  f02d				  -	      beq	skiprasterupdate
   1134  f02d				  -	      jsr	RASTERMUSICTRACKER+3
   1135  f02d				  -skiprasterupdate
   1136  f02d				  -RMT_Iend
   1137  f02d					      endif
   1138  f02d
   1139  f02d		       ee a4 01 	      inc	framecounter
   1140  f030		       ad a4 01 	      lda	framecounter
   1141  f033		       29 3f		      and	#63
   1142  f035		       d0 08		      bne	skipcountdownseconds
   1143  f037		       ad a5 01 	      lda	countdownseconds
   1144  f03a		       f0 03		      beq	skipcountdownseconds
   1145  f03c		       ce a5 01 	      dec	countdownseconds
   1146  f03f				   skipcountdownseconds
   1147  f03f
   1148  f03f		       a2 01		      ldx	#1
   1149  f041				   buttonreadloop
   1150  f041		       8a		      txa
   1151  f042		       48		      pha
   1152  f043		       bc b7 01 	      ldy	port0control,x
   1153  f046		       b9 c4 f1 	      lda	buttonhandlerlo,y
   1154  f049		       85 da		      sta	inttemp3
   1155  f04b		       b9 b8 f1 	      lda	buttonhandlerhi,y
   1156  f04e		       85 db		      sta	inttemp4
   1157  f050		       05 da		      ora	inttemp3
   1158  f052		       f0 03		      beq	buttonreadloopreturn
   1159  f054		       6c da 00 	      jmp	(inttemp3)
   1160  f057				   buttonreadloopreturn
   1161  f057		       68		      pla
   1162  f058		       aa		      tax
   1163  f059		       ca		      dex
   1164  f05a		       10 e5		      bpl	buttonreadloop
   1165  f05c
   1166  f05c							;ifconst KEYPADSUPPORT
   1167  f05c							;  jsr keypadrowselect
   1168  f05c							;endif ; KEYPADSUPPORT
   1169  f05c
   1170  f05c
   1171  f05c				  -	      ifconst	DOUBLEBUFFER
   1172  f05c				  -	      lda	doublebufferminimumframeindex
   1173  f05c				  -	      beq	skipdoublebufferminimumframeindexadjust
   1174  f05c				  -	      dec	doublebufferminimumframeindex
   1175  f05c				  -skipdoublebufferminimumframeindexadjust
   1176  f05c					      endif
   1177  f05c
   1178  f05c		       4c 79 f0 	      jmp	NMIexit
   1179  f05f
   1180  f05f				   IRQ			; the only source of non-nmi interrupt should be the BRK opcode.
   1181  f05f					      ifnconst	BREAKPROTECTOFF
   1182  f05f		       a9 1a		      lda	#$1A
   1183  f061		       85 20		      sta	BACKGRND
   1184  f063				   skipbrkolorset
   1185  f063				   skipbrkdetected
   1186  f063		       a9 60		      lda	#$60
   1187  f065		       8d 07 21 	      sta	sCTRL
   1188  f068		       85 3c		      sta	CTRL
   1189  f06a					      ifnconst	hiscorefont
   1190  f06a		       02		      .byte.b	$02	; KIL/JAM
   1191  f06b				  -	      else		; hiscorefont is present
   1192  f06b				  -	      ifconst	CRASHDUMP
   1193  f06b				  -	      bit	MSTAT
   1194  f06b				  -	      bpl	skipbrkdetected	; wait for vblank to ensure we're clear of NMI
   1195  f06b				  -
   1196  f06b				  -	      ifconst	dumpbankswitch
   1197  f06b				  -	      lda	dumpbankswitch
   1198  f06b				  -	      pha
   1199  f06b				  -	      endif
   1200  f06b				  -
   1201  f06b				  -			; bankswitch if needed, to get to the hiscore font
   1202  f06b				  -	      ifconst	bankswitchmode
   1203  f06b				  -	      ifconst	included.hiscore.asm.bank
   1204  f06b				  -	      ifconst	MCPDEVCART
   1205  f06b				  -	      lda	#($18 | included.hiscore.asm.bank)
   1206  f06b				  -	      sta	$3000
   1207  f06b				  -	      else
   1208  f06b				  -	      lda	#(included.hiscore.asm.bank)
   1209  f06b				  -	      sta	$8000
   1210  f06b				  -	      endif
   1211  f06b				  -	      endif		; included.hiscore.asm.bank
   1212  f06b				  -	      endif		; bankswitchmode
   1213  f06b				  -
   1214  f06b				  -	      ifconst	DOUBLEBUFFER
   1215  f06b				  -			;turn off double-buffering, if on...
   1216  f06b				  -	      lda	#>DLLMEM
   1217  f06b				  -	      sta	DPPH
   1218  f06b				  -	      lda	#<DLLMEM
   1219  f06b				  -	      sta	DPPL
   1220  f06b				  -	      endif
   1221  f06b				  -
   1222  f06b				  -	      lda	#$00
   1223  f06b				  -	      sta	P0C2
   1224  f06b				  -
   1225  f06b				  -			;update the second-from-top DL...
   1226  f06b				  -	      ldy	#8
   1227  f06b				  -NMIupdatetopDL
   1228  f06b				  -	      lda	show2700,y
   1229  f06b				  -	      sta	ZONE1ADDRESS,y
   1230  f06b				  -	      dey
   1231  f06b				  -	      bpl	NMIupdatetopDL
   1232  f06b				  -
   1233  f06b				  -			; the hiscore font is present, so we try to output the stack
   1234  f06b				  -	      ldy	#0
   1235  f06b				  -copystackloop
   1236  f06b				  -	      pla
   1237  f06b				  -	      pha
   1238  f06b				  -	      lsr
   1239  f06b				  -	      lsr
   1240  f06b				  -	      lsr
   1241  f06b				  -	      lsr
   1242  f06b				  -	      tax
   1243  f06b				  -	      lda	hiscorehexlut,x
   1244  f06b				  -	      sta	$2700,y
   1245  f06b				  -	      iny
   1246  f06b				  -
   1247  f06b				  -	      pla
   1248  f06b				  -	      and	#$0F
   1249  f06b				  -	      tax
   1250  f06b				  -	      lda	hiscorehexlut,x
   1251  f06b				  -	      sta	$2700,y
   1252  f06b				  -	      iny
   1253  f06b				  -
   1254  f06b				  -	      lda	#27	; period
   1255  f06b				  -	      sta	$2700,y
   1256  f06b				  -	      iny
   1257  f06b				  -
   1258  f06b				  -	      cpy	#30
   1259  f06b				  -	      bne	copystackloop
   1260  f06b				  -
   1261  f06b				  -	      lda	#>hiscorefont
   1262  f06b				  -	      sta	CHARBASE
   1263  f06b				  -	      sta	sCHARBASE
   1264  f06b				  -	      lda	#%01000011	;Enable DMA, mode=320A
   1265  f06b				  -	      sta	CTRL
   1266  f06b				  -	      sta	sCTRL
   1267  f06b				  -	      .byte	$02	; KIL/JAM
   1268  f06b				  -hiscorehexlut
   1269  f06b				  -			;	  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
   1270  f06b				  -	      .byte	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 0, 1, 2, 3, 4, 5
   1271  f06b				  -show2700
   1272  f06b				  -			;	 lo   mode	   hi	width=29  x   EODL
   1273  f06b				  -	      .byte	$00, %01100000, $27, 3, 20, 0,0,0
   1274  f06b				  -	      else		; CRASHDUMP
   1275  f06b				  -	      .byte	$02	; KIL/JAM
   1276  f06b				  -	      endif		; crashdump
   1277  f06b					      endif		; hiscorefont
   1278  f06b				  -	      else
   1279  f06b				  -	      RTI
   1280  f06b					      endif
   1281  f06b
   1282  f06b				  -	      ifconst	LONGCONTROLLERREAD
   1283  f06b				  -
   1284  f06b				  -longreadtype
   1285  f06b				  -	      .byte	0, 0, 0, 1	; NONE     PROLINE   LIGHTGUN	PADDLE
   1286  f06b				  -	      .byte	2, 0, 3, 0	; TRKBALL  VCSSTICK  DRIVING	KEYPAD
   1287  f06b				  -	      .byte	3, 3, 0, 0	; STMOUSE  AMOUSE    ATARIVOX	SNES
   1288  f06b				  -
   1289  f06b				  -longreadroutineloP0
   1290  f06b				  -	      .byte	<LLRET0	;  0 = no routine
   1291  f06b				  -	      .byte	<paddleport0update	;  1 = paddle
   1292  f06b				  -	      .byte	<trakball0update	;  2 = trakball
   1293  f06b				  -	      .byte	<mouse0update	;  3 = mouse
   1294  f06b				  -
   1295  f06b				  -longreadroutinehiP0
   1296  f06b				  -	      .byte	>LLRET0	;  0 = no routine
   1297  f06b				  -	      .byte	>paddleport0update	;  1 = paddle
   1298  f06b				  -	      .byte	>trakball0update	;  2 = trackball
   1299  f06b				  -	      .byte	>mouse0update	;  3 = mouse
   1300  f06b				  -
   1301  f06b				  -longreadroutineloP1
   1302  f06b				  -	      .byte	<LLRET1	;  0 = no routine
   1303  f06b				  -	      .byte	<paddleport1update	;  1 = paddle
   1304  f06b				  -	      .byte	<trakball1update	;  2 = trakball
   1305  f06b				  -	      .byte	<mouse1update	;  3 = mouse
   1306  f06b				  -
   1307  f06b				  -longreadroutinehiP1
   1308  f06b				  -	      .byte	>LLRET1	;  0 = no routine
   1309  f06b				  -	      .byte	>paddleport1update	;  1 = paddle
   1310  f06b				  -	      .byte	>trakball1update	;  2 = trackball
   1311  f06b				  -	      .byte	>mouse1update	;  3 = mouse
   1312  f06b				  -
   1313  f06b				  -
   1314  f06b				  -SETTIM64T
   1315  f06b				  -	      bne	skipdefaulttime
   1316  f06b				  -	      ifnconst	PADDLESMOOTHINGOFF
   1317  f06b				  -	      lda	#(TIMEVAL+TIMEOFFSET+1)
   1318  f06b				  -	      else
   1319  f06b				  -	      lda	#(TIMEVAL+TIMEOFFSET)
   1320  f06b				  -	      endif
   1321  f06b				  -skipdefaulttime
   1322  f06b				  -	      tay
   1323  f06b				  -	      dey
   1324  f06b				  -.setTIM64Tloop
   1325  f06b				  -	      sta	TIM64T
   1326  f06b				  -	      cpy	INTIM
   1327  f06b				  -	      bne	.setTIM64Tloop
   1328  f06b				  -	      rts
   1329  f06b					      endif		; LONGCONTROLLERREAD
   1330  f06b
   1331  f06b				   reallyoffvisible
   1332  f06b		       85 24		      sta	WSYNC
   1333  f06d
   1334  f06d		       a9 00		      lda	#0
   1335  f06f		       85 4d		      sta	visibleover
   1336  f071				  -	      ifconst	DEBUGINTERRUPT
   1337  f071				  -	      sta	BACKGRND
   1338  f071					      endif
   1339  f071
   1340  f071		       a9 03		      lda	#3
   1341  f073		       8d b2 01 	      sta	interruptindex
   1342  f076
   1343  f076		       20 59 f1 	      jsr	uninterruptableroutines
   1344  f079
   1345  f079				  -	      ifconst	.userinterrupt
   1346  f079				  -	      lda	interrupthold
   1347  f079				  -	      beq	skipuserintroutine
   1348  f079				  -	      jsr	.userinterrupt
   1349  f079				  -skipuserintroutine
   1350  f079					      endif
   1351  f079
   1352  f079				  -	      ifconst	KEYPADSUPPORT
   1353  f079				  -	      jsr	keypadcolumnread
   1354  f079				  -	      jsr	keypadrowselect
   1355  f079					      endif
   1356  f079
   1357  f079				   NMIexit
   1358  f079		       68		      pla
   1359  f07a		       a8		      tay
   1360  f07b		       68		      pla
   1361  f07c		       aa		      tax
   1362  f07d		       68		      pla
   1363  f07e		       40		      RTI
   1364  f07f
   1365  f07f				   clearscreen
   1366  f07f		       a2 17		      ldx	#(WZONECOUNT-1)
   1367  f081		       a9 00		      lda	#0
   1368  f083				   clearscreenloop
   1369  f083		       95 65		      sta	dlend,x
   1370  f085		       ca		      dex
   1371  f086		       10 fb		      bpl	clearscreenloop
   1372  f088		       a9 00		      lda	#0
   1373  f08a		       8d ad 01 	      sta	valbufend	; clear the bcd value buffer
   1374  f08d		       8d ae 01 	      sta	valbufendsave
   1375  f090		       60		      rts
   1376  f091
   1377  f091				   restorescreen
   1378  f091		       a2 17		      ldx	#(WZONECOUNT-1)
   1379  f093		       a9 00		      lda	#0
   1380  f095				   restorescreenloop
   1381  f095		       b5 82		      lda	dlendsave,x
   1382  f097		       95 65		      sta	dlend,x
   1383  f099		       ca		      dex
   1384  f09a		       10 f9		      bpl	restorescreenloop
   1385  f09c		       ad ae 01 	      lda	valbufendsave
   1386  f09f		       8d ad 01 	      sta	valbufend
   1387  f0a2		       60		      rts
   1388  f0a3
   1389  f0a3				   savescreen
   1390  f0a3		       a2 17		      ldx	#(WZONECOUNT-1)
   1391  f0a5				   savescreenloop
   1392  f0a5		       b5 65		      lda	dlend,x
   1393  f0a7		       95 82		      sta	dlendsave,x
   1394  f0a9		       ca		      dex
   1395  f0aa		       10 f9		      bpl	savescreenloop
   1396  f0ac		       ad ad 01 	      lda	valbufend
   1397  f0af		       8d ae 01 	      sta	valbufendsave
   1398  f0b2				  -	      ifconst	DOUBLEBUFFER
   1399  f0b2				  -	      lda	doublebufferstate
   1400  f0b2				  -	      beq	savescreenrts
   1401  f0b2				  -	      lda	#1
   1402  f0b2				  -	      sta	doublebufferbufferdirty
   1403  f0b2				  -savescreenrts
   1404  f0b2					      endif		; DOUBLEBUFFER
   1405  f0b2		       60		      rts
   1406  f0b3
   1407  f0b3				   drawscreen
   1408  f0b3
   1409  f0b3				  -	      ifconst	interrupthold
   1410  f0b3				  -	      lda	#$FF
   1411  f0b3				  -	      sta	interrupthold	; if the user called drawscreen, we're ready for interrupts
   1412  f0b3					      endif
   1413  f0b3
   1414  f0b3		       a9 00		      lda	#0
   1415  f0b5		       85 42		      sta	temp1	; not B&W if we're here...
   1416  f0b7
   1417  f0b7				   drawscreenwait
   1418  f0b7		       a5 4d		      lda	visibleover
   1419  f0b9		       d0 fc		      bne	drawscreenwait	; make sure the visible screen isn't being drawn
   1420  f0bb
   1421  f0bb							;restore some registers in case the game changed them mid-screen...
   1422  f0bb		       ad 07 21 	      lda	sCTRL
   1423  f0be		       05 42		      ora	temp1
   1424  f0c0		       85 3c		      sta	CTRL
   1425  f0c2		       ad 0b 21 	      lda	sCHARBASE
   1426  f0c5		       85 34		      sta	CHARBASE
   1427  f0c7
   1428  f0c7							;ensure all of the display list is terminated...
   1429  f0c7		       20 3f f1 	      jsr	terminatedisplaylist
   1430  f0ca
   1431  f0ca					      ifnconst	pauseroutineoff
   1432  f0ca		       20 d5 f0 	      jsr	pauseroutine
   1433  f0cd					      endif		; pauseroutineoff
   1434  f0cd
   1435  f0cd							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   1436  f0cd							; delaying a full frame, but still allowing time for basic calculations.
   1437  f0cd				   visiblescreenstartedwait
   1438  f0cd		       a5 4d		      lda	visibleover
   1439  f0cf		       f0 fc		      beq	visiblescreenstartedwait
   1440  f0d1				   visiblescreenstartedwaitdone
   1441  f0d1		       ce 3e 21 	      dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   1442  f0d4		       60		      rts
   1443  f0d5
   1444  f0d5					      ifnconst	pauseroutineoff
   1445  f0d5							; check to see if pause was pressed and released
   1446  f0d5				   pauseroutine
   1447  f0d5		       ad b3 01 	      lda	pausedisable
   1448  f0d8		       d0 55		      bne	leavepauseroutine
   1449  f0da		       a9 08		      lda	#8
   1450  f0dc		       2c 82 02 	      bit	SWCHB
   1451  f0df		       f0 30		      beq	pausepressed
   1452  f0e1
   1453  f0e1					      ifnconst	SOFTPAUSEOFF
   1454  f0e1					      ifnconst	SOFTRESETASPAUSEOFF
   1455  f0e1					      ifnconst	MOUSESUPPORT
   1456  f0e1					      ifnconst	TRAKBALLSUPPORT
   1457  f0e1		       ad b7 01 	      lda	port0control
   1458  f0e4		       c9 0b		      cmp	#11
   1459  f0e6		       d0 07		      bne	skipsoftpause
   1460  f0e8		       ad 80 02 	      lda	SWCHA	; then check the soft "RESET" joysick code...
   1461  f0eb		       29 70		      and	#%01110000	; _LDU
   1462  f0ed		       f0 22		      beq	pausepressed
   1463  f0ef				   skipsoftpause
   1464  f0ef					      endif
   1465  f0ef					      endif
   1466  f0ef					      endif
   1467  f0ef					      endif
   1468  f0ef				  -	      ifconst	SNES0PAUSE
   1469  f0ef				  -	      lda	port0control
   1470  f0ef				  -	      cmp	#11
   1471  f0ef				  -	      bne	skipsnes0pause
   1472  f0ef				  -	      lda	snesdetected0
   1473  f0ef				  -	      beq	skipsnes0pause
   1474  f0ef				  -	      lda	snes2atari0hi
   1475  f0ef				  -	      and	#%00010000
   1476  f0ef				  -	      beq	pausepressed
   1477  f0ef				  -skipsnes0pause
   1478  f0ef					      endif
   1479  f0ef				  -	      ifconst	SNES1PAUSE
   1480  f0ef				  -
   1481  f0ef				  -	      lda	port1control
   1482  f0ef				  -	      cmp	#11
   1483  f0ef				  -	      bne	skipsnes1pause
   1484  f0ef				  -	      lda	snesdetected1
   1485  f0ef				  -	      beq	skipsnes1pause
   1486  f0ef				  -	      lda	snes2atari1hi
   1487  f0ef				  -	      and	#%00010000
   1488  f0ef				  -	      beq	pausepressed
   1489  f0ef				  -skipsnes1pause
   1490  f0ef					      endif
   1491  f0ef				  -	      ifconst	SNESNPAUSE
   1492  f0ef				  -	      ldx	snesport
   1493  f0ef				  -	      lda	port0control,x
   1494  f0ef				  -	      cmp	#11
   1495  f0ef				  -	      bne	skipsnesNpause
   1496  f0ef				  -	      lda	snesdetected0,x
   1497  f0ef				  -	      beq	skipsnesNpause
   1498  f0ef				  -	      lda	snes2atari0hi,x
   1499  f0ef				  -	      and	#%00010000
   1500  f0ef				  -	      beq	pausepressed
   1501  f0ef				  -skipsnesNpause
   1502  f0ef					      endif
   1503  f0ef
   1504  f0ef							;pause isn't pressed
   1505  f0ef		       a9 00		      lda	#0
   1506  f0f1		       8d ac 01 	      sta	pausebuttonflag	; clear pause hold state in case its set
   1507  f0f4
   1508  f0f4							;check if we're in an already paused state
   1509  f0f4		       ad 00 21 	      lda	pausestate
   1510  f0f7		       f0 36		      beq	leavepauseroutine	; nope, leave
   1511  f0f9
   1512  f0f9		       c9 01		      cmp	#1	; last frame was the start of pausing
   1513  f0fb		       f0 2b		      beq	enterpausestate2	; move from state 1 to 2
   1514  f0fd
   1515  f0fd		       c9 02		      cmp	#2
   1516  f0ff		       f0 34		      beq	carryonpausing
   1517  f101
   1518  f101							;pausestate must be >2, which means we're ending an unpause
   1519  f101		       a9 00		      lda	#0
   1520  f103		       8d ac 01 	      sta	pausebuttonflag
   1521  f106		       8d 00 21 	      sta	pausestate
   1522  f109		       ad 07 21 	      lda	sCTRL
   1523  f10c		       85 3c		      sta	CTRL
   1524  f10e		       4c 2f f1 	      jmp	leavepauseroutine
   1525  f111
   1526  f111				   pausepressed
   1527  f111							;pause is pressed
   1528  f111		       ad ac 01 	      lda	pausebuttonflag
   1529  f114		       c9 ff		      cmp	#$ff
   1530  f116		       f0 1d		      beq	carryonpausing
   1531  f118
   1532  f118							;its a new press, increment the state
   1533  f118		       ee 00 21 	      inc	pausestate
   1534  f11b
   1535  f11b							;silence volume at the start and end of pausing
   1536  f11b		       a9 00		      lda	#0
   1537  f11d		       85 19		      sta	AUDV0
   1538  f11f		       85 1a		      sta	AUDV1
   1539  f121
   1540  f121				  -	      ifconst	pokeysupport
   1541  f121				  -	      ldy	#7
   1542  f121				  -pausesilencepokeyaudioloop
   1543  f121				  -	      sta	(pokeybase),y
   1544  f121				  -	      dey
   1545  f121				  -	      bpl	pausesilencepokeyaudioloop
   1546  f121					      endif		; pokeysupport
   1547  f121
   1548  f121		       a9 ff		      lda	#$ff
   1549  f123		       8d ac 01 	      sta	pausebuttonflag
   1550  f126		       d0 0d		      bne	carryonpausing
   1551  f128
   1552  f128				   enterpausestate2
   1553  f128		       a9 02		      lda	#2
   1554  f12a		       8d 00 21 	      sta	pausestate
   1555  f12d		       d0 06		      bne	carryonpausing
   1556  f12f				   leavepauseroutine
   1557  f12f		       ad 07 21 	      lda	sCTRL
   1558  f132		       85 3c		      sta	CTRL
   1559  f134		       60		      rts
   1560  f135				   carryonpausing
   1561  f135				  -	      ifconst	.pause
   1562  f135				  -	      jsr	.pause
   1563  f135					      endif		; .pause
   1564  f135		       ad 07 21 	      lda	sCTRL
   1565  f138		       09 80		      ora	#%10000000	; turn off colorburst during pause...
   1566  f13a		       85 3c		      sta	CTRL
   1567  f13c		       4c d5 f0 	      jmp	pauseroutine
   1568  f13f					      endif		; pauseroutineoff
   1569  f13f
   1570  f13f
   1571  f13f				  -	      ifconst	DOUBLEBUFFER
   1572  f13f				  -skipterminatedisplaylistreturn
   1573  f13f				  -	      rts
   1574  f13f					      endif		; DOUBLEBUFFER
   1575  f13f				   terminatedisplaylist
   1576  f13f				  -	      ifconst	DOUBLEBUFFER
   1577  f13f				  -	      lda	doublebufferstate
   1578  f13f				  -	      bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   1579  f13f					      endif		; DOUBLEBUFFER
   1580  f13f				   terminatedisplaybuffer
   1581  f13f							;add DL end entry on each DL
   1582  f13f		       a2 17		      ldx	#(WZONECOUNT-1)
   1583  f141				   dlendloop
   1584  f141		       bd c8 f5 	      lda	DLPOINTL,x
   1585  f144				  -	      ifconst	DOUBLEBUFFER
   1586  f144				  -	      clc
   1587  f144				  -	      adc	doublebufferdloffset
   1588  f144					      endif		; DOUBLEBUFFER
   1589  f144		       85 63		      sta	dlpnt
   1590  f146		       bd b0 f5 	      lda	DLPOINTH,x
   1591  f149				  -	      ifconst	DOUBLEBUFFER
   1592  f149				  -	      adc	#0
   1593  f149					      endif		; DOUBLEBUFFER
   1594  f149		       85 64		      sta	dlpnt+1
   1595  f14b		       b4 65		      ldy	dlend,x
   1596  f14d		       a9 00		      lda	#$00
   1597  f14f				   dlendmoreloops
   1598  f14f		       c8		      iny
   1599  f150		       91 63		      sta	(dlpnt),y
   1600  f152				  -	      ifconst	FRAMESKIPGLITCHFIXWEAK
   1601  f152				  -	      cpy	#DLLASTOBJ+1
   1602  f152				  -	      beq	dlendthiszonedone
   1603  f152				  -	      iny
   1604  f152				  -	      iny
   1605  f152				  -	      iny
   1606  f152				  -	      iny
   1607  f152				  -	      iny
   1608  f152				  -	      sta	(dlpnt),y
   1609  f152				  -dlendthiszonedone
   1610  f152					      endif	FRAMESKIPGLITCHFIXWEAK
   1611  f152				  -	      ifconst	FRAMESKIPGLITCHFIX
   1612  f152				  -	      iny
   1613  f152				  -	      iny
   1614  f152				  -	      iny
   1615  f152				  -	      iny
   1616  f152				  -	      cpy	#DLLASTOBJ-1
   1617  f152				  -	      bcc	dlendmoreloops
   1618  f152					      endif		; FRAMESKIPGLITCHFIX
   1619  f152		       ca		      dex
   1620  f153		       10 ec		      bpl	dlendloop
   1621  f155
   1622  f155					      ifnconst	pauseroutineoff
   1623  f155		       20 d5 f0 	      jsr	pauseroutine
   1624  f158					      endif		; pauseroutineoff
   1625  f158		       60		      rts
   1626  f159
   1627  f159				   uninterruptableroutines
   1628  f159							; this is for routines that must happen off the visible screen, each frame.
   1629  f159
   1630  f159				  -	      ifconst	AVOXVOICE
   1631  f159				  -	      jsr	serviceatarivoxqueue
   1632  f159					      endif
   1633  f159
   1634  f159		       a9 00		      lda	#0
   1635  f15b		       8d b6 01 	      sta	palfastframe
   1636  f15e		       ad 09 21 	      lda	paldetected
   1637  f161		       f0 10		      beq	skippalframeadjusting
   1638  f163							; ** PAL console is detected. we increment palframes to accurately count 5 frames,
   1639  f163		       ae b5 01 	      ldx	palframes
   1640  f166		       e8		      inx
   1641  f167		       e0 05		      cpx	#5
   1642  f169		       d0 05		      bne	palframeskipdone
   1643  f16b		       ee b6 01 	      inc	palfastframe
   1644  f16e		       a2 00		      ldx	#0
   1645  f170				   palframeskipdone
   1646  f170		       8e b5 01 	      stx	palframes
   1647  f173				   skippalframeadjusting
   1648  f173
   1649  f173				  -	      ifconst	MUSICTRACKER
   1650  f173				  -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   1651  f173				  -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   1652  f173				  -			; If that happens, we try again here. Chances are very small we'll run into the same
   1653  f173				  -			; problem twice, and if we do, we just drop a musical note or two.
   1654  f173				  -	      lda	sfxschedulemissed
   1655  f173				  -	      beq	servicesongwasnotmissed
   1656  f173				  -	      jsr	servicesong
   1657  f173				  -servicesongwasnotmissed
   1658  f173					      endif		; MUSICTRACKER
   1659  f173
   1660  f173				  -	      ifconst	RMT
   1661  f173				  -	      lda	palfastframe
   1662  f173				  -	      beq	skiprasterupdate2
   1663  f173				  -	      lda	rasterpause
   1664  f173				  -	      beq	skiprasterupdate2
   1665  f173				  -	      jsr	RASTERMUSICTRACKER+3
   1666  f173				  -skiprasterupdate2
   1667  f173					      endif
   1668  f173
   1669  f173
   1670  f173		       60		      rts
   1671  f174
   1672  f174				   serviceatarivoxqueue
   1673  f174				  -	      ifconst	AVOXVOICE
   1674  f174				  -	      lda	voxlock
   1675  f174				  -	      bne	skipvoxprocessing	; the vox is in the middle of speech address update
   1676  f174				  -skipvoxqueuesizedec
   1677  f174				  -	      jmp	processavoxvoice
   1678  f174				  -skipvoxprocessing
   1679  f174				  -	      rts
   1680  f174				  -
   1681  f174				  -processavoxvoice
   1682  f174				  -	      ifconst	HSSUPPORT
   1683  f174				  -			; ** we skip speech if hi-score is on and no vox was detected
   1684  f174				  -			; ** this is to avoid later collision with snes pads.
   1685  f174				  -	      lda	hsdevice
   1686  f174				  -	      and	#2
   1687  f174				  -	      beq	processavoxvoicereturn
   1688  f174				  -	      endif		; HSSUPPORT
   1689  f174				  -	      lda	avoxenable
   1690  f174				  -	      bne	avoxfixport
   1691  f174				  -	      SPKOUT	tempavox
   1692  f174				  -	      rts
   1693  f174				  -avoxfixport
   1694  f174				  -	      lda	#0	; restore the port to all bits as inputs...
   1695  f174				  -	      sta	CTLSWA
   1696  f174				  -	      rts
   1697  f174				  -silenceavoxvoice
   1698  f174				  -	      SPEAK	avoxsilentdata
   1699  f174				  -processavoxvoicereturn
   1700  f174				  -	      rts
   1701  f174				  -avoxsilentdata
   1702  f174				  -	      .byte	31,255
   1703  f174					      else
   1704  f174		       60		      rts
   1705  f175					      endif		; AVOXVOICE
   1706  f175
   1707  f175				   joybuttonhandler
   1708  f175		       8a		      txa
   1709  f176		       0a		      asl
   1710  f177		       a8		      tay
   1711  f178		       b9 08 00 	      lda	INPT0,y
   1712  f17b		       4a		      lsr
   1713  f17c		       9d 02 21 	      sta	sINPT1,x
   1714  f17f		       b9 09 00 	      lda	INPT1,y
   1715  f182		       29 80		      and	#%10000000
   1716  f184		       1d 02 21 	      ora	sINPT1,x
   1717  f187		       9d 02 21 	      sta	sINPT1,x
   1718  f18a
   1719  f18a		       b5 0c		      lda	INPT4,x
   1720  f18c		       30 19		      bmi	.skip1bjoyfirecheck
   1721  f18e							;one button joystick is down
   1722  f18e		       49 80		      eor	#%10000000
   1723  f190		       9d 02 21 	      sta	sINPT1,x
   1724  f193
   1725  f193		       ad b1 01 	      lda	joybuttonmode
   1726  f196		       3d aa f1 	      and	twobuttonmask,x
   1727  f199		       f0 0c		      beq	.skip1bjoyfirecheck
   1728  f19b		       ad b1 01 	      lda	joybuttonmode
   1729  f19e		       1d aa f1 	      ora	twobuttonmask,x
   1730  f1a1		       8d b1 01 	      sta	joybuttonmode
   1731  f1a4		       8d 82 02 	      sta	SWCHB
   1732  f1a7				   .skip1bjoyfirecheck
   1733  f1a7		       4c 57 f0 	      jmp	buttonreadloopreturn
   1734  f1aa
   1735  f1aa				   twobuttonmask
   1736  f1aa		       04 10		      .byte.b	%00000100,%00010000
   1737  f1ac
   1738  f1ac				  -	      ifconst	SNES2ATARISUPPORT
   1739  f1ac				  -
   1740  f1ac				  -SNES_CLOCK_PORT_BIT
   1741  f1ac				  -	      .byte	$10,$01
   1742  f1ac				  -SNES_CTLSWA_MASK
   1743  f1ac				  -	      .byte	$30,$03
   1744  f1ac				  -SNES_CTLSWA_SIGNAL
   1745  f1ac				  -	      .byte	$C0,$0C
   1746  f1ac				  -SWCHA_DIRMASK
   1747  f1ac				  -	      .byte	$F0,$0F
   1748  f1ac				  -SWCHA_INVDIRMASK
   1749  f1ac				  -	      .byte	$0F,$F0
   1750  f1ac				  -
   1751  f1ac				  -			; Probe each port for SNES, and see if autodetection succeeds anywhere.
   1752  f1ac				  -SNES_AUTODETECT
   1753  f1ac				  -	      ifconst	HSSUPPORT
   1754  f1ac				  -			; ** an atarivox might be plugged in, so we skip scanning the second
   1755  f1ac				  -			; ** port for a snes if vox was detected...
   1756  f1ac				  -	      lda	hsdevice	; b1 high means atarivox/savekey was detected
   1757  f1ac				  -	      lsr
   1758  f1ac				  -	      and	#1
   1759  f1ac				  -	      eor	#1
   1760  f1ac				  -	      tax
   1761  f1ac				  -	      else
   1762  f1ac				  -	      ldx	#1
   1763  f1ac				  -	      endif		; HSSUPPORT
   1764  f1ac				  -
   1765  f1ac				  -SNES_AUTODETECT_LOOP
   1766  f1ac				  -	      lda	#1	; proline
   1767  f1ac				  -	      sta	port0control,x
   1768  f1ac				  -	      jsr	setportforinput
   1769  f1ac				  -	      jsr	setonebuttonmode
   1770  f1ac				  -	      jsr	SNES_READ
   1771  f1ac				  -	      lda	snesdetected0,x
   1772  f1ac				  -	      bne	SNES_AUTODETECT_FOUND
   1773  f1ac				  -			; detection failed
   1774  f1ac				  -	      jsr	setportforinput
   1775  f1ac				  -	      jsr	settwobuttonmode
   1776  f1ac				  -	      dex
   1777  f1ac				  -	      bpl	SNES_AUTODETECT_LOOP
   1778  f1ac				  -	      rts
   1779  f1ac				  -SNES_AUTODETECT_FOUND
   1780  f1ac				  -	      lda	#11	; formally set the snes controller
   1781  f1ac				  -	      sta	port0control,x
   1782  f1ac				  -	      stx	snesport
   1783  f1ac				  -	      rts
   1784  f1ac					      endif		; SNES2ATARISUPPORT
   1785  f1ac
   1786  f1ac				   snes2atarihandler
   1787  f1ac				  -	      ifconst	SNES2ATARISUPPORT
   1788  f1ac				  -SNES2ATARI
   1789  f1ac				  -	      jsr	SNES_READ
   1790  f1ac				  -	      jmp	buttonreadloopreturn
   1791  f1ac				  -
   1792  f1ac				  -SNES_READ
   1793  f1ac				  -			; x=0 for left port, x=1 for right
   1794  f1ac				  -
   1795  f1ac				  -			; Start by checking if any port directions are pressed.
   1796  f1ac				  -			; Abort the autodetect for this port if so, as snes2atari doesn't ground any
   1797  f1ac				  -			; direction pins. if directions are pressed and the port is changed to output,
   1798  f1ac				  -			; that means the output is direct-shorted, and nobody seems to know if riot's
   1799  f1ac				  -			; output mode has current protection.
   1800  f1ac				  -
   1801  f1ac				  -	      lda	SWCHA
   1802  f1ac				  -	      ora	SWCHA_INVDIRMASK,x
   1803  f1ac				  -	      eor	SWCHA_DIRMASK,x
   1804  f1ac				  -	      bne	SNES_READ_cont1
   1805  f1ac				  -	      jmp	SNES_ABORT
   1806  f1ac				  -SNES_READ_cont1
   1807  f1ac				  -
   1808  f1ac				  -	      lda	port0control,x
   1809  f1ac				  -	      cmp	#11	; snes
   1810  f1ac				  -	      bne	snes2atari_signal_go	; if this is a first auto-detection read, go ahead and signal
   1811  f1ac				  -	      lda	snesdetected0,x
   1812  f1ac				  -	      bne	snes2atari_signal_skip	; if snes was available in previous frames, skip signalling
   1813  f1ac				  -snes2atari_signal_go
   1814  f1ac				  -	      jsr	SNES2ATARI_SIGNAL
   1815  f1ac				  -snes2atari_signal_skip
   1816  f1ac				  -
   1817  f1ac				  -			;lda SNES_CTLSWA_MASK,x
   1818  f1ac				  -
   1819  f1ac				  -	      lda	CTLSWA
   1820  f1ac				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   1821  f1ac				  -	      ora	SNES_CTLSWA_MASK,x
   1822  f1ac				  -	      sta	CTLSWA	; enable pins UP/DOWN to work as outputs
   1823  f1ac				  -
   1824  f1ac				  -	      lda	SWCHA
   1825  f1ac				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   1826  f1ac				  -	      ora	SNES_CTLSWA_MASK,x
   1827  f1ac				  -
   1828  f1ac				  -	      sta	SWCHA	; latch+clock high
   1829  f1ac				  -	      nop
   1830  f1ac				  -	      nop
   1831  f1ac				  -	      nop
   1832  f1ac				  -	      nop
   1833  f1ac				  -	      nop
   1834  f1ac				  -	      nop
   1835  f1ac				  -	      nop
   1836  f1ac				  -	      lda	SWCHA
   1837  f1ac				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   1838  f1ac				  -	      sta	SWCHA	; latch and clock low
   1839  f1ac				  -	      ldy	#16	; 16 bits
   1840  f1ac				  -SNES2ATARILOOP
   1841  f1ac				  -	      rol	INPT4,x	; sample data into carry
   1842  f1ac				  -	      lda	SWCHA
   1843  f1ac				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   1844  f1ac				  -	      ora	SNES_CLOCK_PORT_BIT,x
   1845  f1ac				  -	      sta	SWCHA	; clock low
   1846  f1ac				  -	      rol	snes2atari0lo,x
   1847  f1ac				  -	      rol	snes2atari0hi,x
   1848  f1ac				  -	      lda	SWCHA
   1849  f1ac				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   1850  f1ac				  -	      sta	SWCHA	; latch and clock low
   1851  f1ac				  -	      dey		; next bit
   1852  f1ac				  -	      bne	SNES2ATARILOOP
   1853  f1ac				  -	      rol	INPT4,x	; 17th bit should be lo if controller is there.
   1854  f1ac				  -	      rol		; 17th snes bit into A low bit
   1855  f1ac				  -	      eor	snes2atari0lo,x	; 16th bit should be hi if controller is there.
   1856  f1ac				  -	      and	#1
   1857  f1ac				  -	      sta	snesdetected0,x
   1858  f1ac				  -	      beq	SNES_STOP_CLOCK	; if snes isn't detected, leave port in default state
   1859  f1ac				  -	      stx	snesport	; snesport keeps the index of the latest autodetected controller
   1860  f1ac				  -	      lda	SWCHA
   1861  f1ac				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   1862  f1ac				  -	      ora	SNES_CLOCK_PORT_BIT,x
   1863  f1ac				  -SNES_STOP_CLOCK
   1864  f1ac				  -	      sta	SWCHA	; clock low
   1865  f1ac				  -	      lda	CTLSWA
   1866  f1ac				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   1867  f1ac				  -	      ora	SNES_CLOCK_PORT_BIT,x
   1868  f1ac				  -	      sta	CTLSWA	; set port bits to input avoid conflict with other drivers
   1869  f1ac				  -	      rts
   1870  f1ac				  -SNES_ABORT
   1871  f1ac				  -	      sta	snesdetected0,x
   1872  f1ac				  -	      rts
   1873  f1ac				  -SNES2ATARI_SIGNAL
   1874  f1ac				  -			; signal to SNES2ATARI++ that we want SNES mode...
   1875  f1ac				  -	      lda	CTLSWA
   1876  f1ac				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   1877  f1ac				  -	      ora	SNES_CTLSWA_SIGNAL,x
   1878  f1ac				  -	      sta	CTLSWA
   1879  f1ac				  -	      lda	CTLSWA
   1880  f1ac				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   1881  f1ac				  -	      sta	SWCHA
   1882  f1ac				  -	      ldy	#0
   1883  f1ac				  -SNES_SIGNAL_LOOP
   1884  f1ac				  -	      dey
   1885  f1ac				  -	      bne	SNES_SIGNAL_LOOP
   1886  f1ac				  -	      lda	SWCHA
   1887  f1ac				  -	      ora	SWCHA_DIRMASK,x
   1888  f1ac				  -	      sta	SWCHA
   1889  f1ac				  -	      rts
   1890  f1ac					      endif
   1891  f1ac
   1892  f1ac				   gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   1893  f1ac				  -	      ifconst	LIGHTGUNSUPPORT
   1894  f1ac				  -	      cpx	#0
   1895  f1ac				  -	      bne	secondportgunhandler
   1896  f1ac				  -firstportgunhandler
   1897  f1ac				  -	      lda	SWCHA
   1898  f1ac				  -	      asl
   1899  f1ac				  -	      asl
   1900  f1ac				  -	      asl		; shift D4 to D7
   1901  f1ac				  -	      and	#%10000000
   1902  f1ac				  -	      eor	#%10000000
   1903  f1ac				  -	      sta	sINPT1
   1904  f1ac				  -	      jmp	buttonreadloopreturn
   1905  f1ac				  -secondportgunhandler
   1906  f1ac				  -	      lda	SWCHA
   1907  f1ac				  -	      lsr		; shift D0 into carry
   1908  f1ac				  -	      lsr		; shift carry into D7
   1909  f1ac				  -	      and	#%10000000
   1910  f1ac				  -	      eor	#%10000000
   1911  f1ac				  -	      sta	sINPT3
   1912  f1ac				  -	      jmp	buttonreadloopreturn
   1913  f1ac					      endif		; LIGHTGUNSUPPORT
   1914  f1ac
   1915  f1ac				   controlsusing2buttoncode
   1916  f1ac		       00		      .byte.b	0	; 00=no controller plugged in
   1917  f1ad		       01		      .byte.b	1	; 01=proline joystick
   1918  f1ae		       00		      .byte.b	0	; 02=lightgun
   1919  f1af		       00		      .byte.b	0	; 03=paddle
   1920  f1b0		       01		      .byte.b	1	; 04=trakball
   1921  f1b1		       01		      .byte.b	1	; 05=vcs joystick
   1922  f1b2		       01		      .byte.b	1	; 06=driving control
   1923  f1b3		       00		      .byte.b	0	; 07=keypad control
   1924  f1b4		       00		      .byte.b	0	; 08=st mouse/cx80
   1925  f1b5		       00		      .byte.b	0	; 09=amiga mouse
   1926  f1b6		       01		      .byte.b	1	; 10=atarivox
   1927  f1b7		       00		      .byte.b	0	; 11=snes2atari
   1928  f1b8
   1929  f1b8				   buttonhandlerhi
   1930  f1b8		       00		      .byte.b	0	; 00=no controller plugged in
   1931  f1b9		       f1		      .byte.b	>joybuttonhandler	; 01=proline joystick
   1932  f1ba		       f1		      .byte.b	>gunbuttonhandler	; 02=lightgun
   1933  f1bb		       f4		      .byte.b	>paddlebuttonhandler	; 03=paddle
   1934  f1bc		       f1		      .byte.b	>joybuttonhandler	; 04=trakball
   1935  f1bd		       f1		      .byte.b	>joybuttonhandler	; 05=vcs joystick
   1936  f1be		       f1		      .byte.b	>joybuttonhandler	; 06=driving control
   1937  f1bf		       00		      .byte.b	0	; 07=keypad
   1938  f1c0		       f4		      .byte.b	>mousebuttonhandler	; 08=st mouse
   1939  f1c1		       f4		      .byte.b	>mousebuttonhandler	; 09=amiga mouse
   1940  f1c2		       f1		      .byte.b	>joybuttonhandler	; 10=atarivox
   1941  f1c3		       f1		      .byte.b	>snes2atarihandler	; 11=snes
   1942  f1c4				   buttonhandlerlo
   1943  f1c4		       00		      .byte.b	0	; 00=no controller plugged in
   1944  f1c5		       75		      .byte.b	<joybuttonhandler	; 01=proline joystick
   1945  f1c6		       ac		      .byte.b	<gunbuttonhandler	; 02=lightgun
   1946  f1c7		       f9		      .byte.b	<paddlebuttonhandler	; 03=paddle
   1947  f1c8		       75		      .byte.b	<joybuttonhandler	; 04=trakball
   1948  f1c9		       75		      .byte.b	<joybuttonhandler	; 05=vcs joystick
   1949  f1ca		       75		      .byte.b	<joybuttonhandler	; 06=driving control
   1950  f1cb		       00		      .byte.b	0	; 07=keypad
   1951  f1cc		       f9		      .byte.b	<mousebuttonhandler	; 08=st mouse
   1952  f1cd		       f9		      .byte.b	<mousebuttonhandler	; 09=amiga mouse
   1953  f1ce		       75		      .byte.b	<joybuttonhandler	; 10=atarivox
   1954  f1cf		       ac		      .byte.b	<snes2atarihandler	; 11=snes
   1955  f1d0
   1956  f1d0				   drawwait
   1957  f1d0		       24 4d		      bit	visibleover	; 255 if screen is being drawn, 0 when not.
   1958  f1d2		       30 fc		      bmi	drawwait	; make sure the visible screen isn't being drawn
   1959  f1d4		       60		      rts
   1960  f1d5
   1961  f1d5				   drawoverwait
   1962  f1d5		       24 4d		      bit	visibleover	; 255 if screen is being drawn, 0 when not.
   1963  f1d7		       10 fc		      bpl	drawoverwait	; make sure the visible screen is being drawn
   1964  f1d9		       60		      rts
   1965  f1da
   1966  f1da
   1967  f1da				   mutetia
   1968  f1da		       a9 00		      lda	#0
   1969  f1dc		       a2 03		      ldx	#3
   1970  f1de				   mutetialoop
   1971  f1de		       95 4e		      sta	sfx1pointlo,x
   1972  f1e0		       95 17		      sta	AUDF0,x
   1973  f1e2		       ca		      dex
   1974  f1e3		       10 f9		      bpl	mutetialoop
   1975  f1e5		       60		      rts
   1976  f1e6
   1977  f1e6				   servicesfxchannelsdone
   1978  f1e6					      ifnconst	pokeysupport
   1979  f1e6		       60		      rts
   1980  f1e7				  -	      else
   1981  f1e7				  -	      jmp	checkpokeyplaying
   1982  f1e7					      endif
   1983  f1e7				   servicesfxchannels
   1984  f1e7		       a2 ff		      ldx	#255
   1985  f1e9				   servicesfxchannelsloop
   1986  f1e9		       e8		      inx
   1987  f1ea					      ifnconst	TIASFXMONO
   1988  f1ea		       e0 02		      cpx	#2
   1989  f1ec				  -	      else
   1990  f1ec				  -	      cpx	#1
   1991  f1ec					      endif
   1992  f1ec		       f0 f8		      beq	servicesfxchannelsdone
   1993  f1ee
   1994  f1ee		       a5 de		      lda	sfxschedulelock	; =1 if locked
   1995  f1f0		       d0 f4		      bne	servicesfxchannelsdone	; exit if a pointer may be mid-way change
   1996  f1f2
   1997  f1f2		       b5 4e		      lda	sfx1pointlo,x
   1998  f1f4		       85 dc		      sta	inttemp5
   1999  f1f6		       15 50		      ora	sfx1pointhi,x
   2000  f1f8		       f0 ef		      beq	servicesfxchannelsloop
   2001  f1fa		       b5 50		      lda	sfx1pointhi,x
   2002  f1fc		       85 dd		      sta	inttemp6
   2003  f1fe
   2004  f1fe		       b5 58		      lda	sfx1tick,x
   2005  f200		       f0 05		      beq	servicesfx_cont1	; this chunk is over, load the next!
   2006  f202		       d6 58		      dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   2007  f204		       4c e9 f1 	      jmp	servicesfxchannelsloop
   2008  f207				   servicesfx_cont1
   2009  f207
   2010  f207		       a0 01		      ldy	#1	; check to see if they're changing the frame countdown
   2011  f209		       b1 dc		      lda	(inttemp5),y
   2012  f20b		       c9 10		      cmp	#$10
   2013  f20d		       d0 1b		      bne	servicesfx_cont1a
   2014  f20f		       a0 02		      ldy	#2
   2015  f211		       b1 dc		      lda	(inttemp5),y
   2016  f213		       95 56		      sta	sfx1frames,x	; change the frame countdown
   2017  f215		       a9 00		      lda	#0
   2018  f217		       95 58		      sta	sfx1tick,x
   2019  f219							; advance the sound pointer by 3...
   2020  f219		       b5 4e		      lda	sfx1pointlo,x
   2021  f21b		       18		      clc
   2022  f21c		       69 03		      adc	#3
   2023  f21e		       95 4e		      sta	sfx1pointlo,x
   2024  f220		       b5 50		      lda	sfx1pointhi,x
   2025  f222		       69 00		      adc	#0
   2026  f224		       95 50		      sta	sfx1pointhi,x
   2027  f226							; and then fetch another sample for this channel...
   2028  f226		       ca		      dex
   2029  f227		       4c e9 f1 	      jmp	servicesfxchannelsloop
   2030  f22a				   servicesfx_cont1a
   2031  f22a
   2032  f22a		       b5 56		      lda	sfx1frames,x	; set the frame countdown for this sound chunk
   2033  f22c		       95 58		      sta	sfx1tick,x
   2034  f22e
   2035  f22e		       b5 52		      lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   2036  f230		       f0 02		      beq	servicesfx_cont2
   2037  f232		       d6 52		      dec	sfx1priority,x
   2038  f234				   servicesfx_cont2
   2039  f234
   2040  f234		       a0 00		      ldy	#0	; play the sound
   2041  f236		       b1 dc		      lda	(inttemp5),y
   2042  f238		       85 d8		      sta	inttemp1
   2043  f23a
   2044  f23a				  -	      ifconst	MUSICTRACKER
   2045  f23a				  -	      lda	sfx1notedata,x
   2046  f23a				  -	      beq	exitmusictracker	; exit if this isn't a pitched instrument
   2047  f23a				  -	      ldy	#0
   2048  f23a				  -	      sty	inttemp2
   2049  f23a				  -	      clc
   2050  f23a				  -	      adc	(inttemp5),y
   2051  f23a				  -	      asl		; x2
   2052  f23a				  -	      tay
   2053  f23a				  -	      lda	tiatrackeroctavenotes,y
   2054  f23a				  -	      sta	AUDC0,x
   2055  f23a				  -	      iny
   2056  f23a				  -	      lda	tiatrackeroctavenotes,y
   2057  f23a				  -	      sta	AUDF0,x
   2058  f23a				  -	      ldy	#1
   2059  f23a				  -	      jmp	sfxvolumeentrypt
   2060  f23a				  -exitmusictracker
   2061  f23a				  -	      lda	inttemp1
   2062  f23a					      endif		; MUSICTRACKER
   2063  f23a
   2064  f23a		       18		      clc
   2065  f23b		       75 54		      adc	sfx1poffset,x	; take into account any pitch modification
   2066  f23d		       95 17		      sta	AUDF0,x
   2067  f23f		       c8		      iny
   2068  f240		       b1 dc		      lda	(inttemp5),y
   2069  f242		       95 15		      sta	AUDC0,x
   2070  f244		       85 d9		      sta	inttemp2
   2071  f246		       c8		      iny
   2072  f247				   sfxvolumeentrypt
   2073  f247				  -	      ifconst	TIAVOLUME
   2074  f247				  -	      lda	tiavolume
   2075  f247				  -	      asl
   2076  f247				  -	      asl
   2077  f247				  -	      asl
   2078  f247				  -	      asl
   2079  f247				  -	      sta	fourbitfadevalueint
   2080  f247					      endif		; TIAVOLUME
   2081  f247		       b1 dc		      lda	(inttemp5),y
   2082  f249				  -	      ifconst	TIAVOLUME
   2083  f249				  -	      jsr	fourbitfadeint
   2084  f249					      endif		; TIAVOLUME
   2085  f249		       95 19		      sta	AUDV0,x
   2086  f24b		       c9 10		      cmp	#$10
   2087  f24d		       b0 19		      bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   2088  f24f
   2089  f24f		       05 d9		      ora	inttemp2
   2090  f251		       05 d8		      ora	inttemp1	; check if F|C|V=0
   2091  f253		       f0 23		      beq	zerosfx	; if so, we're at the end of the sound.
   2092  f255
   2093  f255				   advancesfxpointer
   2094  f255							; advance the pointer to the next sound chunk
   2095  f255		       c8		      iny
   2096  f256		       84 da		      sty	inttemp3
   2097  f258		       18		      clc
   2098  f259		       b5 4e		      lda	sfx1pointlo,x
   2099  f25b		       65 da		      adc	inttemp3
   2100  f25d		       95 4e		      sta	sfx1pointlo,x
   2101  f25f		       b5 50		      lda	sfx1pointhi,x
   2102  f261		       69 00		      adc	#0
   2103  f263		       95 50		      sta	sfx1pointhi,x
   2104  f265		       4c e9 f1 	      jmp	servicesfxchannelsloop
   2105  f268
   2106  f268				   sfxsoundloop
   2107  f268		       48		      pha
   2108  f269		       b5 52		      lda	sfx1priority,x
   2109  f26b		       d0 04		      bne	sfxsoundloop_carryon
   2110  f26d		       68		      pla		; fix the stack before we go
   2111  f26e		       4c 55 f2 	      jmp	advancesfxpointer
   2112  f271				   sfxsoundloop_carryon
   2113  f271		       68		      pla
   2114  f272		       29 f0		      and	#$F0
   2115  f274		       4a		      lsr
   2116  f275		       4a		      lsr
   2117  f276		       4a		      lsr
   2118  f277		       4a		      lsr
   2119  f278
   2120  f278				   zerosfx
   2121  f278		       95 4e		      sta	sfx1pointlo,x
   2122  f27a		       95 50		      sta	sfx1pointhi,x
   2123  f27c		       95 52		      sta	sfx1priority,x
   2124  f27e		       4c e9 f1 	      jmp	servicesfxchannelsloop
   2125  f281
   2126  f281
   2127  f281				   schedulesfx
   2128  f281							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   2129  f281		       a0 00		      ldy	#0
   2130  f283		       b1 e0		      lda	(sfxinstrumentlo),y
   2131  f285				  -	      ifconst	pokeysupport
   2132  f285				  -	      cmp	#$20	; POKEY?
   2133  f285				  -	      bne	scheduletiasfx
   2134  f285				  -	      jmp	schedulepokeysfx
   2135  f285					      endif
   2136  f285				   scheduletiasfx
   2137  f285							;cmp #$10 ; TIA?
   2138  f285							;beq continuescheduletiasfx
   2139  f285							; rts ; unhandled!!!
   2140  f285				   continuescheduletiasfx
   2141  f285					      ifnconst	TIASFXMONO
   2142  f285		       a5 4e		      lda	sfx1pointlo
   2143  f287		       05 50		      ora	sfx1pointhi
   2144  f289		       f0 13		      beq	schedulesfx1	;if channel 1 is idle, use it
   2145  f28b		       a5 4f		      lda	sfx2pointlo
   2146  f28d		       05 51		      ora	sfx2pointhi
   2147  f28f		       f0 11		      beq	schedulesfx2	;if channel 2 is idle, use it
   2148  f291							; Both channels are scheduled.
   2149  f291		       a0 01		      ldy	#1
   2150  f293		       b1 e0		      lda	(sfxinstrumentlo),y
   2151  f295		       d0 01		      bne	interruptsfx
   2152  f297		       60		      rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   2153  f298				   interruptsfx
   2154  f298							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   2155  f298		       a5 52		      lda	sfx1priority
   2156  f29a		       c5 53		      cmp	sfx2priority
   2157  f29c		       b0 04		      bcs	schedulesfx2
   2158  f29e					      endif		; !TIASFXMONO
   2159  f29e
   2160  f29e				   schedulesfx1
   2161  f29e		       a2 00		      ldx	#0	; channel 1
   2162  f2a0					      ifnconst	TIASFXMONO
   2163  f2a0		       f0 02		      beq	skipschedulesfx2
   2164  f2a2				   schedulesfx2
   2165  f2a2		       a2 01		      ldx	#1	; channel 2
   2166  f2a4				   skipschedulesfx2
   2167  f2a4					      endif		; !TIASFXMONO
   2168  f2a4
   2169  f2a4				  -	      ifconst	MUSICTRACKER
   2170  f2a4				  -	      lda	sfxnoteindex
   2171  f2a4				  -	      bpl	skipdrumkitoverride
   2172  f2a4				  -	      and	#$7F	; subtract 128
   2173  f2a4				  -	      sec
   2174  f2a4				  -	      sbc	#4	; drums start at 132, i.e. octave 10
   2175  f2a4				  -	      asl
   2176  f2a4				  -	      tay
   2177  f2a4				  -	      lda	tiadrumkitdefinition,y
   2178  f2a4				  -	      sta	sfxinstrumentlo
   2179  f2a4				  -	      iny
   2180  f2a4				  -	      lda	tiadrumkitdefinition,y
   2181  f2a4				  -	      sta	sfxinstrumenthi
   2182  f2a4				  -	      lda	#0
   2183  f2a4				  -	      sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   2184  f2a4				  -skipdrumkitoverride
   2185  f2a4					      endif		; MUSICTRACKER
   2186  f2a4		       a0 01		      ldy	#1	; get priority and sound-resolution (in frames)
   2187  f2a6		       b1 e0		      lda	(sfxinstrumentlo),y
   2188  f2a8		       95 52		      sta	sfx1priority,x
   2189  f2aa		       c8		      iny
   2190  f2ab		       b1 e0		      lda	(sfxinstrumentlo),y
   2191  f2ad		       95 56		      sta	sfx1frames,x
   2192  f2af		       a5 e0		      lda	sfxinstrumentlo
   2193  f2b1		       18		      clc
   2194  f2b2		       69 03		      adc	#3
   2195  f2b4		       95 4e		      sta	sfx1pointlo,x
   2196  f2b6		       a5 e1		      lda	sfxinstrumenthi
   2197  f2b8		       69 00		      adc	#0
   2198  f2ba		       95 50		      sta	sfx1pointhi,x
   2199  f2bc		       a5 e2		      lda	sfxpitchoffset
   2200  f2be		       95 54		      sta	sfx1poffset,x
   2201  f2c0		       a9 00		      lda	#0
   2202  f2c2		       95 58		      sta	sfx1tick,x
   2203  f2c4		       a5 e3		      lda	sfxnoteindex
   2204  f2c6		       95 cd		      sta	sfx1notedata,x
   2205  f2c8		       60		      rts
   2206  f2c9
   2207  f2c9				   plotsprite
   2208  f2c9					      ifnconst	NODRAWWAIT
   2209  f2c9				  -	      ifconst	DOUBLEBUFFER
   2210  f2c9				  -	      lda	doublebufferstate
   2211  f2c9				  -	      bne	skipplotspritewait
   2212  f2c9					      endif		; DOUBLEBUFFER
   2213  f2c9				  -	      ifconst	DEBUGWAITCOLOR
   2214  f2c9				  -	      lda	#$41
   2215  f2c9				  -	      sta	BACKGRND
   2216  f2c9					      endif
   2217  f2c9				   plotspritewait
   2218  f2c9		       a5 4d		      lda	visibleover
   2219  f2cb		       d0 fc		      bne	plotspritewait
   2220  f2cd				   skipplotspritewait
   2221  f2cd				  -	      ifconst	DEBUGWAITCOLOR
   2222  f2cd				  -	      lda	#$0
   2223  f2cd				  -	      sta	BACKGRND
   2224  f2cd					      endif
   2225  f2cd					      endif
   2226  f2cd
   2227  f2cd							;arguments:
   2228  f2cd							; temp1=lo graphicdata
   2229  f2cd							; temp2=hi graphicdata
   2230  f2cd							; temp3=palette | width byte
   2231  f2cd							; temp4=x
   2232  f2cd							; temp5=y
   2233  f2cd							; temp6=mode
   2234  f2cd		       a5 46		      lda	temp5	;Y position
   2235  f2cf		       4a		      lsr		; 2 - Divide by 8 or 16
   2236  f2d0		       4a		      lsr		; 2
   2237  f2d1		       4a		      lsr		; 2
   2238  f2d2				  -	      if	WZONEHEIGHT = 16
   2239  f2d2				  -	      lsr		; 2
   2240  f2d2					      endif
   2241  f2d2
   2242  f2d2		       aa		      tax
   2243  f2d3
   2244  f2d3					      ifnconst	NOLIMITCHECKING
   2245  f2d3
   2246  f2d3							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   2247  f2d3
   2248  f2d3		       c9 18		      cmp	#WZONECOUNT
   2249  f2d5
   2250  f2d5		       90 0a		      bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   2251  f2d7							; otherwise, check to see if the bottom half is in zone 0...
   2252  f2d7
   2253  f2d7				  -	      if	WZONEHEIGHT = 16
   2254  f2d7				  -	      cmp	#15
   2255  f2d7					      else
   2256  f2d7		       c9 1f		      cmp	#31
   2257  f2d9					      endif
   2258  f2d9
   2259  f2d9		       d0 05		      bne	exitplotsprite1
   2260  f2db		       a2 00		      ldx	#0
   2261  f2dd		       4c 16 f3 	      jmp	continueplotsprite2
   2262  f2e0				   exitplotsprite1
   2263  f2e0		       60		      rts
   2264  f2e1
   2265  f2e1				   continueplotsprite1
   2266  f2e1					      endif
   2267  f2e1
   2268  f2e1		       bd c8 f5 	      lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   2269  f2e4				  -	      ifconst	DOUBLEBUFFER
   2270  f2e4				  -	      clc
   2271  f2e4				  -	      adc	doublebufferdloffset
   2272  f2e4					      endif		; DOUBLEBUFFER
   2273  f2e4		       85 63		      sta	dlpnt
   2274  f2e6		       bd b0 f5 	      lda	DLPOINTH,x
   2275  f2e9				  -	      ifconst	DOUBLEBUFFER
   2276  f2e9				  -	      adc	#0
   2277  f2e9					      endif		; DOUBLEBUFFER
   2278  f2e9		       85 64		      sta	dlpnt+1
   2279  f2eb
   2280  f2eb							;Create DL entry for upper part of sprite
   2281  f2eb
   2282  f2eb		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   2283  f2ed
   2284  f2ed				  -	      ifconst	CHECKOVERWRITE
   2285  f2ed				  -	      cpy	#DLLASTOBJ
   2286  f2ed				  -	      beq	checkcontinueplotsprite2
   2287  f2ed				  -continueplotsprite1a
   2288  f2ed					      endif
   2289  f2ed
   2290  f2ed		       a5 42		      lda	temp1	; graphic data, lo byte
   2291  f2ef		       91 63		      sta	(dlpnt),y	;Low byte of data address
   2292  f2f1
   2293  f2f1					      ifnconst	ATOMICSPRITEUPDATE
   2294  f2f1		       c8		      iny
   2295  f2f2		       a5 47		      lda	temp6
   2296  f2f4		       91 63		      sta	(dlpnt),y
   2297  f2f6				  -	      else
   2298  f2f6				  -	      iny
   2299  f2f6				  -	      sty	temp8
   2300  f2f6					      endif
   2301  f2f6
   2302  f2f6		       c8		      iny
   2303  f2f7
   2304  f2f7		       a5 46		      lda	temp5	;Y position
   2305  f2f9		       29 07		      and	#(WZONEHEIGHT - 1)
   2306  f2fb		       c9 01		      cmp	#1	; clear carry if our sprite is just in this zone
   2307  f2fd		       05 43		      ora	temp2	; graphic data, hi byte
   2308  f2ff		       91 63		      sta	(dlpnt),y
   2309  f301
   2310  f301
   2311  f301		       c8		      iny
   2312  f302		       a5 44		      lda	temp3	;palette|width
   2313  f304		       91 63		      sta	(dlpnt),y
   2314  f306
   2315  f306		       c8		      iny
   2316  f307		       a5 45		      lda	temp4	;Horizontal position
   2317  f309		       91 63		      sta	(dlpnt),y
   2318  f30b
   2319  f30b		       c8		      iny
   2320  f30c		       94 65		      sty	dlend,x
   2321  f30e
   2322  f30e				  -	      ifconst	ALWAYSTERMINATE
   2323  f30e				  -	      iny
   2324  f30e				  -	      lda	#0
   2325  f30e				  -	      sta	(dlpnt),y
   2326  f30e					      endif
   2327  f30e
   2328  f30e				  -	      ifconst	ATOMICSPRITEUPDATE
   2329  f30e				  -	      ldy	temp8
   2330  f30e				  -	      lda	temp6
   2331  f30e				  -	      sta	(dlpnt),y
   2332  f30e					      endif
   2333  f30e
   2334  f30e				   checkcontinueplotsprite2
   2335  f30e
   2336  f30e		       90 33		      bcc	doneSPDL	;branch if the sprite was fully in the last zone
   2337  f310
   2338  f310							;Create DL entry for lower part of sprite
   2339  f310
   2340  f310		       e8		      inx		;Next region
   2341  f311
   2342  f311					      ifnconst	NOLIMITCHECKING
   2343  f311		       e0 18		      cpx	#WZONECOUNT
   2344  f313
   2345  f313		       90 01		      bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   2346  f315		       60		      rts
   2347  f316				   continueplotsprite2
   2348  f316					      endif
   2349  f316
   2350  f316		       bd c8 f5 	      lda	DLPOINTL,x	;Get pointer to next DL
   2351  f319				  -	      ifconst	DOUBLEBUFFER
   2352  f319				  -	      clc
   2353  f319				  -	      adc	doublebufferdloffset
   2354  f319					      endif		; DOUBLEBUFFER
   2355  f319		       85 63		      sta	dlpnt
   2356  f31b		       bd b0 f5 	      lda	DLPOINTH,x
   2357  f31e				  -	      ifconst	DOUBLEBUFFER
   2358  f31e				  -	      adc	#0
   2359  f31e					      endif		; DOUBLEBUFFER
   2360  f31e		       85 64		      sta	dlpnt+1
   2361  f320		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   2362  f322
   2363  f322				  -	      ifconst	CHECKOVERWRITE
   2364  f322				  -	      cpy	#DLLASTOBJ
   2365  f322				  -	      bne	continueplotsprite2a
   2366  f322				  -	      rts
   2367  f322				  -continueplotsprite2a
   2368  f322					      endif
   2369  f322
   2370  f322		       a5 42		      lda	temp1	; graphic data, lo byte
   2371  f324		       91 63		      sta	(dlpnt),y
   2372  f326
   2373  f326					      ifnconst	ATOMICSPRITEUPDATE
   2374  f326		       c8		      iny
   2375  f327		       a5 47		      lda	temp6
   2376  f329		       91 63		      sta	(dlpnt),y
   2377  f32b				  -	      else
   2378  f32b				  -	      iny
   2379  f32b				  -	      sty	temp8
   2380  f32b					      endif
   2381  f32b
   2382  f32b		       c8		      iny
   2383  f32c
   2384  f32c		       a5 46		      lda	temp5	;Y position
   2385  f32e		       0b 07		      anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   2386  f330		       05 43		      ora	temp2	; graphic data, hi byte
   2387  f332		       e9 07		      sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   2388  f334		       91 63		      sta	(dlpnt),y
   2389  f336
   2390  f336		       c8		      iny
   2391  f337
   2392  f337		       a5 44		      lda	temp3	;palette|width
   2393  f339		       91 63		      sta	(dlpnt),y
   2394  f33b
   2395  f33b		       c8		      iny
   2396  f33c
   2397  f33c		       a5 45		      lda	temp4	;Horizontal position
   2398  f33e		       91 63		      sta	(dlpnt),y
   2399  f340
   2400  f340		       c8		      iny
   2401  f341		       94 65		      sty	dlend,x
   2402  f343
   2403  f343				  -	      ifconst	ALWAYSTERMINATE
   2404  f343				  -	      iny
   2405  f343				  -	      lda	#0
   2406  f343				  -	      sta	(dlpnt),y
   2407  f343					      endif
   2408  f343
   2409  f343				  -	      ifconst	ATOMICSPRITEUPDATE
   2410  f343				  -	      ldy	temp8
   2411  f343				  -	      lda	temp6
   2412  f343				  -	      sta	(dlpnt),y
   2413  f343					      endif
   2414  f343
   2415  f343				   doneSPDL
   2416  f343		       60		      rts
   2417  f344
   2418  f344
   2419  f344				   lockzonex
   2420  f344				  -	      ifconst	ZONELOCKS
   2421  f344				  -	      ldy	dlend,x
   2422  f344				  -	      cpy	#DLLASTOBJ
   2423  f344				  -	      beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   2424  f344				  -	      lda	DLPOINTL,x
   2425  f344				  -	      ifconst	DOUBLEBUFFER
   2426  f344				  -	      clc
   2427  f344				  -	      adc	doublebufferdloffset
   2428  f344				  -	      endif		; DOUBLEBUFFER
   2429  f344				  -	      sta	dlpnt
   2430  f344				  -	      lda	DLPOINTH,x
   2431  f344				  -	      ifconst	DOUBLEBUFFER
   2432  f344				  -	      adc	#0
   2433  f344				  -	      endif		; DOUBLEBUFFER
   2434  f344				  -	      sta	dlpnt+1
   2435  f344				  -	      iny
   2436  f344				  -	      lda	#0
   2437  f344				  -	      sta	(dlpnt),y
   2438  f344				  -	      dey
   2439  f344				  -	      tya
   2440  f344				  -	      ldy	#(DLLASTOBJ-1)
   2441  f344				  -	      sta	(dlpnt),y
   2442  f344				  -	      iny
   2443  f344				  -	      sty	dlend,x
   2444  f344				  -lockzonexreturn
   2445  f344				  -	      rts
   2446  f344					      endif		; ZONELOCKS
   2447  f344				   unlockzonex
   2448  f344				  -	      ifconst	ZONELOCKS
   2449  f344				  -	      ldy	dlend,x
   2450  f344				  -	      cpy	#DLLASTOBJ
   2451  f344				  -	      bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   2452  f344				  -	      lda	DLPOINTL,x
   2453  f344				  -	      ifconst	DOUBLEBUFFER
   2454  f344				  -	      clc
   2455  f344				  -	      adc	doublebufferdloffset
   2456  f344				  -	      endif		; DOUBLEBUFFER
   2457  f344				  -	      sta	dlpnt
   2458  f344				  -	      lda	DLPOINTH,x
   2459  f344				  -	      ifconst	DOUBLEBUFFER
   2460  f344				  -	      adc	#0
   2461  f344				  -	      endif		; DOUBLEBUFFER
   2462  f344				  -	      sta	dlpnt+1
   2463  f344				  -	      dey
   2464  f344				  -			;ldy #(DLLASTOBJ-1)
   2465  f344				  -	      lda	(dlpnt),y
   2466  f344				  -	      tay
   2467  f344				  -	      sty	dlend,x
   2468  f344				  -unlockzonexreturn
   2469  f344					      endif		; ZONELOCKS
   2470  f344		       60		      rts
   2471  f345
   2472  f345				   plotcharloop
   2473  f345							; ** read from a data indirectly pointed to from temp8,temp9
   2474  f345							; ** format is: lo_data, hi_data, palette|width, x, y
   2475  f345							; ** format ends with lo_data | hi_data = 0
   2476  f345
   2477  f345				  -	      ifconst	DOUBLEBUFFER
   2478  f345				  -	      lda	doublebufferstate
   2479  f345				  -	      bne	skipplotcharloopwait
   2480  f345					      endif		; DOUBLEBUFFER
   2481  f345				  -	      ifconst	DEBUGWAITCOLOR
   2482  f345				  -	      lda	#$61
   2483  f345				  -	      sta	BACKGRND
   2484  f345					      endif
   2485  f345				   plotcharloopwait
   2486  f345		       a5 4d		      lda	visibleover
   2487  f347		       d0 fc		      bne	plotcharloopwait
   2488  f349				  -	      ifconst	DEBUGWAITCOLOR
   2489  f349				  -	      lda	#0
   2490  f349				  -	      sta	BACKGRND
   2491  f349					      endif
   2492  f349				   skipplotcharloopwait
   2493  f349				   plotcharlooploop
   2494  f349		       a0 00		      ldy	#0
   2495  f34b		       b1 49		      lda	(temp8),y
   2496  f34d		       85 42		      sta	temp1
   2497  f34f		       c8		      iny
   2498  f350		       b1 49		      lda	(temp8),y
   2499  f352		       85 43		      sta	temp2
   2500  f354		       05 42		      ora	temp1
   2501  f356		       d0 01		      bne	plotcharloopcontinue
   2502  f358							;the pointer=0, so return
   2503  f358		       60		      rts
   2504  f359				   plotcharloopcontinue
   2505  f359		       c8		      iny
   2506  f35a		       b1 49		      lda	(temp8),y
   2507  f35c		       85 44		      sta	temp3
   2508  f35e		       c8		      iny
   2509  f35f		       b1 49		      lda	(temp8),y
   2510  f361		       85 45		      sta	temp4
   2511  f363		       c8		      iny
   2512  f364		       b1 49		      lda	(temp8),y
   2513  f366							;sta temp5 ; not needed with our late entry.
   2514  f366		       20 7f f3 	      jsr	plotcharactersskipentry
   2515  f369		       a5 49		      lda	temp8
   2516  f36b		       18		      clc
   2517  f36c		       69 05		      adc	#5
   2518  f36e		       85 49		      sta	temp8
   2519  f370		       a5 4a		      lda	temp9
   2520  f372		       69 00		      adc	#0
   2521  f374		       85 4a		      sta	temp9
   2522  f376		       4c 49 f3 	      jmp	plotcharlooploop
   2523  f379
   2524  f379				   plotcharacters
   2525  f379				  -	      ifconst	DOUBLEBUFFER
   2526  f379				  -	      lda	doublebufferstate
   2527  f379				  -	      bne	skipplotcharacterswait
   2528  f379					      endif		; DOUBLEBUFFER
   2529  f379				  -	      ifconst	DEBUGWAITCOLOR
   2530  f379				  -	      lda	#$41
   2531  f379				  -	      sta	BACKGRND
   2532  f379					      endif
   2533  f379				   plotcharacterswait
   2534  f379		       a5 4d		      lda	visibleover
   2535  f37b		       d0 fc		      bne	plotcharacterswait
   2536  f37d				  -	      ifconst	DEBUGWAITCOLOR
   2537  f37d				  -	      sta	BACKGRND
   2538  f37d					      endif
   2539  f37d				   skipplotcharacterswait
   2540  f37d							;arguments:
   2541  f37d							; temp1=lo charactermap
   2542  f37d							; temp2=hi charactermap
   2543  f37d							; temp3=palette | width byte
   2544  f37d							; temp4=x
   2545  f37d							; temp5=y
   2546  f37d
   2547  f37d		       a5 46		      lda	temp5	;Y position
   2548  f37f
   2549  f37f				   plotcharactersskipentry
   2550  f37f
   2551  f37f							;ifconst ZONEHEIGHT
   2552  f37f							; if ZONEHEIGHT = 16
   2553  f37f							; and #$0F
   2554  f37f							; endif
   2555  f37f							; if ZONEHEIGHT = 8
   2556  f37f							; and #$1F
   2557  f37f							; endif
   2558  f37f							;else
   2559  f37f							; and #$0F
   2560  f37f							;endif
   2561  f37f
   2562  f37f		       aa		      tax
   2563  f380		       bd c8 f5 	      lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   2564  f383				  -	      ifconst	DOUBLEBUFFER
   2565  f383				  -	      clc
   2566  f383				  -	      adc	doublebufferdloffset
   2567  f383					      endif		; DOUBLEBUFFER
   2568  f383		       85 63		      sta	dlpnt
   2569  f385		       bd b0 f5 	      lda	DLPOINTH,x
   2570  f388				  -	      ifconst	DOUBLEBUFFER
   2571  f388				  -	      adc	#0
   2572  f388					      endif		; DOUBLEBUFFER
   2573  f388		       85 64		      sta	dlpnt+1
   2574  f38a
   2575  f38a							;Create DL entry for the characters
   2576  f38a
   2577  f38a		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   2578  f38c
   2579  f38c				  -	      ifconst	CHECKOVERWRITE
   2580  f38c				  -	      cpy	#DLLASTOBJ
   2581  f38c				  -	      bne	continueplotcharacters
   2582  f38c				  -	      rts
   2583  f38c				  -continueplotcharacters
   2584  f38c					      endif
   2585  f38c
   2586  f38c		       a5 42		      lda	temp1	; character map data, lo byte
   2587  f38e		       91 63		      sta	(dlpnt),y	;(1) store low address
   2588  f390
   2589  f390		       c8		      iny
   2590  f391		       ad 06 21 	      lda	charactermode
   2591  f394		       91 63		      sta	(dlpnt),y	;(2) store mode
   2592  f396
   2593  f396		       c8		      iny
   2594  f397		       a5 43		      lda	temp2	; character map, hi byte
   2595  f399		       91 63		      sta	(dlpnt),y	;(3) store high address
   2596  f39b
   2597  f39b		       c8		      iny
   2598  f39c		       a5 44		      lda	temp3	;palette|width
   2599  f39e		       91 63		      sta	(dlpnt),y	;(4) store palette|width
   2600  f3a0
   2601  f3a0		       c8		      iny
   2602  f3a1		       a5 45		      lda	temp4	;Horizontal position
   2603  f3a3		       91 63		      sta	(dlpnt),y	;(5) store horizontal position
   2604  f3a5
   2605  f3a5		       c8		      iny
   2606  f3a6		       94 65		      sty	dlend,x	; save display list end byte
   2607  f3a8		       60		      rts
   2608  f3a9
   2609  f3a9
   2610  f3a9				  -	      ifconst	plotvalueonscreen
   2611  f3a9				  -plotcharacterslive
   2612  f3a9				  -			; a version of plotcharacters that draws live and minimally disrupts the screen...
   2613  f3a9				  -
   2614  f3a9				  -			;arguments:
   2615  f3a9				  -			; temp1=lo charactermap
   2616  f3a9				  -			; temp2=hi charactermap
   2617  f3a9				  -			; temp3=palette | width byte
   2618  f3a9				  -			; temp4=x
   2619  f3a9				  -			; temp5=y
   2620  f3a9				  -
   2621  f3a9				  -	      lda	temp5	;Y position
   2622  f3a9				  -
   2623  f3a9				  -	      tax
   2624  f3a9				  -	      lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   2625  f3a9				  -	      ifconst	DOUBLEBUFFER
   2626  f3a9				  -	      clc
   2627  f3a9				  -	      adc	doublebufferdloffset
   2628  f3a9				  -	      endif		; DOUBLEBUFFER
   2629  f3a9				  -	      sta	dlpnt
   2630  f3a9				  -	      lda	DLPOINTH,x
   2631  f3a9				  -	      ifconst	DOUBLEBUFFER
   2632  f3a9				  -	      adc	#0
   2633  f3a9				  -	      endif		; DOUBLEBUFFER
   2634  f3a9				  -	      sta	dlpnt+1
   2635  f3a9				  -
   2636  f3a9				  -			;Create DL entry for the characters
   2637  f3a9				  -
   2638  f3a9				  -	      ldy	dlend,x	;Get the index to the end of this DL
   2639  f3a9				  -
   2640  f3a9				  -	      ifconst	CHECKOVERWRITE
   2641  f3a9				  -	      cpy	#DLLASTOBJ
   2642  f3a9				  -	      bne	continueplotcharacterslive
   2643  f3a9				  -	      rts
   2644  f3a9				  -continueplotcharacterslive
   2645  f3a9				  -	      endif
   2646  f3a9				  -
   2647  f3a9				  -	      lda	temp1	; character map data, lo byte
   2648  f3a9				  -	      sta	(dlpnt),y	;(1) store low address
   2649  f3a9				  -
   2650  f3a9				  -	      iny
   2651  f3a9				  -			; we don't add the second byte yet, since the charmap could briefly
   2652  f3a9				  -			; render without a proper character map address, width, or position.
   2653  f3a9				  -	      lda	charactermode
   2654  f3a9				  -	      sta	(dlpnt),y	;(2) store mode
   2655  f3a9				  -
   2656  f3a9				  -	      iny
   2657  f3a9				  -	      lda	temp2	; character map, hi byte
   2658  f3a9				  -	      sta	(dlpnt),y	;(3) store high address
   2659  f3a9				  -
   2660  f3a9				  -	      iny
   2661  f3a9				  -	      lda	temp3	;palette|width
   2662  f3a9				  -	      sta	(dlpnt),y	;(4) store palette|width
   2663  f3a9				  -
   2664  f3a9				  -	      iny
   2665  f3a9				  -	      lda	temp4	;Horizontal position
   2666  f3a9				  -	      sta	(dlpnt),y	;(5) store horizontal position
   2667  f3a9				  -
   2668  f3a9				  -	      iny
   2669  f3a9				  -	      sty	dlend,x	; save display list end byte
   2670  f3a9				  -
   2671  f3a9				  -	      rts
   2672  f3a9					      endif		;plotcharacterslive
   2673  f3a9
   2674  f3a9				  -	      ifconst	USED_PLOTVALUE
   2675  f3a9				  -plotvalue
   2676  f3a9				  -			; calling 7800basic command:
   2677  f3a9				  -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   2678  f3a9				  -			; ...displays the variable as BCD digits
   2679  f3a9				  -			;
   2680  f3a9				  -			; asm sub arguments:
   2681  f3a9				  -			; temp1=lo charactermap
   2682  f3a9				  -			; temp2=hi charactermap
   2683  f3a9				  -			; temp3=palette | width byte
   2684  f3a9				  -			; temp4=x
   2685  f3a9				  -			; temp5=y
   2686  f3a9				  -			; temp6=number of digits
   2687  f3a9				  -			; temp7=lo variable
   2688  f3a9				  -			; temp8=hi variable
   2689  f3a9				  -			; temp9=character mode
   2690  f3a9				  -
   2691  f3a9				  -plotdigitcount =	temp6
   2692  f3a9				  -
   2693  f3a9				  -	      ifconst	ZONELOCKS
   2694  f3a9				  -	      ldx	temp5
   2695  f3a9				  -	      ldy	dlend,x
   2696  f3a9				  -	      cpy	#DLLASTOBJ
   2697  f3a9				  -	      bne	carryonplotvalue
   2698  f3a9				  -	      rts
   2699  f3a9				  -carryonplotvalue
   2700  f3a9				  -	      endif
   2701  f3a9				  -
   2702  f3a9				  -	      lda	#0
   2703  f3a9				  -	      tay
   2704  f3a9				  -	      ldx	valbufend
   2705  f3a9				  -
   2706  f3a9				  -	      lda	plotdigitcount
   2707  f3a9				  -	      and	#1
   2708  f3a9				  -	      beq	pvnibble2char
   2709  f3a9				  -	      lda	#0
   2710  f3a9				  -	      sta	VALBUFFER,x	; just in case we skip this digit
   2711  f3a9				  -	      beq	pvnibble2char_skipnibble
   2712  f3a9				  -
   2713  f3a9				  -pvnibble2char
   2714  f3a9				  -			; high nibble...
   2715  f3a9				  -	      lda	(temp7),y
   2716  f3a9				  -	      and	#$f0
   2717  f3a9				  -	      lsr
   2718  f3a9				  -	      lsr
   2719  f3a9				  -	      lsr
   2720  f3a9				  -	      ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   2721  f3a9				  -	      lsr
   2722  f3a9				  -	      endif
   2723  f3a9				  -
   2724  f3a9				  -	      clc
   2725  f3a9				  -	      adc	temp1	; add the offset to character graphics to our value
   2726  f3a9				  -	      sta	VALBUFFER,x
   2727  f3a9				  -	      inx
   2728  f3a9				  -	      dec	plotdigitcount
   2729  f3a9				  -
   2730  f3a9				  -pvnibble2char_skipnibble
   2731  f3a9				  -			; low nibble...
   2732  f3a9				  -	      lda	(temp7),y
   2733  f3a9				  -	      and	#$0f
   2734  f3a9				  -	      ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   2735  f3a9				  -	      asl
   2736  f3a9				  -	      endif
   2737  f3a9				  -	      clc
   2738  f3a9				  -	      adc	temp1	; add the offset to character graphics to our value
   2739  f3a9				  -	      sta	VALBUFFER,x
   2740  f3a9				  -	      inx
   2741  f3a9				  -	      iny
   2742  f3a9				  -
   2743  f3a9				  -	      dec	plotdigitcount
   2744  f3a9				  -	      bne	pvnibble2char
   2745  f3a9				  -
   2746  f3a9				  -			;point to the start of our valuebuffer
   2747  f3a9				  -	      clc
   2748  f3a9				  -	      lda	#<VALBUFFER
   2749  f3a9				  -	      adc	valbufend
   2750  f3a9				  -	      sta	temp1
   2751  f3a9				  -	      lda	#>VALBUFFER
   2752  f3a9				  -	      adc	#0
   2753  f3a9				  -	      sta	temp2
   2754  f3a9				  -
   2755  f3a9				  -			;advance valbufend to the end of our value buffer
   2756  f3a9				  -	      stx	valbufend
   2757  f3a9				  -
   2758  f3a9				  -	      ifnconst	plotvalueonscreen
   2759  f3a9				  -	      jmp	plotcharacters
   2760  f3a9				  -	      else
   2761  f3a9				  -	      jmp	plotcharacterslive
   2762  f3a9				  -	      endif
   2763  f3a9				  -
   2764  f3a9					      endif		; USED_PLOTVALUE
   2765  f3a9
   2766  f3a9
   2767  f3a9				  -	      ifconst	USED_PLOTVALUEEXTRA
   2768  f3a9				  -plotdigitcount =	temp6
   2769  f3a9				  -plotvalueextra
   2770  f3a9				  -			; calling 7800basic command:
   2771  f3a9				  -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   2772  f3a9				  -			; ...displays the variable as BCD digits
   2773  f3a9				  -			;
   2774  f3a9				  -			; asm sub arguments:
   2775  f3a9				  -			; temp1=lo charactermap
   2776  f3a9				  -			; temp2=hi charactermap
   2777  f3a9				  -			; temp3=palette | width byte
   2778  f3a9				  -			; temp4=x
   2779  f3a9				  -			; temp5=y
   2780  f3a9				  -			; temp6=number of digits
   2781  f3a9				  -			; temp7=lo variable
   2782  f3a9				  -			; temp8=hi variable
   2783  f3a9				  -
   2784  f3a9				  -	      lda	#0
   2785  f3a9				  -	      tay
   2786  f3a9				  -	      ldx	valbufend
   2787  f3a9				  -	      ifnconst	plotvalueonscreen
   2788  f3a9				  -	      sta	VALBUFFER,x
   2789  f3a9				  -	      endif
   2790  f3a9				  -
   2791  f3a9				  -	      lda	plotdigitcount
   2792  f3a9				  -	      and	#1
   2793  f3a9				  -
   2794  f3a9				  -	      bne	pvnibble2char_skipnibbleextra
   2795  f3a9				  -
   2796  f3a9				  -pvnibble2charextra
   2797  f3a9				  -			; high nibble...
   2798  f3a9				  -	      lda	(temp7),y
   2799  f3a9				  -	      and	#$f0
   2800  f3a9				  -	      lsr
   2801  f3a9				  -	      lsr
   2802  f3a9				  -	      ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   2803  f3a9				  -	      lsr
   2804  f3a9				  -	      endif
   2805  f3a9				  -	      clc
   2806  f3a9				  -	      adc	temp1	; add the offset to character graphics to our value
   2807  f3a9				  -	      sta	VALBUFFER,x
   2808  f3a9				  -	      inx
   2809  f3a9				  -
   2810  f3a9				  -			; second half of the digit
   2811  f3a9				  -	      clc
   2812  f3a9				  -	      adc	#1
   2813  f3a9				  -	      sta	VALBUFFER,x
   2814  f3a9				  -	      inx
   2815  f3a9				  -
   2816  f3a9				  -pvnibble2char_skipnibbleextra
   2817  f3a9				  -			; low nibble...
   2818  f3a9				  -	      lda	(temp7),y
   2819  f3a9				  -	      and	#$0f
   2820  f3a9				  -	      ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   2821  f3a9				  -	      asl
   2822  f3a9				  -	      endif
   2823  f3a9				  -	      asl
   2824  f3a9				  -
   2825  f3a9				  -	      clc
   2826  f3a9				  -	      adc	temp1	; add the offset to character graphics to our value
   2827  f3a9				  -	      sta	VALBUFFER,x
   2828  f3a9				  -	      inx
   2829  f3a9				  -
   2830  f3a9				  -	      clc
   2831  f3a9				  -	      adc	#1
   2832  f3a9				  -	      sta	VALBUFFER,x
   2833  f3a9				  -	      inx
   2834  f3a9				  -	      iny
   2835  f3a9				  -
   2836  f3a9				  -	      dec	plotdigitcount
   2837  f3a9				  -	      bne	pvnibble2charextra
   2838  f3a9				  -
   2839  f3a9				  -			;point to the start of our valuebuffer
   2840  f3a9				  -	      clc
   2841  f3a9				  -	      lda	#<VALBUFFER
   2842  f3a9				  -	      adc	valbufend
   2843  f3a9				  -	      sta	temp1
   2844  f3a9				  -	      lda	#>VALBUFFER
   2845  f3a9				  -	      adc	#0
   2846  f3a9				  -	      sta	temp2
   2847  f3a9				  -
   2848  f3a9				  -			;advance valbufend to the end of our value buffer
   2849  f3a9				  -	      stx	valbufend
   2850  f3a9				  -
   2851  f3a9				  -	      ifnconst	plotvalueonscreen
   2852  f3a9				  -	      jmp	plotcharacters
   2853  f3a9				  -	      else
   2854  f3a9				  -	      jmp	plotcharacterslive
   2855  f3a9				  -	      endif
   2856  f3a9					      endif		; USED_PLOTVALUEEXTRA
   2857  f3a9
   2858  f3a9				   boxcollision
   2859  f3a9				  -	      ifconst	BOXCOLLISION
   2860  f3a9				  -			; the worst case cycle-time for the code below is 43 cycles.
   2861  f3a9				  -			; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   2862  f3a9				  -
   2863  f3a9				  -			;__boxx1 = accumulator
   2864  f3a9				  -			;__boxy1 = y
   2865  f3a9				  -__boxw1    =	temp3
   2866  f3a9				  -__boxh1    =	temp4
   2867  f3a9				  -
   2868  f3a9				  -__boxx2    =	temp5
   2869  f3a9				  -__boxy2    =	temp6
   2870  f3a9				  -__boxw2    =	temp7
   2871  f3a9				  -__boxh2    =	temp8
   2872  f3a9				  -
   2873  f3a9				  -DoXCollisionCheck
   2874  f3a9				  -			;lda __boxx1 ; skipped. already in the accumulator
   2875  f3a9				  -	      cmp	__boxx2	;3
   2876  f3a9				  -	      bcs	X1isbiggerthanX2	;2/3
   2877  f3a9				  -X2isbiggerthanX1
   2878  f3a9				  -			; carry is clear
   2879  f3a9				  -	      adc	__boxw1	;3
   2880  f3a9				  -	      cmp	__boxx2	;3
   2881  f3a9				  -	      bcs	DoYCollisionCheck	;3/2
   2882  f3a9				  -	      rts		;6 - carry clear, no collision
   2883  f3a9				  -X1isbiggerthanX2
   2884  f3a9				  -	      clc		;2
   2885  f3a9				  -	      sbc	__boxw2	;3
   2886  f3a9				  -	      cmp	__boxx2	;3
   2887  f3a9				  -	      bcs	noboxcollision	;3/2
   2888  f3a9				  -DoYCollisionCheck
   2889  f3a9				  -	      tya		; 2 ; use to be "lda __boxy1"
   2890  f3a9				  -	      cmp	__boxy2	;3
   2891  f3a9				  -	      bcs	Y1isbiggerthanY2	;3/2
   2892  f3a9				  -Y2isbiggerthanY1
   2893  f3a9				  -			; carry is clear
   2894  f3a9				  -	      adc	__boxh1	;3
   2895  f3a9				  -	      cmp	__boxy2	;3
   2896  f3a9				  -	      rts		;6
   2897  f3a9				  -Y1isbiggerthanY2
   2898  f3a9				  -	      clc		;2
   2899  f3a9				  -	      sbc	__boxh2	;3
   2900  f3a9				  -	      cmp	__boxy2	;3
   2901  f3a9				  -	      bcs	noboxcollision	;3/2
   2902  f3a9				  -yesboxcollision
   2903  f3a9				  -	      sec		;2
   2904  f3a9				  -	      rts		;6
   2905  f3a9				  -noboxcollision
   2906  f3a9				  -	      clc		;2
   2907  f3a9				  -	      rts		;6
   2908  f3a9					      endif		; BOXCOLLISION
   2909  f3a9
   2910  f3a9				   randomize
   2911  f3a9		       a5 40		      lda	rand
   2912  f3ab		       4a		      lsr
   2913  f3ac		       26 41		      rol	rand16
   2914  f3ae		       90 02		      bcc	noeor
   2915  f3b0		       49 b4		      eor	#$B4
   2916  f3b2				   noeor
   2917  f3b2		       85 40		      sta	rand
   2918  f3b4		       45 41		      eor	rand16
   2919  f3b6		       60		      rts
   2920  f3b7
   2921  f3b7							; *** bcd conversion routine courtesy Omegamatrix
   2922  f3b7							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   2923  f3b7				   converttobcd
   2924  f3b7							;value to convert is in the accumulator
   2925  f3b7		       85 42		      sta	temp1
   2926  f3b9		       4a		      lsr
   2927  f3ba		       65 42		      adc	temp1
   2928  f3bc		       6a		      ror
   2929  f3bd		       4a		      lsr
   2930  f3be		       4a		      lsr
   2931  f3bf		       65 42		      adc	temp1
   2932  f3c1		       6a		      ror
   2933  f3c2		       65 42		      adc	temp1
   2934  f3c4		       6a		      ror
   2935  f3c5		       4a		      lsr
   2936  f3c6		       29 3c		      and	#$3C
   2937  f3c8		       85 43		      sta	temp2
   2938  f3ca		       4a		      lsr
   2939  f3cb		       65 43		      adc	temp2
   2940  f3cd		       65 42		      adc	temp1
   2941  f3cf		       60		      rts		; return the result in the accumulator
   2942  f3d0
   2943  f3d0							; Y and A contain multiplicands, result in A
   2944  f3d0				   mul8
   2945  f3d0		       84 42		      sty	temp1
   2946  f3d2		       85 43		      sta	temp2
   2947  f3d4		       a9 00		      lda	#0
   2948  f3d6				   reptmul8
   2949  f3d6		       46 43		      lsr	temp2
   2950  f3d8		       90 03		      bcc	skipmul8
   2951  f3da		       18		      clc
   2952  f3db		       65 42		      adc	temp1
   2953  f3dd							;bcs donemul8 might save cycles?
   2954  f3dd				   skipmul8
   2955  f3dd							;beq donemul8 might save cycles?
   2956  f3dd		       06 42		      asl	temp1
   2957  f3df		       d0 f5		      bne	reptmul8
   2958  f3e1				   donemul8
   2959  f3e1		       60		      rts
   2960  f3e2
   2961  f3e2				   div8
   2962  f3e2							; A=numerator Y=denominator, result in A
   2963  f3e2		       c0 02		      cpy	#2
   2964  f3e4		       90 0a		      bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   2965  f3e6		       84 42		      sty	temp1
   2966  f3e8		       a0 ff		      ldy	#$ff
   2967  f3ea				   div8loop
   2968  f3ea		       e5 42		      sbc	temp1
   2969  f3ec		       c8		      iny
   2970  f3ed		       b0 fb		      bcs	div8loop
   2971  f3ef				   div8end
   2972  f3ef		       98		      tya
   2973  f3f0							; result in A
   2974  f3f0		       60		      rts
   2975  f3f1
   2976  f3f1							; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   2977  f3f1				   mul16
   2978  f3f1		       84 42		      sty	temp1
   2979  f3f3		       85 43		      sta	temp2
   2980  f3f5
   2981  f3f5		       a9 00		      lda	#0
   2982  f3f7		       a2 08		      ldx	#8
   2983  f3f9		       46 42		      lsr	temp1
   2984  f3fb				   mul16_1
   2985  f3fb		       90 03		      bcc	mul16_2
   2986  f3fd		       18		      clc
   2987  f3fe		       65 43		      adc	temp2
   2988  f400				   mul16_2
   2989  f400		       6a		      ror
   2990  f401		       66 42		      ror	temp1
   2991  f403		       ca		      dex
   2992  f404		       d0 f5		      bne	mul16_1
   2993  f406		       85 43		      sta	temp2
   2994  f408		       60		      rts
   2995  f409
   2996  f409							; div int/int
   2997  f409							; numerator in A, denom in temp1
   2998  f409							; returns with quotient in A, remainder in temp1
   2999  f409				   div16
   3000  f409		       85 43		      sta	temp2
   3001  f40b		       84 42		      sty	temp1
   3002  f40d		       a9 00		      lda	#0
   3003  f40f		       a2 08		      ldx	#8
   3004  f411		       06 43		      asl	temp2
   3005  f413				   div16_1
   3006  f413		       2a		      rol
   3007  f414		       c5 42		      cmp	temp1
   3008  f416		       90 02		      bcc	div16_2
   3009  f418		       e5 42		      sbc	temp1
   3010  f41a				   div16_2
   3011  f41a		       26 43		      rol	temp2
   3012  f41c		       ca		      dex
   3013  f41d		       d0 f4		      bne	div16_1
   3014  f41f		       85 42		      sta	temp1
   3015  f421		       a5 43		      lda	temp2
   3016  f423		       60		      rts
   3017  f424
   3018  f424				  -	      ifconst	bankswitchmode
   3019  f424				  -BS_jsr
   3020  f424				  -	      ifconst	dumpbankswitch
   3021  f424				  -	      sta	dumpbankswitch
   3022  f424				  -	      endif
   3023  f424				  -	      ifconst	MCPDEVCART
   3024  f424				  -	      ora	#$18
   3025  f424				  -	      sta	$3000
   3026  f424				  -	      else
   3027  f424				  -	      sta	$8000
   3028  f424				  -	      endif
   3029  f424				  -	      pla
   3030  f424				  -	      tax
   3031  f424				  -	      pla
   3032  f424				  -	      rts
   3033  f424				  -
   3034  f424				  -BS_return
   3035  f424				  -	      pla		; bankswitch bank
   3036  f424				  -	      ifconst	dumpbankswitch
   3037  f424				  -	      sta	dumpbankswitch
   3038  f424				  -	      endif
   3039  f424				  -	      ifconst	BANKRAM
   3040  f424				  -	      sta	currentbank
   3041  f424				  -	      ora	currentrambank
   3042  f424				  -	      endif
   3043  f424				  -	      ifconst	MCPDEVCART
   3044  f424				  -	      ora	#$18
   3045  f424				  -	      sta	$3000
   3046  f424				  -	      else
   3047  f424				  -	      sta	$8000
   3048  f424				  -	      endif
   3049  f424				  -	      pla		; bankswitch $0 flag
   3050  f424				  -	      rts
   3051  f424					      endif
   3052  f424
   3053  f424				   checkselectswitch
   3054  f424		       ad 82 02 	      lda	SWCHB	; first check the real select switch...
   3055  f427		       29 02		      and	#%00000010
   3056  f429					      ifnconst	SOFTPAUSEOFF
   3057  f429					      ifnconst	MOUSESUPPORT
   3058  f429					      ifnconst	TRAKBALLSUPPORT
   3059  f429		       f0 0f		      beq	checkselectswitchreturn	; switch is pressed
   3060  f42b		       ad b7 01 	      lda	port0control
   3061  f42e		       c9 0b		      cmp	#11
   3062  f430		       d0 03		      bne	checkselectsoftswitch
   3063  f432		       a9 ff		      lda	#$ff
   3064  f434		       60		      rts
   3065  f435				   checkselectsoftswitch
   3066  f435		       ad 80 02 	      lda	SWCHA	; then check the soft "select" joysick code...
   3067  f438		       29 b0		      and	#%10110000	; R_DU
   3068  f43a					      endif		; TRAKBALLSUPPORT
   3069  f43a					      endif		; MOUSESUPPORT
   3070  f43a					      endif		; SOFTPAUSEOFF
   3071  f43a				   checkselectswitchreturn
   3072  f43a		       60		      rts
   3073  f43b
   3074  f43b				   checkresetswitch
   3075  f43b		       ad 82 02 	      lda	SWCHB	; first check the real reset switch...
   3076  f43e		       29 01		      and	#%00000001
   3077  f440					      ifnconst	SOFTPAUSEOFF
   3078  f440					      ifnconst	MOUSESUPPORT
   3079  f440					      ifnconst	TRAKBALLSUPPORT
   3080  f440		       f0 0f		      beq	checkresetswitchreturn	; switch is pressed
   3081  f442		       ad b7 01 	      lda	port0control
   3082  f445		       c9 0b		      cmp	#11
   3083  f447		       d0 03		      bne	checkresetsoftswitch
   3084  f449		       a9 ff		      lda	#$ff
   3085  f44b		       60		      rts
   3086  f44c				   checkresetsoftswitch
   3087  f44c		       ad 80 02 	      lda	SWCHA	; then check the soft "reset" joysick code...
   3088  f44f		       29 70		      and	#%01110000	; _LDU
   3089  f451					      endif		; TRAKBALLSUPPORT
   3090  f451					      endif		; MOUSESUPPORT
   3091  f451					      endif		; SOFTPAUSEOFF
   3092  f451				   checkresetswitchreturn
   3093  f451		       60		      rts
   3094  f452
   3095  f452				  -	      ifconst	FINESCROLLENABLED
   3096  f452				  -finescrolldlls
   3097  f452				  -	      ldx	temp1	; first DLL index x3
   3098  f452				  -	      lda	DLLMEM,x
   3099  f452				  -	      and	#%11110000
   3100  f452				  -	      ora	finescrolly
   3101  f452				  -	      sta	DLLMEM,x
   3102  f452				  -
   3103  f452				  -	      ldx	temp2	; last DLL index x3
   3104  f452				  -	      lda	DLLMEM,x
   3105  f452				  -	      and	#%11110000
   3106  f452				  -	      ora	finescrolly
   3107  f452				  -	      eor	#(WZONEHEIGHT-1)
   3108  f452				  -	      sta	DLLMEM,x
   3109  f452				  -	      rts
   3110  f452					      endif		; FINESCROLLENABLED
   3111  f452
   3112  f452				  -	      ifconst	USED_ADJUSTVISIBLE
   3113  f452				  -adjustvisible
   3114  f452				  -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   3115  f452				  -	      jsr	waitforvblankstart	; ensure vblank just started
   3116  f452				  -	      ldx	visibleDLLstart
   3117  f452				  -findfirstinterrupt
   3118  f452				  -	      lda	DLLMEM,x
   3119  f452				  -	      bmi	foundfirstinterrupt
   3120  f452				  -	      inx
   3121  f452				  -	      inx
   3122  f452				  -	      inx
   3123  f452				  -	      bne	findfirstinterrupt
   3124  f452				  -foundfirstinterrupt
   3125  f452				  -	      and	#%01111111	; clear the interrupt bit
   3126  f452				  -	      sta	DLLMEM,x
   3127  f452				  -	      ifconst	DOUBLEBUFFER
   3128  f452				  -	      sta	DLLMEM+DBOFFSET,x
   3129  f452				  -	      endif		; DOUBLEBUFFER
   3130  f452				  -	      ldx	overscanDLLstart
   3131  f452				  -findlastinterrupt
   3132  f452				  -	      lda	DLLMEM,x
   3133  f452				  -	      bmi	foundlastinterrupt
   3134  f452				  -	      dex
   3135  f452				  -	      dex
   3136  f452				  -	      dex
   3137  f452				  -	      bne	findlastinterrupt
   3138  f452				  -foundlastinterrupt
   3139  f452				  -	      and	#%01111111	; clear the interrupt bit
   3140  f452				  -	      sta	DLLMEM,x
   3141  f452				  -	      ifconst	DOUBLEBUFFER
   3142  f452				  -	      sta	DLLMEM+DBOFFSET,x
   3143  f452				  -	      endif		; DOUBLEBUFFER
   3144  f452				  -			;now we need to set the new interrupts
   3145  f452				  -	      clc
   3146  f452				  -	      lda	temp1
   3147  f452				  -	      adc	visibleDLLstart
   3148  f452				  -	      tax
   3149  f452				  -	      lda	DLLMEM,x
   3150  f452				  -	      ora	#%10000000
   3151  f452				  -	      sta	DLLMEM,x
   3152  f452				  -	      ifconst	DOUBLEBUFFER
   3153  f452				  -	      sta	DLLMEM+DBOFFSET,x
   3154  f452				  -	      endif		; DOUBLEBUFFER
   3155  f452				  -	      clc
   3156  f452				  -	      lda	temp2
   3157  f452				  -	      adc	visibleDLLstart
   3158  f452				  -	      tax
   3159  f452				  -	      lda	DLLMEM,x
   3160  f452				  -	      ora	#%10000000
   3161  f452				  -	      sta	DLLMEM,x
   3162  f452				  -	      ifconst	DOUBLEBUFFER
   3163  f452				  -	      sta	DLLMEM+DBOFFSET,x
   3164  f452				  -	      endif		; DOUBLEBUFFER
   3165  f452				  -	      jsr	vblankresync
   3166  f452				  -	      rts
   3167  f452					      endif		; USED_ADJUSTVISIBLE
   3168  f452
   3169  f452				   vblankresync
   3170  f452		       20 f0 f4 	      jsr	waitforvblankstart	; ensure vblank just started
   3171  f455		       a9 00		      lda	#0
   3172  f457		       85 4d		      sta	visibleover
   3173  f459		       a9 03		      lda	#3
   3174  f45b		       8d b2 01 	      sta	interruptindex
   3175  f45e		       60		      rts
   3176  f45f
   3177  f45f				   createallgamedlls
   3178  f45f		       a2 00		      ldx	#0
   3179  f461		       a9 19		      lda	#NVLINES
   3180  f463		       ac 09 21 	      ldy	paldetected
   3181  f466		       f0 03		      beq	skipcreatePALpadding
   3182  f468		       18		      clc
   3183  f469		       69 15		      adc	#21
   3184  f46b				   skipcreatePALpadding
   3185  f46b		       20 a0 f4 	      jsr	createnonvisibledlls
   3186  f46e		       8e 3c 21 	      stx	visibleDLLstart
   3187  f471		       20 d1 f4 	      jsr	createvisiblezones
   3188  f474		       8e 3d 21 	      stx	overscanDLLstart
   3189  f477				   createallgamedllscontinue
   3190  f477		       a9 50		      lda	#(NVLINES+55)	; extras for PAL
   3191  f479		       20 a0 f4 	      jsr	createnonvisibledlls
   3192  f47c
   3193  f47c		       ae 3c 21 	      ldx	visibleDLLstart
   3194  f47f		       bd 00 18 	      lda	DLLMEM,x
   3195  f482		       09 80		      ora	#%10000000	; NMI 1 - start of visible screen
   3196  f484		       9d 00 18 	      sta	DLLMEM,x
   3197  f487				  -	      ifconst	DOUBLEBUFFER
   3198  f487				  -	      sta	DLLMEM+DBOFFSET,x
   3199  f487					      endif		; DOUBLEBUFFER
   3200  f487
   3201  f487		       ae 3d 21 	      ldx	overscanDLLstart
   3202  f48a		       bd 00 18 	      lda	DLLMEM,x
   3203  f48d		       09 83		      ora	#%10000011	; NMI 2 - end of visible screen
   3204  f48f		       29 f3		      and	#%11110011	; change this to a 1-line DLL, so there's time enough for the "deeper overscan" DLL
   3205  f491		       9d 00 18 	      sta	DLLMEM,x
   3206  f494				  -	      ifconst	DOUBLEBUFFER
   3207  f494				  -	      sta	DLLMEM+DBOFFSET,x
   3208  f494					      endif		; DOUBLEBUFFER
   3209  f494
   3210  f494		       e8		      inx
   3211  f495		       e8		      inx
   3212  f496		       e8		      inx
   3213  f497
   3214  f497		       bd 00 18 	      lda	DLLMEM,x
   3215  f49a		       09 80		      ora	#%10000000	; NMI 3 - deeper overscan
   3216  f49c		       9d 00 18 	      sta	DLLMEM,x
   3217  f49f				  -	      ifconst	DOUBLEBUFFER
   3218  f49f				  -	      sta	DLLMEM+DBOFFSET,x
   3219  f49f					      endif		; DOUBLEBUFFER
   3220  f49f
   3221  f49f		       60		      rts
   3222  f4a0
   3223  f4a0				   createnonvisibledlls
   3224  f4a0		       85 42		      sta	temp1
   3225  f4a2		       4a		      lsr
   3226  f4a3		       4a		      lsr
   3227  f4a4		       4a		      lsr
   3228  f4a5		       4a		      lsr		; /16
   3229  f4a6		       f0 09		      beq	skipcreatenonvisibledlls1loop
   3230  f4a8		       a8		      tay
   3231  f4a9				   createnonvisibledlls1loop
   3232  f4a9		       a9 4f		      lda	#%01001111	;low nibble=16 lines, high nibble=Holey DMA
   3233  f4ab		       20 c0 f4 	      jsr	createblankdllentry
   3234  f4ae		       88		      dey
   3235  f4af		       d0 f8		      bne	createnonvisibledlls1loop
   3236  f4b1				   skipcreatenonvisibledlls1loop
   3237  f4b1		       a5 42		      lda	temp1
   3238  f4b3		       29 0f		      and	#%00001111
   3239  f4b5		       f0 08		      beq	createnonvisibledllsreturn
   3240  f4b7		       38		      sec
   3241  f4b8		       e9 01		      sbc	#1
   3242  f4ba		       09 40		      ora	#%01000000
   3243  f4bc		       20 c0 f4 	      jsr	createblankdllentry
   3244  f4bf				   createnonvisibledllsreturn
   3245  f4bf		       60		      rts
   3246  f4c0
   3247  f4c0				   createblankdllentry
   3248  f4c0		       9d 00 18 	      sta	DLLMEM,x
   3249  f4c3				  -	      ifconst	DOUBLEBUFFER
   3250  f4c3				  -	      sta	DLLMEM+DBOFFSET,x
   3251  f4c3					      endif		; DOUBLEBUFFER
   3252  f4c3		       e8		      inx
   3253  f4c4		       a9 21		      lda	#$21	; blank
   3254  f4c6		       9d 00 18 	      sta	DLLMEM,x
   3255  f4c9				  -	      ifconst	DOUBLEBUFFER
   3256  f4c9				  -	      sta	DLLMEM+DBOFFSET,x
   3257  f4c9					      endif		; DOUBLEBUFFER
   3258  f4c9		       e8		      inx
   3259  f4ca		       a9 00		      lda	#$00
   3260  f4cc		       9d 00 18 	      sta	DLLMEM,x
   3261  f4cf				  -	      ifconst	DOUBLEBUFFER
   3262  f4cf				  -	      sta	DLLMEM+DBOFFSET,x
   3263  f4cf					      endif		; DOUBLEBUFFER
   3264  f4cf		       e8		      inx
   3265  f4d0		       60		      rts
   3266  f4d1
   3267  f4d1				   createvisiblezones
   3268  f4d1		       a0 00		      ldy	#0
   3269  f4d3				   createvisiblezonesloop
   3270  f4d3		       b9 e0 f5 	      lda.w	DLHEIGHT,y
   3271  f4d6		       09 20		      ora	#(WZONEHEIGHT * 4)	; set Holey DMA for 8 or 16 tall zones
   3272  f4d8		       9d 00 18 	      sta	DLLMEM,x
   3273  f4db				  -	      ifconst	DOUBLEBUFFER
   3274  f4db				  -	      sta	DLLMEM+DBOFFSET,x
   3275  f4db					      endif		; DOUBLEBUFFER
   3276  f4db		       e8		      inx
   3277  f4dc		       b9 b0 f5 	      lda	DLPOINTH,y
   3278  f4df				  -	      ifconst	BANKSET_DL_IN_CARTRAM
   3279  f4df				  -			; with bankset cart ram, we added $8000 to the DL address so plot functions would hit the write-address
   3280  f4df				  -			; but now we need to subtract that $8000 location to give Maria the normal address
   3281  f4df				  -	      sec
   3282  f4df				  -	      sbc	#$80
   3283  f4df					      endif		; BANKSET_DL_IN_CARTRAM
   3284  f4df		       9d 00 18 	      sta	DLLMEM,x
   3285  f4e2				  -	      ifconst	DOUBLEBUFFER
   3286  f4e2				  -	      sta	DLLMEM+DBOFFSET,x
   3287  f4e2					      endif		; DOUBLEBUFFER
   3288  f4e2		       e8		      inx
   3289  f4e3		       b9 c8 f5 	      lda	DLPOINTL,y
   3290  f4e6		       9d 00 18 	      sta	DLLMEM,x
   3291  f4e9				  -	      ifconst	DOUBLEBUFFER
   3292  f4e9				  -	      clc
   3293  f4e9				  -	      adc	#DOUBLEBUFFEROFFSET
   3294  f4e9				  -	      sta	DLLMEM+DBOFFSET,x
   3295  f4e9				  -	      bcc	skiphidoublebufferadjust	; dlls are big endian, so we need to fix the hi byte after-the-fact...
   3296  f4e9				  -	      inc	DLLMEM+DBOFFSET-1,x
   3297  f4e9				  -skiphidoublebufferadjust
   3298  f4e9					      endif		; DOUBLEBUFFER
   3299  f4e9		       e8		      inx
   3300  f4ea		       c8		      iny
   3301  f4eb		       c0 18		      cpy	#WZONECOUNT
   3302  f4ed		       d0 e4		      bne	createvisiblezonesloop
   3303  f4ef		       60		      rts
   3304  f4f0
   3305  f4f0				   waitforvblankstart
   3306  f4f0				   vblankendwait
   3307  f4f0		       24 28		      BIT	MSTAT
   3308  f4f2		       30 fc		      bmi	vblankendwait
   3309  f4f4				   vblankstartwait
   3310  f4f4		       24 28		      BIT	MSTAT
   3311  f4f6		       10 fc		      bpl	vblankstartwait
   3312  f4f8		       60		      rts
   3313  f4f9
   3314  f4f9				  -	      ifconst	DOUBLEBUFFER
   3315  f4f9				  -flipdisplaybufferreturn
   3316  f4f9				  -	      rts
   3317  f4f9				  -flipdisplaybuffer
   3318  f4f9				  -	      ifconst	interrupthold
   3319  f4f9				  -	      lda	#$FF
   3320  f4f9				  -	      sta	interrupthold
   3321  f4f9				  -	      endif
   3322  f4f9				  -	      lda	doublebufferstate
   3323  f4f9				  -	      beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   3324  f4f9				  -
   3325  f4f9				  -	      jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   3326  f4f9				  -
   3327  f4f9				  -	      lda	doublebufferstate
   3328  f4f9				  -	      lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   3329  f4f9				  -	      tax
   3330  f4f9				  -
   3331  f4f9				  -			; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   3332  f4f9				  -
   3333  f4f9				  -flipdisplaybufferwait1
   3334  f4f9				  -	      lda	visibleover
   3335  f4f9				  -	      beq	flipdisplaybufferwait1
   3336  f4f9				  -
   3337  f4f9				  -flipdisplaybufferwait
   3338  f4f9				  -	      lda	visibleover
   3339  f4f9				  -	      bne	flipdisplaybufferwait
   3340  f4f9				  -
   3341  f4f9				  -	      lda	doublebufferminimumframetarget
   3342  f4f9				  -	      beq	skipminimumframecode
   3343  f4f9				  -	      lda	doublebufferminimumframeindex
   3344  f4f9				  -	      bne	flipdisplaybufferwait1
   3345  f4f9				  -	      lda	doublebufferminimumframetarget
   3346  f4f9				  -	      sta	doublebufferminimumframeindex
   3347  f4f9				  -skipminimumframecode
   3348  f4f9				  -
   3349  f4f9				  -	      lda	DLLMEMLutHi,x
   3350  f4f9				  -	      sta	DPPH
   3351  f4f9				  -	      lda	DLLMEMLutLo,x
   3352  f4f9				  -	      sta	DPPL
   3353  f4f9				  -
   3354  f4f9				  -	      lda	NewPageflipstate,x
   3355  f4f9				  -	      sta	doublebufferstate
   3356  f4f9				  -	      lda	NewPageflipoffset,x
   3357  f4f9				  -	      sta	doublebufferdloffset
   3358  f4f9				  -
   3359  f4f9				  -	      ifnconst	BANKSET_DL_IN_CARTRAM
   3360  f4f9				  -	      lda	doublebufferbufferdirty
   3361  f4f9				  -	      beq	flipdisplaybufferreturn
   3362  f4f9				  -
   3363  f4f9				  -			; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   3364  f4f9				  -			; To make savescreen work with the new working buffer, we need to copy over the saved objects
   3365  f4f9				  -			; from the displayed buffer to the working buffer...
   3366  f4f9				  -
   3367  f4f9				  -	      lda	doublebufferdloffset
   3368  f4f9				  -	      eor	#DOUBLEBUFFEROFFSET
   3369  f4f9				  -	      sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   3370  f4f9				  -
   3371  f4f9				  -	      ldx	#(WZONECOUNT-1)
   3372  f4f9				  -copybufferzoneloop
   3373  f4f9				  -
   3374  f4f9				  -	      lda	DLPOINTL,x
   3375  f4f9				  -	      clc
   3376  f4f9				  -	      adc	doublebufferdloffset
   3377  f4f9				  -	      sta	temp1
   3378  f4f9				  -	      lda	DLPOINTH,x
   3379  f4f9				  -	      adc	#0
   3380  f4f9				  -	      sta	temp2
   3381  f4f9				  -
   3382  f4f9				  -	      lda	DLPOINTL,x
   3383  f4f9				  -	      clc
   3384  f4f9				  -	      adc	temp6
   3385  f4f9				  -	      sta	temp3
   3386  f4f9				  -	      lda	DLPOINTH,x
   3387  f4f9				  -	      adc	#0
   3388  f4f9				  -	      sta	temp4
   3389  f4f9				  -
   3390  f4f9				  -	      lda	dlendsave,x
   3391  f4f9				  -	      tay
   3392  f4f9				  -copybuffercharsloop
   3393  f4f9				  -	      lda	(temp3),y
   3394  f4f9				  -	      sta	(temp1),y
   3395  f4f9				  -	      dey
   3396  f4f9				  -	      bpl	copybuffercharsloop
   3397  f4f9				  -	      dex
   3398  f4f9				  -	      bpl	copybufferzoneloop
   3399  f4f9				  -	      lda	#0
   3400  f4f9				  -	      sta	doublebufferbufferdirty
   3401  f4f9				  -	      endif		; ! BANKSET_DL_IN_CARTRAM
   3402  f4f9				  -	      rts
   3403  f4f9				  -
   3404  f4f9				  -doublebufferoff
   3405  f4f9				  -	      lda	#1
   3406  f4f9				  -	      sta	doublebufferstate
   3407  f4f9				  -	      jsr	flipdisplaybuffer
   3408  f4f9				  -	      lda	#0
   3409  f4f9				  -	      sta	doublebufferstate
   3410  f4f9				  -	      sta	doublebufferdloffset
   3411  f4f9				  -	      rts
   3412  f4f9				  -
   3413  f4f9				  -DLLMEMLutLo
   3414  f4f9				  -	      .byte	<DLLMEM,<(DLLMEM+DBOFFSET)
   3415  f4f9				  -DLLMEMLutHi
   3416  f4f9				  -	      .byte	>DLLMEM,>(DLLMEM+DBOFFSET)
   3417  f4f9				  -NewPageflipstate
   3418  f4f9				  -	      .byte	3,1
   3419  f4f9				  -NewPageflipoffset
   3420  f4f9				  -	      .byte	DOUBLEBUFFEROFFSET,0
   3421  f4f9				  -
   3422  f4f9					      endif		; DOUBLEBUFFER
   3423  f4f9
   3424  f4f9				  -	      ifconst	MOUSESUPPORT
   3425  f4f9				  -
   3426  f4f9				  -rotationalcompare
   3427  f4f9				  -			; old =   00	  01	  10	 11
   3428  f4f9				  -	      .byte	$00, $01, $ff, $00	; new=00
   3429  f4f9				  -	      .byte	$ff, $00, $00, $01	; new=01
   3430  f4f9				  -	      .byte	$01, $00, $00, $ff	; new=10
   3431  f4f9				  -	      .byte	$00, $ff, $01, $00	; new=11
   3432  f4f9				  -
   3433  f4f9				  -			;  0000YyXx st mouse
   3434  f4f9				  -
   3435  f4f9				  -			;  0000xyXY amiga mouse
   3436  f4f9				  -
   3437  f4f9				  -	      ifconst	MOUSEXONLY
   3438  f4f9				  -amigatoataribits		; swap bits 1 and 4...
   3439  f4f9				  -	      .byte	%0000, %0000, %0010, %0010
   3440  f4f9				  -	      .byte	%0000, %0000, %0010, %0010
   3441  f4f9				  -	      .byte	%0001, %0001, %0011, %0011
   3442  f4f9				  -	      .byte	%0001, %0001, %0011, %0011
   3443  f4f9				  -
   3444  f4f9				  -			; null change bits
   3445  f4f9				  -	      .byte	%0000, %0001, %0010, %0011
   3446  f4f9				  -	      .byte	%0000, %0001, %0010, %0011
   3447  f4f9				  -	      .byte	%0000, %0001, %0010, %0011
   3448  f4f9				  -	      .byte	%0000, %0001, %0010, %0011
   3449  f4f9				  -
   3450  f4f9				  -	      else		; !MOUSEXONLY
   3451  f4f9				  -
   3452  f4f9				  -amigatoataribits		; swap bits 1 and 4...
   3453  f4f9				  -	      .byte	%0000, %1000, %0010, %1010
   3454  f4f9				  -	      .byte	%0100, %1100, %0110, %1110
   3455  f4f9				  -	      .byte	%0001, %1001, %0011, %1011
   3456  f4f9				  -	      .byte	%0101, %1101, %0111, %1111
   3457  f4f9				  -			; null change bits
   3458  f4f9				  -	      .byte	%0000, %0001, %0010, %0011
   3459  f4f9				  -	      .byte	%0100, %0101, %0110, %0111
   3460  f4f9				  -	      .byte	%1000, %1001, %1010, %1011
   3461  f4f9				  -	      .byte	%1100, %1101, %1110, %1111
   3462  f4f9				  -	      endif		; !MOUSEXONLY
   3463  f4f9				  -
   3464  f4f9					      endif		; MOUSESUPPORT
   3465  f4f9
   3466  f4f9				   mouse0update
   3467  f4f9				  -	      ifconst	MOUSE0SUPPORT
   3468  f4f9				  -
   3469  f4f9				  -mousetableselect =	inttemp2
   3470  f4f9				  -mousexdelta =	inttemp3
   3471  f4f9				  -mouseydelta =	inttemp4
   3472  f4f9				  -lastSWCHA  =	inttemp6
   3473  f4f9				  -
   3474  f4f9				  -			;  0000YyXx st mouse
   3475  f4f9				  -			;  0000xyXY amiga mouse
   3476  f4f9				  -
   3477  f4f9				  -	      lda	#$ff
   3478  f4f9				  -	      sta	lastSWCHA
   3479  f4f9				  -
   3480  f4f9				  -	      ldy	port0control
   3481  f4f9				  -
   3482  f4f9				  -	      lda	#%00010000
   3483  f4f9				  -	      cpy	#9	; AMIGA?
   3484  f4f9				  -	      bne	skipamigabitsfix0
   3485  f4f9				  -	      lda	#0
   3486  f4f9				  -skipamigabitsfix0
   3487  f4f9				  -	      sta	mousetableselect
   3488  f4f9				  -	      ifconst	DRIVINGBOOST
   3489  f4f9				  -	      cpy	#6	; DRIVING?
   3490  f4f9				  -	      bne	skipdriving0setup
   3491  f4f9				  -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   3492  f4f9				  -			; trails the actual mousex0, so we can smoothly interpolate toward
   3493  f4f9				  -			; the actual position. This actual position is stored in mousey0
   3494  f4f9				  -			; after the driver has run.
   3495  f4f9				  -	      ldx	mousex0
   3496  f4f9				  -	      lda	mousey0
   3497  f4f9				  -	      stx	mousey0
   3498  f4f9				  -	      sta	mousex0
   3499  f4f9				  -skipdriving0setup
   3500  f4f9				  -	      endif		; DRIVINGBOOST
   3501  f4f9				  -
   3502  f4f9				  -	      lda	#0
   3503  f4f9				  -	      sta	mousexdelta
   3504  f4f9				  -	      sta	mouseydelta
   3505  f4f9				  -
   3506  f4f9				  -	      ifnconst	MOUSETIME
   3507  f4f9				  -	      ifnconst	MOUSEXONLY
   3508  f4f9				  -	      lda	#180	; minimum for x+y
   3509  f4f9				  -	      else
   3510  f4f9				  -	      lda	#100	; minimum for just x
   3511  f4f9				  -	      endif
   3512  f4f9				  -	      else
   3513  f4f9				  -	      lda	#MOUSETIME
   3514  f4f9				  -	      endif
   3515  f4f9				  -	      jsr	SETTIM64T	; INTIM is in Y
   3516  f4f9				  -
   3517  f4f9				  -mouse0updateloop
   3518  f4f9				  -	      lda	SWCHA
   3519  f4f9				  -	      asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   3520  f4f9				  -	      cmp	lastSWCHA
   3521  f4f9				  -	      beq	mouse0loopcondition
   3522  f4f9				  -	      sta	lastSWCHA
   3523  f4f9				  -	      lsr
   3524  f4f9				  -	      lsr
   3525  f4f9				  -	      lsr
   3526  f4f9				  -
   3527  f4f9				  -	      ora	mousetableselect	; atari/amiga decoding table selection
   3528  f4f9				  -
   3529  f4f9				  -			; st mice encode on different bits/joystick-lines than amiga mice...
   3530  f4f9				  -			;  0000YyXx st mouse
   3531  f4f9				  -			;  0000xyXY amiga mouse
   3532  f4f9				  -			; ...so can shuffle the amiga bits to reuse the st driver.
   3533  f4f9				  -	      tay
   3534  f4f9				  -	      lax	amigatoataribits,y
   3535  f4f9				  -
   3536  f4f9				  -	      ifnconst	MOUSEXONLY
   3537  f4f9				  -			; first the Y...
   3538  f4f9				  -	      and	#%00001100
   3539  f4f9				  -	      ora	mousecodey0
   3540  f4f9				  -	      tay
   3541  f4f9				  -	      lda	rotationalcompare,y
   3542  f4f9				  -	      clc
   3543  f4f9				  -	      adc	mouseydelta
   3544  f4f9				  -	      sta	mouseydelta
   3545  f4f9				  -	      tya
   3546  f4f9				  -	      lsr
   3547  f4f9				  -	      lsr
   3548  f4f9				  -	      sta	mousecodey0
   3549  f4f9				  -	      txa
   3550  f4f9				  -			; ...then the X...
   3551  f4f9				  -	      and	#%00000011
   3552  f4f9				  -	      tax
   3553  f4f9				  -	      endif		; !MOUSEXONLY
   3554  f4f9				  -
   3555  f4f9				  -	      asl
   3556  f4f9				  -	      asl
   3557  f4f9				  -	      ora	mousecodex0
   3558  f4f9				  -	      tay
   3559  f4f9				  -	      lda	rotationalcompare,y
   3560  f4f9				  -	      adc	mousexdelta	; carry was clear by previous ASL
   3561  f4f9				  -	      sta	mousexdelta
   3562  f4f9				  -	      stx	mousecodex0
   3563  f4f9				  -mouse0loopcondition
   3564  f4f9				  -	      lda	TIMINT
   3565  f4f9				  -	      bpl	mouse0updateloop
   3566  f4f9				  -
   3567  f4f9				  -			; *** adapt to selected device resolution.
   3568  f4f9				  -	      ldx	port0control
   3569  f4f9				  -
   3570  f4f9				  -	      ifconst	PRECISIONMOUSING
   3571  f4f9				  -	      ldy	port0resolution
   3572  f4f9				  -	      bne	mouse0halveddone
   3573  f4f9				  -	      cpx	#6	; half-resolution is no good for driving wheels
   3574  f4f9				  -	      beq	mouse0halveddone
   3575  f4f9				  -			; resolution=0 is half mouse resolution, necessary for precision
   3576  f4f9				  -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   3577  f4f9				  -
   3578  f4f9				  -	      lda	mousexdelta
   3579  f4f9				  -	      cmp	#$80
   3580  f4f9				  -	      ror		; do a signed divide by 2.
   3581  f4f9				  -	      clc
   3582  f4f9				  -	      adc	mousex0
   3583  f4f9				  -	      sta	mousex0
   3584  f4f9				  -	      ifnconst	MOUSEXONLY
   3585  f4f9				  -	      lda	mouseydelta
   3586  f4f9				  -	      clc
   3587  f4f9				  -	      adc	mousey0
   3588  f4f9				  -	      sta	mousey0
   3589  f4f9				  -	      endif
   3590  f4f9				  -			; at half resolution we just exit after updating x and y
   3591  f4f9				  -	      jmp	LLRET0
   3592  f4f9				  -mouse0halveddone
   3593  f4f9				  -	      endif		; PRECISIONMOUSING
   3594  f4f9				  -
   3595  f4f9				  -	      ifnconst	MOUSEXONLY
   3596  f4f9				  -	      asl	mouseydelta	; *2 because Y resolution is finer
   3597  f4f9				  -	      ldy	port0resolution
   3598  f4f9				  -	      dey
   3599  f4f9				  -	      lda	#0
   3600  f4f9				  -mousey0resolutionfix
   3601  f4f9				  -	      clc
   3602  f4f9				  -	      adc	mouseydelta
   3603  f4f9				  -	      dey
   3604  f4f9				  -	      bpl	mousey0resolutionfix
   3605  f4f9				  -	      clc
   3606  f4f9				  -	      adc	mousey0
   3607  f4f9				  -	      sta	mousey0
   3608  f4f9				  -	      endif		; MOUSEXONLY
   3609  f4f9				  -
   3610  f4f9				  -	      ldy	port0resolution
   3611  f4f9				  -	      dey
   3612  f4f9				  -	      lda	#0
   3613  f4f9				  -mousex0resolutionfix
   3614  f4f9				  -	      clc
   3615  f4f9				  -	      adc	mousexdelta
   3616  f4f9				  -	      dey
   3617  f4f9				  -	      bpl	mousex0resolutionfix
   3618  f4f9				  -	      ifnconst	DRIVINGBOOST
   3619  f4f9				  -	      clc
   3620  f4f9				  -	      adc	mousex0
   3621  f4f9				  -	      sta	mousex0
   3622  f4f9				  -	      else
   3623  f4f9				  -	      cpx	#6
   3624  f4f9				  -	      beq	carryonmouse0boost
   3625  f4f9				  -	      clc
   3626  f4f9				  -	      adc	mousex0
   3627  f4f9				  -	      sta	mousex0
   3628  f4f9				  -	      jmp	LLRET0
   3629  f4f9				  -carryonmouse0boost
   3630  f4f9				  -	      sta	mousexdelta
   3631  f4f9				  -	      clc
   3632  f4f9				  -	      adc	mousecodey0
   3633  f4f9				  -	      sta	mousecodey0
   3634  f4f9				  -	      clc
   3635  f4f9				  -	      adc	mousex0
   3636  f4f9				  -	      tay		; save the target X
   3637  f4f9				  -	      adc	mousey0	; average in the smoothly-trailing X
   3638  f4f9				  -	      ror
   3639  f4f9				  -	      sta	mousex0	; mousex0 now has the smoothly trailing X
   3640  f4f9				  -	      sty	mousey0	; and mousey0 has the the target X
   3641  f4f9				  -
   3642  f4f9				  -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   3643  f4f9				  -			; A has mousex0, the smoothly trailing X
   3644  f4f9				  -	      sbc	mousey0	; less the target X
   3645  f4f9				  -	      bpl	skipabsolutedrive0
   3646  f4f9				  -	      eor	#$ff
   3647  f4f9				  -skipabsolutedrive0
   3648  f4f9				  -	      cmp	#64	; just an unreasonably large change
   3649  f4f9				  -	      bcc	skipdrivewrapfix0
   3650  f4f9				  -	      sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   3651  f4f9				  -skipdrivewrapfix0
   3652  f4f9				  -
   3653  f4f9				  -			; get rid of the tweening if the distance travelled was very small
   3654  f4f9				  -	      lda	mousexdelta
   3655  f4f9				  -	      cmp	port0resolution
   3656  f4f9				  -	      bcs	skipbetweenfix0
   3657  f4f9				  -	      lda	mousex0
   3658  f4f9				  -	      sta	mousey0
   3659  f4f9				  -skipbetweenfix0
   3660  f4f9				  -
   3661  f4f9				  -drivingboostreductioncheck0
   3662  f4f9				  -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   3663  f4f9				  -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   3664  f4f9				  -			; negated again because truncation during BCD math results in
   3665  f4f9				  -			; differing magnitudes, depending if the value is  +ve or -ve.
   3666  f4f9				  -driving0fix
   3667  f4f9				  -	      lax	mousecodey0
   3668  f4f9				  -	      cmp	#$80
   3669  f4f9				  -	      bcs	driving0skipnegate1
   3670  f4f9				  -	      eor	#$FF
   3671  f4f9				  -	      adc	#1
   3672  f4f9				  -	      sta	mousecodey0
   3673  f4f9				  -driving0skipnegate1
   3674  f4f9				  -	      cmp	#$80
   3675  f4f9				  -	      ror
   3676  f4f9				  -	      cmp	#$80
   3677  f4f9				  -	      ror
   3678  f4f9				  -	      cmp	#$80
   3679  f4f9				  -	      ror
   3680  f4f9				  -	      sta	inttemp1
   3681  f4f9				  -	      lda	mousecodey0
   3682  f4f9				  -	      sec
   3683  f4f9				  -	      sbc	inttemp1
   3684  f4f9				  -	      cpx	#$80
   3685  f4f9				  -	      bcs	driving0skipnegate2
   3686  f4f9				  -	      eor	#$FF
   3687  f4f9				  -	      adc	#1
   3688  f4f9				  -driving0skipnegate2
   3689  f4f9				  -	      sta	mousecodey0
   3690  f4f9				  -drivingboostdone0
   3691  f4f9				  -	      endif		; DRIVINGBOOST
   3692  f4f9				  -
   3693  f4f9				  -	      jmp	LLRET0
   3694  f4f9				  -
   3695  f4f9					      endif		; MOUSE0SUPPORT
   3696  f4f9
   3697  f4f9				   mouse1update
   3698  f4f9				  -	      ifconst	MOUSE1SUPPORT
   3699  f4f9				  -
   3700  f4f9				  -mousetableselect =	inttemp2
   3701  f4f9				  -mousexdelta =	inttemp3
   3702  f4f9				  -mouseydelta =	inttemp4
   3703  f4f9				  -lastSWCHA  =	inttemp6
   3704  f4f9				  -
   3705  f4f9				  -			;  0000YyXx st mouse
   3706  f4f9				  -			;  0000xyXY amiga mouse
   3707  f4f9				  -
   3708  f4f9				  -	      lda	#$ff
   3709  f4f9				  -	      sta	lastSWCHA
   3710  f4f9				  -
   3711  f4f9				  -	      ldy	port1control
   3712  f4f9				  -
   3713  f4f9				  -	      lda	#%00010000
   3714  f4f9				  -	      cpy	#9	; AMIGA?
   3715  f4f9				  -	      bne	skipamigabitsfix1
   3716  f4f9				  -	      lda	#0
   3717  f4f9				  -skipamigabitsfix1
   3718  f4f9				  -	      sta	mousetableselect
   3719  f4f9				  -	      ifconst	DRIVINGBOOST
   3720  f4f9				  -	      cpy	#6	; DRIVING?
   3721  f4f9				  -	      bne	skipdriving1setup
   3722  f4f9				  -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   3723  f4f9				  -			; trails the actual mousex1, so we can smoothly interpolate toward
   3724  f4f9				  -			; the actual position. This actual position is stored in mousey1
   3725  f4f9				  -			; after the driver has run.
   3726  f4f9				  -	      ldx	mousex1
   3727  f4f9				  -	      lda	mousey1
   3728  f4f9				  -	      stx	mousey1
   3729  f4f9				  -	      sta	mousex1
   3730  f4f9				  -skipdriving1setup
   3731  f4f9				  -	      endif		; DRIVINGBOOST
   3732  f4f9				  -
   3733  f4f9				  -	      lda	#0
   3734  f4f9				  -	      sta	mousexdelta
   3735  f4f9				  -	      sta	mouseydelta
   3736  f4f9				  -
   3737  f4f9				  -	      ifnconst	MOUSETIME
   3738  f4f9				  -	      ifnconst	MOUSEXONLY
   3739  f4f9				  -	      lda	#180	; minimum for x+y
   3740  f4f9				  -	      else
   3741  f4f9				  -	      lda	#100	; minimum for just x
   3742  f4f9				  -	      endif
   3743  f4f9				  -	      else
   3744  f4f9				  -	      lda	#MOUSETIME
   3745  f4f9				  -	      endif
   3746  f4f9				  -	      jsr	SETTIM64T	; INTIM is in Y
   3747  f4f9				  -
   3748  f4f9				  -mouse1updateloop
   3749  f4f9				  -	      lda	SWCHA
   3750  f4f9				  -	      and	#%00001111
   3751  f4f9				  -	      cmp	lastSWCHA
   3752  f4f9				  -	      beq	mouse1loopcondition
   3753  f4f9				  -	      sta	lastSWCHA
   3754  f4f9				  -
   3755  f4f9				  -	      ora	mousetableselect	; atari/amiga decoding table selection
   3756  f4f9				  -
   3757  f4f9				  -			; st mice encode on different bits/joystick-lines than amiga mice...
   3758  f4f9				  -			;  0000YyXx st mouse
   3759  f4f9				  -			;  0000xyXY amiga mouse
   3760  f4f9				  -			; ...so can shuffle the amiga bits to reuse the st driver.
   3761  f4f9				  -	      tay
   3762  f4f9				  -	      lax	amigatoataribits,y
   3763  f4f9				  -
   3764  f4f9				  -	      ifnconst	MOUSEXONLY
   3765  f4f9				  -			; first the Y...
   3766  f4f9				  -	      and	#%00001100
   3767  f4f9				  -	      ora	mousecodey1
   3768  f4f9				  -	      tay
   3769  f4f9				  -	      lda	rotationalcompare,y
   3770  f4f9				  -	      clc
   3771  f4f9				  -	      adc	mouseydelta
   3772  f4f9				  -	      sta	mouseydelta
   3773  f4f9				  -	      tya
   3774  f4f9				  -	      lsr
   3775  f4f9				  -	      lsr
   3776  f4f9				  -	      sta	mousecodey1
   3777  f4f9				  -	      txa
   3778  f4f9				  -			; ...then the X...
   3779  f4f9				  -	      and	#%00000011
   3780  f4f9				  -	      tax
   3781  f4f9				  -	      endif		; !MOUSEXONLY
   3782  f4f9				  -
   3783  f4f9				  -	      asl
   3784  f4f9				  -	      asl
   3785  f4f9				  -	      ora	mousecodex1
   3786  f4f9				  -	      tay
   3787  f4f9				  -	      lda	rotationalcompare,y
   3788  f4f9				  -	      adc	mousexdelta	; carry was clear by previous ASL
   3789  f4f9				  -	      sta	mousexdelta
   3790  f4f9				  -	      stx	mousecodex1
   3791  f4f9				  -mouse1loopcondition
   3792  f4f9				  -	      lda	TIMINT
   3793  f4f9				  -	      bpl	mouse1updateloop
   3794  f4f9				  -
   3795  f4f9				  -			; *** adapt to selected device resolution.
   3796  f4f9				  -	      ldx	port1control
   3797  f4f9				  -
   3798  f4f9				  -	      ifconst	PRECISIONMOUSING
   3799  f4f9				  -	      ldy	port1resolution
   3800  f4f9				  -	      bne	mouse1halveddone
   3801  f4f9				  -	      cpx	#6	; half-resolution is no good for driving wheels
   3802  f4f9				  -	      beq	mouse1halveddone
   3803  f4f9				  -			; resolution=0 is half mouse resolution, necessary for precision
   3804  f4f9				  -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   3805  f4f9				  -
   3806  f4f9				  -	      lda	mousexdelta
   3807  f4f9				  -	      cmp	#$80
   3808  f4f9				  -	      ror		; do a signed divide by 2.
   3809  f4f9				  -	      clc
   3810  f4f9				  -	      adc	mousex1
   3811  f4f9				  -	      sta	mousex1
   3812  f4f9				  -	      ifnconst	MOUSEXONLY
   3813  f4f9				  -	      lda	mouseydelta
   3814  f4f9				  -	      clc
   3815  f4f9				  -	      adc	mousey1
   3816  f4f9				  -	      sta	mousey1
   3817  f4f9				  -	      endif
   3818  f4f9				  -			; at half resolution we just exit after updating x and y
   3819  f4f9				  -	      jmp	LLRET1
   3820  f4f9				  -mouse1halveddone
   3821  f4f9				  -	      endif		; PRECISIONMOUSING
   3822  f4f9				  -
   3823  f4f9				  -	      ifnconst	MOUSEXONLY
   3824  f4f9				  -	      asl	mouseydelta	; *2 because Y resolution is finer
   3825  f4f9				  -	      ldy	port1resolution
   3826  f4f9				  -	      dey
   3827  f4f9				  -	      lda	#0
   3828  f4f9				  -mousey1resolutionfix
   3829  f4f9				  -	      clc
   3830  f4f9				  -	      adc	mouseydelta
   3831  f4f9				  -	      dey
   3832  f4f9				  -	      bpl	mousey1resolutionfix
   3833  f4f9				  -	      clc
   3834  f4f9				  -	      adc	mousey1
   3835  f4f9				  -	      sta	mousey1
   3836  f4f9				  -	      endif		; MOUSEXONLY
   3837  f4f9				  -
   3838  f4f9				  -	      ldy	port1resolution
   3839  f4f9				  -	      dey
   3840  f4f9				  -	      lda	#0
   3841  f4f9				  -mousex1resolutionfix
   3842  f4f9				  -	      clc
   3843  f4f9				  -	      adc	mousexdelta
   3844  f4f9				  -	      dey
   3845  f4f9				  -	      bpl	mousex1resolutionfix
   3846  f4f9				  -	      ifnconst	DRIVINGBOOST
   3847  f4f9				  -	      clc
   3848  f4f9				  -	      adc	mousex1
   3849  f4f9				  -	      sta	mousex1
   3850  f4f9				  -	      else
   3851  f4f9				  -	      cpx	#6
   3852  f4f9				  -	      beq	carryonmouse1boost
   3853  f4f9				  -	      clc
   3854  f4f9				  -	      adc	mousex1
   3855  f4f9				  -	      sta	mousex1
   3856  f4f9				  -	      jmp	LLRET1
   3857  f4f9				  -carryonmouse1boost
   3858  f4f9				  -	      sta	mousexdelta
   3859  f4f9				  -	      clc
   3860  f4f9				  -	      adc	mousecodey1
   3861  f4f9				  -	      sta	mousecodey1
   3862  f4f9				  -	      clc
   3863  f4f9				  -	      adc	mousex1
   3864  f4f9				  -	      tay		; save the target X
   3865  f4f9				  -	      adc	mousey1	; average in the smoothly-trailing X
   3866  f4f9				  -	      ror
   3867  f4f9				  -	      sta	mousex1	; mousex0 now has the smoothly trailing X
   3868  f4f9				  -	      sty	mousey1	; and mousey0 has the the target X
   3869  f4f9				  -
   3870  f4f9				  -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   3871  f4f9				  -			; A has mousex1, the smoothly trailing X
   3872  f4f9				  -	      sbc	mousey1	; less the target X
   3873  f4f9				  -	      bpl	skipabsolutedrive1
   3874  f4f9				  -	      eor	#$ff
   3875  f4f9				  -skipabsolutedrive1
   3876  f4f9				  -	      cmp	#64	; just an unreasonably large change
   3877  f4f9				  -	      bcc	skipdrivewrapfix1
   3878  f4f9				  -	      sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   3879  f4f9				  -skipdrivewrapfix1
   3880  f4f9				  -
   3881  f4f9				  -			; get rid of the tweening if the distance travelled was very small
   3882  f4f9				  -	      lda	mousexdelta
   3883  f4f9				  -	      cmp	port1resolution
   3884  f4f9				  -	      bcs	skipbetweenfix1
   3885  f4f9				  -	      lda	mousex1
   3886  f4f9				  -	      sta	mousey1
   3887  f4f9				  -skipbetweenfix1
   3888  f4f9				  -
   3889  f4f9				  -drivingboostreductioncheck1
   3890  f4f9				  -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   3891  f4f9				  -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   3892  f4f9				  -			; negated again because truncation during BCD math results in
   3893  f4f9				  -			; differing magnitudes, depending if the value is  +ve or -ve.
   3894  f4f9				  -driving1fix
   3895  f4f9				  -	      lax	mousecodey1
   3896  f4f9				  -	      cmp	#$80
   3897  f4f9				  -	      bcs	driving0skipnegate1
   3898  f4f9				  -	      eor	#$FF
   3899  f4f9				  -	      adc	#1
   3900  f4f9				  -	      sta	mousecodey1
   3901  f4f9				  -driving0skipnegate1
   3902  f4f9				  -	      cmp	#$80
   3903  f4f9				  -	      ror
   3904  f4f9				  -	      cmp	#$80
   3905  f4f9				  -	      ror
   3906  f4f9				  -	      cmp	#$80
   3907  f4f9				  -	      ror
   3908  f4f9				  -	      sta	inttemp1
   3909  f4f9				  -	      lda	mousecodey1
   3910  f4f9				  -	      sec
   3911  f4f9				  -	      sbc	inttemp1
   3912  f4f9				  -	      cpx	#$80
   3913  f4f9				  -	      bcs	driving1skipnegate2
   3914  f4f9				  -	      eor	#$FF
   3915  f4f9				  -	      adc	#1
   3916  f4f9				  -driving1skipnegate2
   3917  f4f9				  -	      sta	mousecodey1
   3918  f4f9				  -drivingboostdone1
   3919  f4f9				  -	      endif		; DRIVINGBOOST
   3920  f4f9				  -
   3921  f4f9				  -	      jmp	LLRET1
   3922  f4f9				  -
   3923  f4f9					      endif		; MOUSE1SUPPORT
   3924  f4f9
   3925  f4f9
   3926  f4f9				   trakball0update
   3927  f4f9				  -	      ifconst	TRAKBALL0SUPPORT
   3928  f4f9				  -	      ifnconst	TRAKTIME
   3929  f4f9				  -	      ifnconst	TRAKXONLY
   3930  f4f9				  -	      lda	#180	; minimum for x+y
   3931  f4f9				  -	      else		;  !TRAKXONLY
   3932  f4f9				  -	      lda	#100	; minimum for just x
   3933  f4f9				  -	      endif		; !TRAKXONLY
   3934  f4f9				  -	      else		; !TRAKTIME
   3935  f4f9				  -	      lda	#TRAKTIME
   3936  f4f9				  -	      endif		; !TRAKTIME
   3937  f4f9				  -	      jsr	SETTIM64T	; INTIM is in Y
   3938  f4f9				  -	      ldx	#0
   3939  f4f9				  -	      ifnconst	TRAKXONLY
   3940  f4f9				  -	      ldy	#0
   3941  f4f9				  -	      endif		;  TRAKXONLY
   3942  f4f9				  -trakball0updateloop
   3943  f4f9				  -	      lda	SWCHA
   3944  f4f9				  -	      and	#%00110000
   3945  f4f9				  -	      cmp	trakballcodex0
   3946  f4f9				  -	      sta	trakballcodex0
   3947  f4f9				  -	      beq	trakball0movementXdone
   3948  f4f9				  -	      and	#%00010000
   3949  f4f9				  -	      beq	trakball0negativeX
   3950  f4f9				  -trakball0positiveX
   3951  f4f9				  -			;(2 from beq)
   3952  f4f9				  -	      inx		; 2
   3953  f4f9				  -	      jmp	trakball0movementXdone	; 3
   3954  f4f9				  -trakball0negativeX
   3955  f4f9				  -			;(3 from beq)
   3956  f4f9				  -	      dex		; 2
   3957  f4f9				  -	      nop		; 2
   3958  f4f9				  -trakball0movementXdone
   3959  f4f9				  -
   3960  f4f9				  -	      ifnconst	TRAKXONLY
   3961  f4f9				  -	      lda	SWCHA
   3962  f4f9				  -	      and	#%11000000
   3963  f4f9				  -	      cmp	trakballcodey0
   3964  f4f9				  -	      sta	trakballcodey0
   3965  f4f9				  -	      beq	trakball0movementYdone
   3966  f4f9				  -	      and	#%01000000
   3967  f4f9				  -	      beq	trakball0negativeY
   3968  f4f9				  -trakball0positiveY
   3969  f4f9				  -			;(2 from beq)
   3970  f4f9				  -	      iny		; 2
   3971  f4f9				  -	      jmp	trakball0movementYdone	; 3
   3972  f4f9				  -trakball0negativeY
   3973  f4f9				  -			;(3 from beq)
   3974  f4f9				  -	      dey		; 2
   3975  f4f9				  -	      nop		; 2
   3976  f4f9				  -trakball0movementYdone
   3977  f4f9				  -	      endif		; !TRAKXONLY
   3978  f4f9				  -
   3979  f4f9				  -	      lda	TIMINT
   3980  f4f9				  -	      bpl	trakball0updateloop
   3981  f4f9				  -	      lda	#0
   3982  f4f9				  -	      cpx	#0
   3983  f4f9				  -	      beq	trakball0skipXadjust
   3984  f4f9				  -	      clc
   3985  f4f9				  -trakball0Xloop
   3986  f4f9				  -	      adc	port0resolution
   3987  f4f9				  -	      dex
   3988  f4f9				  -	      bne	trakball0Xloop
   3989  f4f9				  -	      clc
   3990  f4f9				  -	      adc	trakballx0
   3991  f4f9				  -	      sta	trakballx0
   3992  f4f9				  -trakball0skipXadjust
   3993  f4f9				  -	      ifnconst	TRAKXONLY
   3994  f4f9				  -	      lda	#0
   3995  f4f9				  -	      cpy	#0
   3996  f4f9				  -	      beq	trakball0skipYadjust
   3997  f4f9				  -	      clc
   3998  f4f9				  -trakball0yloop
   3999  f4f9				  -	      adc	port0resolution
   4000  f4f9				  -	      dey
   4001  f4f9				  -	      bne	trakball0yloop
   4002  f4f9				  -	      clc
   4003  f4f9				  -	      adc	trakbally0
   4004  f4f9				  -	      sta	trakbally0
   4005  f4f9				  -trakball0skipYadjust
   4006  f4f9				  -	      endif		; !TRAKXONLY
   4007  f4f9				  -
   4008  f4f9				  -	      jmp	LLRET0
   4009  f4f9					      endif
   4010  f4f9
   4011  f4f9
   4012  f4f9
   4013  f4f9				   trakball1update
   4014  f4f9				  -	      ifconst	TRAKBALL1SUPPORT
   4015  f4f9				  -	      ifnconst	TRAKTIME
   4016  f4f9				  -	      ifnconst	TRAKXONLY
   4017  f4f9				  -	      lda	#180	; minimum for x+y
   4018  f4f9				  -	      else		;  !TRAKXONLY
   4019  f4f9				  -	      lda	#100	; minimum for just x
   4020  f4f9				  -	      endif		; !TRAKXONLY
   4021  f4f9				  -	      else		; !TRAKTIME
   4022  f4f9				  -	      lda	#TRAKTIME
   4023  f4f9				  -	      endif		; !TRAKTIME
   4024  f4f9				  -	      jsr	SETTIM64T	; INTIM is in Y
   4025  f4f9				  -	      ldx	#0
   4026  f4f9				  -	      ifnconst	TRAKXONLY
   4027  f4f9				  -	      ldy	#0
   4028  f4f9				  -	      endif		;  TRAKXONLY
   4029  f4f9				  -trakball1updateloop
   4030  f4f9				  -	      lda	SWCHA
   4031  f4f9				  -	      and	#%00000011
   4032  f4f9				  -	      cmp	trakballcodex1
   4033  f4f9				  -	      sta	trakballcodex1
   4034  f4f9				  -	      beq	trakball1movementXdone
   4035  f4f9				  -	      and	#%00000001
   4036  f4f9				  -	      beq	trakball1negativeX
   4037  f4f9				  -trakball1positiveX
   4038  f4f9				  -			;(2 from beq)
   4039  f4f9				  -	      inx		; 2
   4040  f4f9				  -	      jmp	trakball1movementXdone	; 3
   4041  f4f9				  -trakball1negativeX
   4042  f4f9				  -			;(3 from beq)
   4043  f4f9				  -	      dex		; 2
   4044  f4f9				  -	      nop		; 2
   4045  f4f9				  -trakball1movementXdone
   4046  f4f9				  -
   4047  f4f9				  -	      ifnconst	TRAKXONLY
   4048  f4f9				  -	      lda	SWCHA
   4049  f4f9				  -	      and	#%00001100
   4050  f4f9				  -	      cmp	trakballcodey1
   4051  f4f9				  -	      sta	trakballcodey1
   4052  f4f9				  -	      beq	trakball1movementYdone
   4053  f4f9				  -	      and	#%00000100
   4054  f4f9				  -	      beq	trakball1negativeY
   4055  f4f9				  -trakball1positiveY
   4056  f4f9				  -			;(2 from beq)
   4057  f4f9				  -	      iny		; 2
   4058  f4f9				  -	      jmp	trakball1movementYdone	; 3
   4059  f4f9				  -trakball1negativeY
   4060  f4f9				  -			;(3 from beq)
   4061  f4f9				  -	      dey		; 2
   4062  f4f9				  -	      nop		; 2
   4063  f4f9				  -trakball1movementYdone
   4064  f4f9				  -	      endif		; !TRAKXONLY
   4065  f4f9				  -
   4066  f4f9				  -	      lda	TIMINT
   4067  f4f9				  -	      bpl	trakball1updateloop
   4068  f4f9				  -	      lda	#0
   4069  f4f9				  -	      cpx	#0
   4070  f4f9				  -	      beq	trakball1skipXadjust
   4071  f4f9				  -	      clc
   4072  f4f9				  -trakball1Xloop
   4073  f4f9				  -	      adc	port1resolution
   4074  f4f9				  -	      dex
   4075  f4f9				  -	      bne	trakball1Xloop
   4076  f4f9				  -	      clc
   4077  f4f9				  -	      adc	trakballx1
   4078  f4f9				  -	      sta	trakballx1
   4079  f4f9				  -trakball1skipXadjust
   4080  f4f9				  -	      ifnconst	TRAKXONLY
   4081  f4f9				  -	      lda	#0
   4082  f4f9				  -	      cpy	#0
   4083  f4f9				  -	      beq	trakball1skipYadjust
   4084  f4f9				  -	      clc
   4085  f4f9				  -trakball1yloop
   4086  f4f9				  -	      adc	port1resolution
   4087  f4f9				  -	      dey
   4088  f4f9				  -	      bne	trakball1yloop
   4089  f4f9				  -	      clc
   4090  f4f9				  -	      adc	trakbally1
   4091  f4f9				  -	      sta	trakbally1
   4092  f4f9				  -trakball1skipYadjust
   4093  f4f9				  -	      endif		; !TRAKXONLY
   4094  f4f9				  -
   4095  f4f9				  -	      jmp	LLRET1
   4096  f4f9					      endif
   4097  f4f9
   4098  f4f9
   4099  f4f9				   paddleport0update
   4100  f4f9				  -	      ifconst	PADDLE0SUPPORT
   4101  f4f9				  -	      lda	#6
   4102  f4f9				  -	      sta	VBLANK	; start charging the paddle caps
   4103  f4f9				  -	      lda	#0	; use PADDLE timing
   4104  f4f9				  -	      jsr	SETTIM64T	; INTIM is in Y
   4105  f4f9				  -
   4106  f4f9				  -paddleport0updateloop
   4107  f4f9				  -	      lda	INPT0
   4108  f4f9				  -	      bmi	skippaddle0setposition
   4109  f4f9				  -	      sty	paddleposition0
   4110  f4f9				  -skippaddle0setposition
   4111  f4f9				  -	      ifconst	TWOPADDLESUPPORT
   4112  f4f9				  -	      lda	INPT1
   4113  f4f9				  -	      bmi	skippaddle1setposition
   4114  f4f9				  -	      sty	paddleposition1
   4115  f4f9				  -skippaddle1setposition
   4116  f4f9				  -	      endif
   4117  f4f9				  -	      ldy	INTIM
   4118  f4f9				  -	      cpy	#TIMEOFFSET
   4119  f4f9				  -	      bcs	paddleport0updateloop
   4120  f4f9				  -
   4121  f4f9				  -	      lda	#%10000110
   4122  f4f9				  -	      sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   4123  f4f9				  -	      sec
   4124  f4f9				  -	      lda	paddleposition0
   4125  f4f9				  -	      sbc	#TIMEOFFSET
   4126  f4f9				  -	      ifconst	PADDLESCALEX2
   4127  f4f9				  -	      asl
   4128  f4f9				  -	      endif
   4129  f4f9				  -
   4130  f4f9				  -	      ifnconst	PADDLESMOOTHINGOFF
   4131  f4f9				  -	      clc
   4132  f4f9				  -	      adc	paddleprevious0
   4133  f4f9				  -	      ror
   4134  f4f9				  -	      sta	paddleprevious0
   4135  f4f9				  -	      endif
   4136  f4f9				  -
   4137  f4f9				  -	      sta	paddleposition0
   4138  f4f9				  -
   4139  f4f9				  -	      ifconst	TWOPADDLESUPPORT
   4140  f4f9				  -	      sec
   4141  f4f9				  -	      lda	paddleposition1
   4142  f4f9				  -	      sbc	#TIMEOFFSET
   4143  f4f9				  -	      ifconst	PADDLESCALEX2
   4144  f4f9				  -	      asl
   4145  f4f9				  -	      endif
   4146  f4f9				  -
   4147  f4f9				  -	      ifnconst	PADDLESMOOTHINGOFF
   4148  f4f9				  -	      clc
   4149  f4f9				  -	      adc	paddleprevious1
   4150  f4f9				  -	      ror
   4151  f4f9				  -	      sta	paddleprevious1
   4152  f4f9				  -	      endif
   4153  f4f9				  -	      sta	paddleposition1
   4154  f4f9				  -	      endif		; TWOPADDLESUPPORT
   4155  f4f9				  -
   4156  f4f9				  -	      jmp	LLRET0
   4157  f4f9					      endif
   4158  f4f9
   4159  f4f9				   paddleport1update
   4160  f4f9				  -	      ifconst	PADDLE1SUPPORT
   4161  f4f9				  -	      lda	#6
   4162  f4f9				  -	      sta	VBLANK	; start charging the paddle caps
   4163  f4f9				  -
   4164  f4f9				  -	      lda	#0	; use PADDLE timing
   4165  f4f9				  -	      jsr	SETTIM64T	; INTIM is in Y
   4166  f4f9				  -
   4167  f4f9				  -paddleport1updateloop
   4168  f4f9				  -	      lda	INPT2
   4169  f4f9				  -	      bmi	skippaddle2setposition
   4170  f4f9				  -	      sty	paddleposition2
   4171  f4f9				  -skippaddle2setposition
   4172  f4f9				  -	      ifconst	TWOPADDLESUPPORT
   4173  f4f9				  -	      lda	INPT3
   4174  f4f9				  -	      bmi	skippaddle3setposition
   4175  f4f9				  -	      sty	paddleposition3
   4176  f4f9				  -skippaddle3setposition
   4177  f4f9				  -	      endif
   4178  f4f9				  -	      ldy	INTIM
   4179  f4f9				  -	      cpy	#TIMEOFFSET
   4180  f4f9				  -	      bcs	paddleport1updateloop
   4181  f4f9				  -
   4182  f4f9				  -	      lda	#%10000110
   4183  f4f9				  -	      sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   4184  f4f9				  -	      sec
   4185  f4f9				  -	      lda	paddleposition2
   4186  f4f9				  -	      sbc	#TIMEOFFSET
   4187  f4f9				  -	      ifconst	PADDLESCALEX2
   4188  f4f9				  -	      asl
   4189  f4f9				  -	      endif
   4190  f4f9				  -
   4191  f4f9				  -	      ifnconst	PADDLESMOOTHINGOFF
   4192  f4f9				  -	      clc
   4193  f4f9				  -	      adc	paddleprevious2
   4194  f4f9				  -	      ror
   4195  f4f9				  -	      sta	paddleprevious2
   4196  f4f9				  -	      endif
   4197  f4f9				  -
   4198  f4f9				  -	      sta	paddleposition2
   4199  f4f9				  -
   4200  f4f9				  -	      ifconst	TWOPADDLESUPPORT
   4201  f4f9				  -	      sec
   4202  f4f9				  -	      lda	paddleposition3
   4203  f4f9				  -	      sbc	#TIMEOFFSET
   4204  f4f9				  -	      ifconst	PADDLESCALEX2
   4205  f4f9				  -	      asl
   4206  f4f9				  -	      endif
   4207  f4f9				  -
   4208  f4f9				  -	      ifnconst	PADDLESMOOTHINGOFF
   4209  f4f9				  -	      clc
   4210  f4f9				  -	      adc	paddleprevious3
   4211  f4f9				  -	      ror
   4212  f4f9				  -	      sta	paddleprevious3
   4213  f4f9				  -	      endif
   4214  f4f9				  -	      sta	paddleposition3
   4215  f4f9				  -	      endif		; TWOPADDLESUPPORT
   4216  f4f9				  -
   4217  f4f9				  -	      jmp	LLRET1
   4218  f4f9					      endif
   4219  f4f9
   4220  f4f9
   4221  f4f9				   paddlebuttonhandler		; outside of conditional, for button-handler LUT
   4222  f4f9				  -	      ifconst	PADDLESUPPORT
   4223  f4f9				  -			; x=0|1 for port, rather than paddle #.
   4224  f4f9				  -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   4225  f4f9				  -			; game wants to support 2 paddles, up to the game to instead test the
   4226  f4f9				  -			; joystick right+left directions instead.
   4227  f4f9				  -	      lda	SWCHA	; top of nibble is first paddle button
   4228  f4f9				  -	      cpx	#0	; port 0?
   4229  f4f9				  -	      beq	skippaddleport2shift
   4230  f4f9				  -	      asl		; shift second port to upper nibble
   4231  f4f9				  -	      asl
   4232  f4f9				  -	      asl
   4233  f4f9				  -	      asl
   4234  f4f9				  -skippaddleport2shift
   4235  f4f9				  -	      and	#%10000000
   4236  f4f9				  -	      eor	#%10000000	; invert
   4237  f4f9				  -	      sta	sINPT1,x
   4238  f4f9				  -	      jmp	buttonreadloopreturn
   4239  f4f9					      endif		; PADDLESUPPORT
   4240  f4f9
   4241  f4f9				   mousebuttonhandler		; outside of conditional, for button-handler LUT
   4242  f4f9				  -	      ifconst	MOUSESUPPORT
   4243  f4f9				  -			; stick the mouse buttons in the correct shadow register...
   4244  f4f9				  -	      txa
   4245  f4f9				  -	      asl
   4246  f4f9				  -	      tay		; y=x*2
   4247  f4f9				  -	      lda	INPT4,x
   4248  f4f9				  -	      eor	#%10000000
   4249  f4f9				  -	      lsr
   4250  f4f9				  -	      sta	sINPT1,x
   4251  f4f9				  -
   4252  f4f9				  -	      lda	INPT1,y
   4253  f4f9				  -	      and	#%10000000
   4254  f4f9				  -	      eor	#%10000000
   4255  f4f9				  -	      ora	sINPT1,x
   4256  f4f9				  -	      sta	sINPT1,x
   4257  f4f9				  -	      jmp	buttonreadloopreturn
   4258  f4f9					      endif		; MOUSESUPPORT
   4259  f4f9
   4260  f4f9				  -	      ifconst	KEYPADSUPPORT
   4261  f4f9				  -			; ** select keypad rows 0 to 3 over 4 frames...
   4262  f4f9				  -keypadrowselect
   4263  f4f9				  -	      inc	keypadcounter
   4264  f4f9				  -	      ldy	#0
   4265  f4f9				  -	      lda	port0control
   4266  f4f9				  -	      cmp	#7
   4267  f4f9				  -	      bne	skipport0val
   4268  f4f9				  -	      iny		; y=y+1
   4269  f4f9				  -skipport0val
   4270  f4f9				  -	      lda	port1control
   4271  f4f9				  -	      cmp	#7
   4272  f4f9				  -	      bne	skipport1val
   4273  f4f9				  -	      iny
   4274  f4f9				  -	      iny		; y=y+2
   4275  f4f9				  -skipport1val
   4276  f4f9				  -	      cpy	#0
   4277  f4f9				  -	      beq	exitkeypadrowselect
   4278  f4f9				  -	      lda	keyrowdirectionmask,y
   4279  f4f9				  -	      sta	CTLSWA
   4280  f4f9				  -	      tya
   4281  f4f9				  -	      asl
   4282  f4f9				  -	      asl
   4283  f4f9				  -	      sta	inttemp1
   4284  f4f9				  -	      lda	keypadcounter
   4285  f4f9				  -	      and	#3
   4286  f4f9				  -	      ora	inttemp1
   4287  f4f9				  -	      tax
   4288  f4f9				  -	      lda	keyrowselectvalue,x
   4289  f4f9				  -	      sta	SWCHA
   4290  f4f9				  -exitkeypadrowselect
   4291  f4f9				  -	      rts
   4292  f4f9				  -
   4293  f4f9				  -keyrowdirectionmask
   4294  f4f9				  -	      .byte	#%00000000	; 0 : port0=input  port1=input
   4295  f4f9				  -	      .byte	#%11110000	; 1 : port0=output port1=input
   4296  f4f9				  -	      .byte	#%00001111	; 2 : port0=input  port1=output
   4297  f4f9				  -	      .byte	#%11111111	; 3 : port0=output port1=output
   4298  f4f9				  -
   4299  f4f9				  -keyrowselectvalue
   4300  f4f9				  -	      .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   4301  f4f9				  -	      .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   4302  f4f9				  -	      .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   4303  f4f9				  -	      .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   4304  f4f9					      endif		;  KEYPADSUPPORT
   4305  f4f9
   4306  f4f9				  -	      ifconst	KEYPADSUPPORT
   4307  f4f9				  -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   4308  f4f9				  -keypadcolumnread
   4309  f4f9				  -	      lda	port0control
   4310  f4f9				  -	      cmp	#7
   4311  f4f9				  -	      bne	skipkeypadcolumnread0
   4312  f4f9				  -	      lda	keypadcounter
   4313  f4f9				  -	      and	#3
   4314  f4f9				  -	      asl		; x2 because keypad variables are interleaved
   4315  f4f9				  -	      tax
   4316  f4f9				  -	      lda	#0
   4317  f4f9				  -	      sta	keypadmatrix0a,x
   4318  f4f9				  -	      lda	INPT0
   4319  f4f9				  -	      cmp	#$80
   4320  f4f9				  -	      rol	keypadmatrix0a,x
   4321  f4f9				  -	      lda	INPT1
   4322  f4f9				  -	      cmp	#$80
   4323  f4f9				  -	      rol	keypadmatrix0a,x
   4324  f4f9				  -	      lda	INPT4
   4325  f4f9				  -	      cmp	#$80
   4326  f4f9				  -	      rol	keypadmatrix0a,x
   4327  f4f9				  -	      lda	keypadmatrix0a,x
   4328  f4f9				  -	      eor	#%00000111
   4329  f4f9				  -	      sta	keypadmatrix0a,x
   4330  f4f9				  -skipkeypadcolumnread0
   4331  f4f9				  -
   4332  f4f9				  -	      lda	port1control
   4333  f4f9				  -	      cmp	#7
   4334  f4f9				  -	      bne	skipkeypadcolumnread1
   4335  f4f9				  -	      lda	keypadcounter
   4336  f4f9				  -	      and	#3
   4337  f4f9				  -	      asl		; x2 because keypad variables are interleaved
   4338  f4f9				  -	      tax
   4339  f4f9				  -	      lda	#0
   4340  f4f9				  -	      sta	keypadmatrix1a,x
   4341  f4f9				  -	      rol	keypadmatrix1a,x
   4342  f4f9				  -	      lda	INPT2
   4343  f4f9				  -	      cmp	#$80
   4344  f4f9				  -	      rol	keypadmatrix1a,x
   4345  f4f9				  -	      lda	INPT3
   4346  f4f9				  -	      cmp	#$80
   4347  f4f9				  -	      rol	keypadmatrix1a,x
   4348  f4f9				  -	      lda	INPT5
   4349  f4f9				  -	      cmp	#$80
   4350  f4f9				  -	      rol	keypadmatrix1a,x
   4351  f4f9				  -	      lda	keypadmatrix1a,x
   4352  f4f9				  -	      eor	#%00000111
   4353  f4f9				  -	      sta	keypadmatrix1a,x
   4354  f4f9				  -skipkeypadcolumnread1
   4355  f4f9				  -	      rts
   4356  f4f9					      endif		; KEYPADSUPPORT
   4357  f4f9
   4358  f4f9				   setportforinput
   4359  f4f9		       a5 e4		      lda	CTLSWAs
   4360  f4fb		       3d 04 f5 	      and	allpinsinputlut,x
   4361  f4fe		       85 e4		      sta	CTLSWAs
   4362  f500		       8d 81 02 	      sta	CTLSWA
   4363  f503		       60		      rts
   4364  f504
   4365  f504				   allpinsinputlut
   4366  f504		       0f f0		      .byte.b	$0F, $F0
   4367  f506
   4368  f506				   setonebuttonmode
   4369  f506		       a9 06		      lda	#6	; in case we're in unlocked-bios mode
   4370  f508		       85 01		      sta	VBLANK	; if we were on paddles, the line is grounded out.
   4371  f50a		       a9 14		      lda	#$14
   4372  f50c		       8d 83 02 	      sta	CTLSWB	; set both 2-button disable bits to writable
   4373  f50f		       a5 e5		      lda	CTLSWBs
   4374  f511		       1d 1a f5 	      ora	thisjoy2buttonbit,x
   4375  f514		       85 e5		      sta	CTLSWBs
   4376  f516		       8d 82 02 	      sta	SWCHB	; turn off the 2-button disable bits
   4377  f519		       60		      rts
   4378  f51a
   4379  f51a				   thisjoy2buttonbit
   4380  f51a		       04 10		      .byte.b	$04, $10
   4381  f51c
   4382  f51c				   settwobuttonmode
   4383  f51c		       a9 06		      lda	#6	; in case we're in unlocked-bios mode
   4384  f51e		       85 01		      sta	VBLANK	; if we were on paddles, the line is grounded out.
   4385  f520		       a9 14		      lda	#$14
   4386  f522		       8d 83 02 	      sta	CTLSWB	; set both 2-button disable bits to writable
   4387  f525		       a5 e5		      lda	CTLSWBs
   4388  f527		       3d 30 f5 	      and	thisjoy2buttonmask,x
   4389  f52a		       85 e5		      sta	CTLSWBs
   4390  f52c		       8d 82 02 	      sta	SWCHB
   4391  f52f		       60		      rts
   4392  f530
   4393  f530				   thisjoy2buttonmask
   4394  f530		       fb ef		      .byte.b	$fb, $ef
   4395  f532
   4396  f532							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4397  f532
   4398  f532				   START
   4399  f532				   start
   4400  f532
   4401  f532							;******** more or less the Atari recommended startup procedure
   4402  f532
   4403  f532		       78		      sei
   4404  f533		       d8		      cld
   4405  f534
   4406  f534					      ifnconst	NOTIALOCK
   4407  f534		       a9 07		      lda	#$07
   4408  f536				  -	      else
   4409  f536				  -	      lda	#$06
   4410  f536					      endif
   4411  f536		       85 01		      sta	INPTCTRL	;lock 7800 into 7800 mode
   4412  f538		       a9 7f		      lda	#$7F
   4413  f53a		       85 3c		      sta	CTRL	;disable DMA
   4414  f53c		       a9 00		      lda	#$00
   4415  f53e		       85 38		      sta	OFFSET
   4416  f540					      ifnconst	NOTIALOCK
   4417  f540		       85 01		      sta	INPTCTRL
   4418  f542		       85 20		      sta	BACKGRND	; black default, in case a flash cart is using something else
   4419  f544					      endif
   4420  f544		       a2 ff		      ldx	#$FF
   4421  f546		       9a		      txs
   4422  f547
   4423  f547							;************** Clear Memory
   4424  f547
   4425  f547							; ** Clear 1800-27FF, pg0+pg1 memory.
   4426  f547				   ClearMemPages
   4427  f547		       a9 00		      lda	#0
   4428  f549		       a8		      tay		; y=0
   4429  f54a		       85 80		      sta	$80
   4430  f54c		       a2 18		      ldx	#$18
   4431  f54e				   ClearMemPagesLoop
   4432  f54e		       86 81		      stx	$81	; needed for when we step on ZP memory
   4433  f550		       91 80		      sta	($80),y	;Store data
   4434  f552		       c8		      iny		;Next byte
   4435  f553		       d0 f9		      bne	ClearMemPagesLoop
   4436  f555		       e8		      inx
   4437  f556		       e0 28		      cpx	#$28
   4438  f558		       d0 f4		      bne	ClearMemPagesLoop
   4439  f55a		       85 81		      sta	$81
   4440  f55c
   4441  f55c							;seed random number with hopefully-random timer value
   4442  f55c		       a9 01		      lda	#1
   4443  f55e		       0d 84 02 	      ora	INTIM
   4444  f561		       85 40		      sta	rand
   4445  f563
   4446  f563							; detect the console type...
   4447  f563				   pndetectvblankstart
   4448  f563		       a5 28		      lda	MSTAT
   4449  f565		       10 fc		      bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start
   4450  f567				   pndetectvblankover
   4451  f567		       a5 28		      lda	MSTAT
   4452  f569		       30 fc		      bmi	pndetectvblankover	;  then wait for it to be over
   4453  f56b		       a0 00		      ldy	#$00
   4454  f56d		       a2 00		      ldx	#$00
   4455  f56f				   pndetectvblankhappening
   4456  f56f		       a5 28		      lda	MSTAT
   4457  f571		       30 07		      bmi	pndetectinvblank	;  if VBLANK starts, exit our counting loop
   4458  f573		       85 24		      sta	WSYNC
   4459  f575		       85 24		      sta	WSYNC
   4460  f577		       e8		      inx
   4461  f578		       d0 f5		      bne	pndetectvblankhappening
   4462  f57a				   pndetectinvblank
   4463  f57a		       e0 7d		      cpx	#125
   4464  f57c		       90 02		      bcc	pndetecispal
   4465  f57e		       a0 01		      ldy	#$01
   4466  f580				   pndetecispal
   4467  f580		       8c 09 21 	      sty	paldetected
   4468  f583
   4469  f583		       20 5f f4 	      jsr	createallgamedlls
   4470  f586
   4471  f586		       a9 18		      lda	#>DLLMEM
   4472  f588		       85 2c		      sta	DPPH
   4473  f58a		       a9 00		      lda	#<DLLMEM
   4474  f58c		       85 30		      sta	DPPL
   4475  f58e
   4476  f58e				  -	      ifconst	pokeysupport
   4477  f58e				  -			; pokey support is compiled in, so try to detect it...
   4478  f58e				  -	      jsr	detectpokeylocation
   4479  f58e					      endif
   4480  f58e
   4481  f58e		       a9 01		      lda	#1	; default for port 0 and 1 is a regular joystick
   4482  f590		       8d b7 01 	      sta	port0control
   4483  f593		       8d b8 01 	      sta	port1control
   4484  f596
   4485  f596							;Setup port A to read mode
   4486  f596							;lda #$00
   4487  f596							;sta SWCHA
   4488  f596							;sta CTLSWA
   4489  f596
   4490  f596				  -	      ifconst	HSSUPPORT
   4491  f596				  -	      ifconst	bankswitchmode
   4492  f596				  -	      ifconst	included.hiscore.asm.bank
   4493  f596				  -	      ifconst	MCPDEVCART
   4494  f596				  -	      lda	#($18 | included.hiscore.asm.bank)
   4495  f596				  -	      ifconst	dumpbankswitch
   4496  f596				  -	      sta	dumpbankswitch
   4497  f596				  -	      endif
   4498  f596				  -	      sta	$3000
   4499  f596				  -	      else
   4500  f596				  -	      lda	#(included.hiscore.asm.bank)
   4501  f596				  -	      ifconst	dumpbankswitch
   4502  f596				  -	      sta	dumpbankswitch
   4503  f596				  -	      endif
   4504  f596				  -	      sta	$8000
   4505  f596				  -	      endif
   4506  f596				  -	      endif		; included.hiscore.asm.bank
   4507  f596				  -	      endif		; bankswitchmode
   4508  f596				  -			; try to detect HSC
   4509  f596				  -	      jsr	detecthsc
   4510  f596				  -	      and	#1
   4511  f596				  -	      sta	hsdevice
   4512  f596				  -skipHSCdetect
   4513  f596				  -			; try to detect AtariVox eeprom
   4514  f596				  -	      jsr	detectatarivoxeeprom
   4515  f596				  -	      and	#2
   4516  f596				  -	      ora	hsdevice
   4517  f596				  -	      cmp	#3
   4518  f596				  -	      bne	storeAinhsdevice
   4519  f596				  -			; For now, we tie break by giving HSC priority over AtariVox.
   4520  f596				  -			; Later we should check each device's priority byte if set, instead,
   4521  f596				  -	      lda	#2
   4522  f596				  -storeAinhsdevice
   4523  f596				  -	      sta	hsdevice
   4524  f596				  -	      lda	#$ff
   4525  f596				  -	      sta	hsdifficulty
   4526  f596				  -	      sta	hsgameslot
   4527  f596				  -	      sta	hsnewscoreline
   4528  f596					      endif		; HSSUPPORT
   4529  f596
   4530  f596				  -	      ifconst	AVOXVOICE
   4531  f596				  -	      jsr	silenceavoxvoice
   4532  f596					      endif
   4533  f596
   4534  f596				  -	      ifconst	RMT
   4535  f596				  -	      ifconst	RMTVOLUME
   4536  f596				  -	      lda	#$F0	; default to full RMT volume
   4537  f596				  -	      sta	rmtvolume
   4538  f596				  -	      ifconst	TIAVOLUME
   4539  f596				  -	      sta	tiavolume
   4540  f596				  -	      endif		; TIAVOLUME
   4541  f596				  -	      endif		; RMTVOLUME
   4542  f596					      else		; !RMT
   4543  f596				  -	      ifconst	TIAVOLUME
   4544  f596				  -	      lda	#$F0	; default to full TIA volume
   4545  f596				  -	      sta	tiavolume
   4546  f596					      endif		; TIAVOLUME
   4547  f596					      endif		; RMT
   4548  f596
   4549  f596				  -	      ifconst	bankswitchmode
   4550  f596				  -			; we need to switch to the first bank as a default. this needs to
   4551  f596				  -			; happen before DMA, in case there's a topscreenroutine in bank 0
   4552  f596				  -	      ifconst	MCPDEVCART
   4553  f596				  -	      lda	#$18	; xxx11nnn - switch to bank 0
   4554  f596				  -	      ifconst	dumpbankswitch
   4555  f596				  -	      sta	dumpbankswitch
   4556  f596				  -	      endif
   4557  f596				  -	      sta	$3000
   4558  f596				  -	      else
   4559  f596				  -	      lda	#0
   4560  f596				  -	      ifconst	dumpbankswitch
   4561  f596				  -	      sta	dumpbankswitch
   4562  f596				  -	      endif
   4563  f596				  -	      sta	$8000
   4564  f596				  -	      endif
   4565  f596					      endif
   4566  f596
   4567  f596							; CTRL 76543210
   4568  f596							; 7 colorburst kill
   4569  f596							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   4570  f596							; 4 character width 1=2 byte chars, 0=1 byte chars
   4571  f596							; 3 border control 0=background color border, 1=black border
   4572  f596							; 2 kangaroo mode 0=transparency, 1=kangaroo
   4573  f596							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   4574  f596
   4575  f596				  -	      ifconst	DOUBLEWIDE
   4576  f596				  -	      lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   4577  f596					      else
   4578  f596		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
   4579  f598					      endif
   4580  f598
   4581  f598		       20 f0 f4 	      jsr	waitforvblankstart	; give the some vblank time to minimally update the display
   4582  f59b
   4583  f59b		       85 3c		      sta	CTRL
   4584  f59d		       8d 07 21 	      sta	sCTRL
   4585  f5a0
   4586  f5a0		       20 52 f4 	      jsr	vblankresync
   4587  f5a3
   4588  f5a3		       a2 01		      ldx	#1
   4589  f5a5		       20 1c f5 	      jsr	settwobuttonmode
   4590  f5a8		       a2 00		      ldx	#0
   4591  f5aa		       20 1c f5 	      jsr	settwobuttonmode
   4592  f5ad
   4593  f5ad					      ifnconst	.altgamestart
   4594  f5ad		       4c 00 80 	      jmp	game
   4595  f5b0				  -	      else
   4596  f5b0				  -	      jmp	.altgamestart
   4597  f5b0					      endif
   4598  f5b0
   4599  f5b0							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4600  f5b0
   4601  f5b0							;************** Setup DLL entries
   4602  f5b0
   4603  f5b0							; setup some working definitions, to avoid ifnconst mess elsewhere...
   4604  f5b0					      ifnconst	SCREENHEIGHT
   4605  f5b0		       00 c0	   WSCREENHEIGHT =	192
   4606  f5b0				  -	      else
   4607  f5b0				  -WSCREENHEIGHT =	SCREENHEIGHT
   4608  f5b0					      endif
   4609  f5b0
   4610  f5b0				  -	      ifnconst	ZONEHEIGHT
   4611  f5b0				  -WZONEHEIGHT =	16
   4612  f5b0					      else
   4613  f5b0		       00 08	   WZONEHEIGHT =	ZONEHEIGHT
   4614  f5b0					      endif
   4615  f5b0
   4616  f5b0					      ifnconst	ZONECOUNT
   4617  f5b0		       00 18	   WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   4618  f5b0				  -	      else
   4619  f5b0				  -WZONECOUNT =	ZONECOUNT
   4620  f5b0					      endif
   4621  f5b0
   4622  f5b0							; top of the frame, non-visible lines. this is based on NTSC,
   4623  f5b0							; but we add in extra NV lines at the end of the display to ensure
   4624  f5b0							; our PAL friends can play the game without it crashing.
   4625  f5b0		       00 19	   NVLINES    =	((243-WSCREENHEIGHT)/2)
   4626  f5b0
   4627  f5b0					      ifnconst	DLMEMSTART
   4628  f5b0					      ifnconst	DOUBLEBUFFER
   4629  f5b0		       18 80	   WDLMEMSTART =	$1880
   4630  f5b0				  -	      else
   4631  f5b0				  -WDLMEMSTART =	$18E0
   4632  f5b0					      endif		; DOUBLEBUFFER
   4633  f5b0				  -	      else
   4634  f5b0				  -WDLMEMSTART =	DLMEMSTART
   4635  f5b0					      endif
   4636  f5b0
   4637  f5b0					      ifnconst	DLMEMEND
   4638  f5b0				  -	      ifconst	EXTRADLMEMORY
   4639  f5b0				  -WDLMEMEND  =	$23FF
   4640  f5b0					      else
   4641  f5b0		       1f ff	   WDLMEMEND  =	$1FFF
   4642  f5b0					      endif
   4643  f5b0				  -	      else
   4644  f5b0				  -WDLMEMEND  =	DLMEMEND
   4645  f5b0					      endif
   4646  f5b0
   4647  f5b0
   4648  f5b0		       07 80	   WMEMSIZE   =	(WDLMEMEND-WDLMEMSTART+1)
   4649  f5b0
   4650  f5b0					      ifnconst	DOUBLEBUFFER
   4651  f5b0		       00 4b	   DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   4652  f5b0				  -	      else
   4653  f5b0				  -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   4654  f5b0					      endif
   4655  f5b0
   4656  f5b0		       00 4d	   TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   4657  f5b0				  -	      if	TDOUBLEBUFFEROFFSET > 255
   4658  f5b0				  -DOUBLEBUFFEROFFSET =	255
   4659  f5b0					      else
   4660  f5b0		       00 4d	   DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   4661  f5b0					      endif
   4662  f5b0
   4663  f5b0				  -	      ifconst	EXTRADLMEMORY
   4664  f5b0				  -SECONDDLHALFSTART SET	$2300
   4665  f5b0					      endif
   4666  f5b0
   4667  f5b0				   DLPOINTH
   4668  f5b0				   DLINDEX    SET	0
   4669  f5b0					      REPEAT	WZONECOUNT
   4670  f5b0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5b0				  -	      ifconst	EXTRADLMEMORY
   4672  f5b0				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5b0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5b0				  -	      else
   4675  f5b0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5b0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5b0				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5b0				  -	      endif
   4679  f5b0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5b0					      endif		; EXTRADLMEMORY
   4681  f5b0							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5b0		       18		      .byte.b	>TMPMEMADDRESS
   4683  f5b0				   DLINDEX    SET	DLINDEX + 1
   4669  f5b0					      REPEND
   4670  f5b0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5b1				  -	      ifconst	EXTRADLMEMORY
   4672  f5b1				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5b1				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5b1				  -	      else
   4675  f5b1				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5b1				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5b1				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5b1				  -	      endif
   4679  f5b1				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5b1					      endif		; EXTRADLMEMORY
   4681  f5b1							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5b1		       18		      .byte.b	>TMPMEMADDRESS
   4683  f5b1				   DLINDEX    SET	DLINDEX + 1
   4669  f5b1					      REPEND
   4670  f5b1				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5b2				  -	      ifconst	EXTRADLMEMORY
   4672  f5b2				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5b2				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5b2				  -	      else
   4675  f5b2				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5b2				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5b2				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5b2				  -	      endif
   4679  f5b2				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5b2					      endif		; EXTRADLMEMORY
   4681  f5b2							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5b2		       19		      .byte.b	>TMPMEMADDRESS
   4683  f5b2				   DLINDEX    SET	DLINDEX + 1
   4669  f5b2					      REPEND
   4670  f5b2				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5b3				  -	      ifconst	EXTRADLMEMORY
   4672  f5b3				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5b3				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5b3				  -	      else
   4675  f5b3				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5b3				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5b3				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5b3				  -	      endif
   4679  f5b3				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5b3					      endif		; EXTRADLMEMORY
   4681  f5b3							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5b3		       19		      .byte.b	>TMPMEMADDRESS
   4683  f5b3				   DLINDEX    SET	DLINDEX + 1
   4669  f5b3					      REPEND
   4670  f5b3				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5b4				  -	      ifconst	EXTRADLMEMORY
   4672  f5b4				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5b4				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5b4				  -	      else
   4675  f5b4				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5b4				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5b4				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5b4				  -	      endif
   4679  f5b4				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5b4					      endif		; EXTRADLMEMORY
   4681  f5b4							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5b4		       19		      .byte.b	>TMPMEMADDRESS
   4683  f5b4				   DLINDEX    SET	DLINDEX + 1
   4669  f5b4					      REPEND
   4670  f5b4				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5b5				  -	      ifconst	EXTRADLMEMORY
   4672  f5b5				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5b5				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5b5				  -	      else
   4675  f5b5				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5b5				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5b5				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5b5				  -	      endif
   4679  f5b5				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5b5					      endif		; EXTRADLMEMORY
   4681  f5b5							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5b5		       1a		      .byte.b	>TMPMEMADDRESS
   4683  f5b5				   DLINDEX    SET	DLINDEX + 1
   4669  f5b5					      REPEND
   4670  f5b5				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5b6				  -	      ifconst	EXTRADLMEMORY
   4672  f5b6				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5b6				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5b6				  -	      else
   4675  f5b6				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5b6				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5b6				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5b6				  -	      endif
   4679  f5b6				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5b6					      endif		; EXTRADLMEMORY
   4681  f5b6							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5b6		       1a		      .byte.b	>TMPMEMADDRESS
   4683  f5b6				   DLINDEX    SET	DLINDEX + 1
   4669  f5b6					      REPEND
   4670  f5b6				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5b7				  -	      ifconst	EXTRADLMEMORY
   4672  f5b7				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5b7				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5b7				  -	      else
   4675  f5b7				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5b7				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5b7				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5b7				  -	      endif
   4679  f5b7				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5b7					      endif		; EXTRADLMEMORY
   4681  f5b7							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5b7		       1a		      .byte.b	>TMPMEMADDRESS
   4683  f5b7				   DLINDEX    SET	DLINDEX + 1
   4669  f5b7					      REPEND
   4670  f5b7				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5b8				  -	      ifconst	EXTRADLMEMORY
   4672  f5b8				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5b8				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5b8				  -	      else
   4675  f5b8				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5b8				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5b8				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5b8				  -	      endif
   4679  f5b8				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5b8					      endif		; EXTRADLMEMORY
   4681  f5b8							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5b8		       1b		      .byte.b	>TMPMEMADDRESS
   4683  f5b8				   DLINDEX    SET	DLINDEX + 1
   4669  f5b8					      REPEND
   4670  f5b8				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5b9				  -	      ifconst	EXTRADLMEMORY
   4672  f5b9				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5b9				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5b9				  -	      else
   4675  f5b9				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5b9				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5b9				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5b9				  -	      endif
   4679  f5b9				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5b9					      endif		; EXTRADLMEMORY
   4681  f5b9							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5b9		       1b		      .byte.b	>TMPMEMADDRESS
   4683  f5b9				   DLINDEX    SET	DLINDEX + 1
   4669  f5b9					      REPEND
   4670  f5b9				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5ba				  -	      ifconst	EXTRADLMEMORY
   4672  f5ba				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5ba				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5ba				  -	      else
   4675  f5ba				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5ba				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5ba				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5ba				  -	      endif
   4679  f5ba				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5ba					      endif		; EXTRADLMEMORY
   4681  f5ba							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5ba		       1b		      .byte.b	>TMPMEMADDRESS
   4683  f5ba				   DLINDEX    SET	DLINDEX + 1
   4669  f5ba					      REPEND
   4670  f5ba				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5bb				  -	      ifconst	EXTRADLMEMORY
   4672  f5bb				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5bb				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5bb				  -	      else
   4675  f5bb				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5bb				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5bb				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5bb				  -	      endif
   4679  f5bb				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5bb					      endif		; EXTRADLMEMORY
   4681  f5bb							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5bb		       1b		      .byte.b	>TMPMEMADDRESS
   4683  f5bb				   DLINDEX    SET	DLINDEX + 1
   4669  f5bb					      REPEND
   4670  f5bb				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5bc				  -	      ifconst	EXTRADLMEMORY
   4672  f5bc				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5bc				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5bc				  -	      else
   4675  f5bc				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5bc				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5bc				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5bc				  -	      endif
   4679  f5bc				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5bc					      endif		; EXTRADLMEMORY
   4681  f5bc							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5bc		       1c		      .byte.b	>TMPMEMADDRESS
   4683  f5bc				   DLINDEX    SET	DLINDEX + 1
   4669  f5bc					      REPEND
   4670  f5bc				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5bd				  -	      ifconst	EXTRADLMEMORY
   4672  f5bd				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5bd				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5bd				  -	      else
   4675  f5bd				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5bd				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5bd				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5bd				  -	      endif
   4679  f5bd				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5bd					      endif		; EXTRADLMEMORY
   4681  f5bd							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5bd		       1c		      .byte.b	>TMPMEMADDRESS
   4683  f5bd				   DLINDEX    SET	DLINDEX + 1
   4669  f5bd					      REPEND
   4670  f5bd				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5be				  -	      ifconst	EXTRADLMEMORY
   4672  f5be				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5be				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5be				  -	      else
   4675  f5be				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5be				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5be				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5be				  -	      endif
   4679  f5be				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5be					      endif		; EXTRADLMEMORY
   4681  f5be							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5be		       1c		      .byte.b	>TMPMEMADDRESS
   4683  f5be				   DLINDEX    SET	DLINDEX + 1
   4669  f5be					      REPEND
   4670  f5be				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5bf				  -	      ifconst	EXTRADLMEMORY
   4672  f5bf				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5bf				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5bf				  -	      else
   4675  f5bf				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5bf				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5bf				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5bf				  -	      endif
   4679  f5bf				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5bf					      endif		; EXTRADLMEMORY
   4681  f5bf							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5bf		       1d		      .byte.b	>TMPMEMADDRESS
   4683  f5bf				   DLINDEX    SET	DLINDEX + 1
   4669  f5bf					      REPEND
   4670  f5bf				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5c0				  -	      ifconst	EXTRADLMEMORY
   4672  f5c0				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5c0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5c0				  -	      else
   4675  f5c0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5c0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5c0				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5c0				  -	      endif
   4679  f5c0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5c0					      endif		; EXTRADLMEMORY
   4681  f5c0							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5c0		       1d		      .byte.b	>TMPMEMADDRESS
   4683  f5c0				   DLINDEX    SET	DLINDEX + 1
   4669  f5c0					      REPEND
   4670  f5c0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5c1				  -	      ifconst	EXTRADLMEMORY
   4672  f5c1				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5c1				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5c1				  -	      else
   4675  f5c1				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5c1				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5c1				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5c1				  -	      endif
   4679  f5c1				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5c1					      endif		; EXTRADLMEMORY
   4681  f5c1							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5c1		       1d		      .byte.b	>TMPMEMADDRESS
   4683  f5c1				   DLINDEX    SET	DLINDEX + 1
   4669  f5c1					      REPEND
   4670  f5c1				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5c2				  -	      ifconst	EXTRADLMEMORY
   4672  f5c2				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5c2				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5c2				  -	      else
   4675  f5c2				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5c2				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5c2				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5c2				  -	      endif
   4679  f5c2				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5c2					      endif		; EXTRADLMEMORY
   4681  f5c2							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5c2		       1e		      .byte.b	>TMPMEMADDRESS
   4683  f5c2				   DLINDEX    SET	DLINDEX + 1
   4669  f5c2					      REPEND
   4670  f5c2				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5c3				  -	      ifconst	EXTRADLMEMORY
   4672  f5c3				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5c3				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5c3				  -	      else
   4675  f5c3				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5c3				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5c3				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5c3				  -	      endif
   4679  f5c3				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5c3					      endif		; EXTRADLMEMORY
   4681  f5c3							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5c3		       1e		      .byte.b	>TMPMEMADDRESS
   4683  f5c3				   DLINDEX    SET	DLINDEX + 1
   4669  f5c3					      REPEND
   4670  f5c3				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5c4				  -	      ifconst	EXTRADLMEMORY
   4672  f5c4				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5c4				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5c4				  -	      else
   4675  f5c4				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5c4				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5c4				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5c4				  -	      endif
   4679  f5c4				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5c4					      endif		; EXTRADLMEMORY
   4681  f5c4							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5c4		       1e		      .byte.b	>TMPMEMADDRESS
   4683  f5c4				   DLINDEX    SET	DLINDEX + 1
   4669  f5c4					      REPEND
   4670  f5c4				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5c5				  -	      ifconst	EXTRADLMEMORY
   4672  f5c5				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5c5				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5c5				  -	      else
   4675  f5c5				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5c5				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5c5				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5c5				  -	      endif
   4679  f5c5				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5c5					      endif		; EXTRADLMEMORY
   4681  f5c5							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5c5		       1f		      .byte.b	>TMPMEMADDRESS
   4683  f5c5				   DLINDEX    SET	DLINDEX + 1
   4669  f5c5					      REPEND
   4670  f5c5				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5c6				  -	      ifconst	EXTRADLMEMORY
   4672  f5c6				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5c6				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5c6				  -	      else
   4675  f5c6				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5c6				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5c6				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5c6				  -	      endif
   4679  f5c6				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5c6					      endif		; EXTRADLMEMORY
   4681  f5c6							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5c6		       1f		      .byte.b	>TMPMEMADDRESS
   4683  f5c6				   DLINDEX    SET	DLINDEX + 1
   4669  f5c6					      REPEND
   4670  f5c6				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4671  f5c7				  -	      ifconst	EXTRADLMEMORY
   4672  f5c7				  -	      if	TMPMEMADDRESS > $1FFF
   4673  f5c7				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4674  f5c7				  -	      else
   4675  f5c7				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4676  f5c7				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4677  f5c7				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4678  f5c7				  -	      endif
   4679  f5c7				  -	      endif		; TMPMEMADDRESS > $1FFF
   4680  f5c7					      endif		; EXTRADLMEMORY
   4681  f5c7							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4682  f5c7		       1f		      .byte.b	>TMPMEMADDRESS
   4683  f5c7				   DLINDEX    SET	DLINDEX + 1
   4684  f5c8					      REPEND
   4685  f5c8
   4686  f5c8				  -	      ifconst	EXTRADLMEMORY
   4687  f5c8				  -	      echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   4688  f5c8					      endif
   4689  f5c8
   4690  f5c8
   4691  f5c8				   DLPOINTL
   4692  f5c8				   DLINDEX    SET	0
   4693  f5c8					      REPEAT	WZONECOUNT
   4694  f5c8				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5c8				  -	      ifconst	EXTRADLMEMORY
   4696  f5c8				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5c8				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5c8				  -	      else
   4699  f5c8				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5c8				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5c8				  -	      endif
   4702  f5c8				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5c8					      endif		; EXTRADLMEMORY
   4704  f5c8		       80		      .byte.b	<TMPMEMADDRESS
   4705  f5c8				   DLINDEX    SET	DLINDEX + 1
   4693  f5c8					      REPEND
   4694  f5c8				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5c9				  -	      ifconst	EXTRADLMEMORY
   4696  f5c9				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5c9				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5c9				  -	      else
   4699  f5c9				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5c9				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5c9				  -	      endif
   4702  f5c9				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5c9					      endif		; EXTRADLMEMORY
   4704  f5c9		       d0		      .byte.b	<TMPMEMADDRESS
   4705  f5c9				   DLINDEX    SET	DLINDEX + 1
   4693  f5c9					      REPEND
   4694  f5c9				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5ca				  -	      ifconst	EXTRADLMEMORY
   4696  f5ca				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5ca				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5ca				  -	      else
   4699  f5ca				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5ca				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5ca				  -	      endif
   4702  f5ca				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5ca					      endif		; EXTRADLMEMORY
   4704  f5ca		       20		      .byte.b	<TMPMEMADDRESS
   4705  f5ca				   DLINDEX    SET	DLINDEX + 1
   4693  f5ca					      REPEND
   4694  f5ca				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5cb				  -	      ifconst	EXTRADLMEMORY
   4696  f5cb				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5cb				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5cb				  -	      else
   4699  f5cb				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5cb				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5cb				  -	      endif
   4702  f5cb				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5cb					      endif		; EXTRADLMEMORY
   4704  f5cb		       70		      .byte.b	<TMPMEMADDRESS
   4705  f5cb				   DLINDEX    SET	DLINDEX + 1
   4693  f5cb					      REPEND
   4694  f5cb				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5cc				  -	      ifconst	EXTRADLMEMORY
   4696  f5cc				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5cc				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5cc				  -	      else
   4699  f5cc				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5cc				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5cc				  -	      endif
   4702  f5cc				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5cc					      endif		; EXTRADLMEMORY
   4704  f5cc		       c0		      .byte.b	<TMPMEMADDRESS
   4705  f5cc				   DLINDEX    SET	DLINDEX + 1
   4693  f5cc					      REPEND
   4694  f5cc				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5cd				  -	      ifconst	EXTRADLMEMORY
   4696  f5cd				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5cd				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5cd				  -	      else
   4699  f5cd				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5cd				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5cd				  -	      endif
   4702  f5cd				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5cd					      endif		; EXTRADLMEMORY
   4704  f5cd		       10		      .byte.b	<TMPMEMADDRESS
   4705  f5cd				   DLINDEX    SET	DLINDEX + 1
   4693  f5cd					      REPEND
   4694  f5cd				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5ce				  -	      ifconst	EXTRADLMEMORY
   4696  f5ce				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5ce				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5ce				  -	      else
   4699  f5ce				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5ce				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5ce				  -	      endif
   4702  f5ce				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5ce					      endif		; EXTRADLMEMORY
   4704  f5ce		       60		      .byte.b	<TMPMEMADDRESS
   4705  f5ce				   DLINDEX    SET	DLINDEX + 1
   4693  f5ce					      REPEND
   4694  f5ce				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5cf				  -	      ifconst	EXTRADLMEMORY
   4696  f5cf				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5cf				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5cf				  -	      else
   4699  f5cf				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5cf				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5cf				  -	      endif
   4702  f5cf				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5cf					      endif		; EXTRADLMEMORY
   4704  f5cf		       b0		      .byte.b	<TMPMEMADDRESS
   4705  f5cf				   DLINDEX    SET	DLINDEX + 1
   4693  f5cf					      REPEND
   4694  f5cf				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5d0				  -	      ifconst	EXTRADLMEMORY
   4696  f5d0				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5d0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5d0				  -	      else
   4699  f5d0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5d0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5d0				  -	      endif
   4702  f5d0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5d0					      endif		; EXTRADLMEMORY
   4704  f5d0		       00		      .byte.b	<TMPMEMADDRESS
   4705  f5d0				   DLINDEX    SET	DLINDEX + 1
   4693  f5d0					      REPEND
   4694  f5d0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5d1				  -	      ifconst	EXTRADLMEMORY
   4696  f5d1				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5d1				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5d1				  -	      else
   4699  f5d1				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5d1				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5d1				  -	      endif
   4702  f5d1				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5d1					      endif		; EXTRADLMEMORY
   4704  f5d1		       50		      .byte.b	<TMPMEMADDRESS
   4705  f5d1				   DLINDEX    SET	DLINDEX + 1
   4693  f5d1					      REPEND
   4694  f5d1				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5d2				  -	      ifconst	EXTRADLMEMORY
   4696  f5d2				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5d2				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5d2				  -	      else
   4699  f5d2				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5d2				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5d2				  -	      endif
   4702  f5d2				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5d2					      endif		; EXTRADLMEMORY
   4704  f5d2		       a0		      .byte.b	<TMPMEMADDRESS
   4705  f5d2				   DLINDEX    SET	DLINDEX + 1
   4693  f5d2					      REPEND
   4694  f5d2				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5d3				  -	      ifconst	EXTRADLMEMORY
   4696  f5d3				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5d3				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5d3				  -	      else
   4699  f5d3				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5d3				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5d3				  -	      endif
   4702  f5d3				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5d3					      endif		; EXTRADLMEMORY
   4704  f5d3		       f0		      .byte.b	<TMPMEMADDRESS
   4705  f5d3				   DLINDEX    SET	DLINDEX + 1
   4693  f5d3					      REPEND
   4694  f5d3				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5d4				  -	      ifconst	EXTRADLMEMORY
   4696  f5d4				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5d4				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5d4				  -	      else
   4699  f5d4				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5d4				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5d4				  -	      endif
   4702  f5d4				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5d4					      endif		; EXTRADLMEMORY
   4704  f5d4		       40		      .byte.b	<TMPMEMADDRESS
   4705  f5d4				   DLINDEX    SET	DLINDEX + 1
   4693  f5d4					      REPEND
   4694  f5d4				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5d5				  -	      ifconst	EXTRADLMEMORY
   4696  f5d5				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5d5				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5d5				  -	      else
   4699  f5d5				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5d5				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5d5				  -	      endif
   4702  f5d5				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5d5					      endif		; EXTRADLMEMORY
   4704  f5d5		       90		      .byte.b	<TMPMEMADDRESS
   4705  f5d5				   DLINDEX    SET	DLINDEX + 1
   4693  f5d5					      REPEND
   4694  f5d5				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5d6				  -	      ifconst	EXTRADLMEMORY
   4696  f5d6				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5d6				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5d6				  -	      else
   4699  f5d6				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5d6				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5d6				  -	      endif
   4702  f5d6				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5d6					      endif		; EXTRADLMEMORY
   4704  f5d6		       e0		      .byte.b	<TMPMEMADDRESS
   4705  f5d6				   DLINDEX    SET	DLINDEX + 1
   4693  f5d6					      REPEND
   4694  f5d6				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5d7				  -	      ifconst	EXTRADLMEMORY
   4696  f5d7				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5d7				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5d7				  -	      else
   4699  f5d7				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5d7				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5d7				  -	      endif
   4702  f5d7				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5d7					      endif		; EXTRADLMEMORY
   4704  f5d7		       30		      .byte.b	<TMPMEMADDRESS
   4705  f5d7				   DLINDEX    SET	DLINDEX + 1
   4693  f5d7					      REPEND
   4694  f5d7				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5d8				  -	      ifconst	EXTRADLMEMORY
   4696  f5d8				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5d8				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5d8				  -	      else
   4699  f5d8				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5d8				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5d8				  -	      endif
   4702  f5d8				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5d8					      endif		; EXTRADLMEMORY
   4704  f5d8		       80		      .byte.b	<TMPMEMADDRESS
   4705  f5d8				   DLINDEX    SET	DLINDEX + 1
   4693  f5d8					      REPEND
   4694  f5d8				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5d9				  -	      ifconst	EXTRADLMEMORY
   4696  f5d9				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5d9				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5d9				  -	      else
   4699  f5d9				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5d9				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5d9				  -	      endif
   4702  f5d9				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5d9					      endif		; EXTRADLMEMORY
   4704  f5d9		       d0		      .byte.b	<TMPMEMADDRESS
   4705  f5d9				   DLINDEX    SET	DLINDEX + 1
   4693  f5d9					      REPEND
   4694  f5d9				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5da				  -	      ifconst	EXTRADLMEMORY
   4696  f5da				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5da				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5da				  -	      else
   4699  f5da				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5da				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5da				  -	      endif
   4702  f5da				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5da					      endif		; EXTRADLMEMORY
   4704  f5da		       20		      .byte.b	<TMPMEMADDRESS
   4705  f5da				   DLINDEX    SET	DLINDEX + 1
   4693  f5da					      REPEND
   4694  f5da				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5db				  -	      ifconst	EXTRADLMEMORY
   4696  f5db				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5db				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5db				  -	      else
   4699  f5db				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5db				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5db				  -	      endif
   4702  f5db				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5db					      endif		; EXTRADLMEMORY
   4704  f5db		       70		      .byte.b	<TMPMEMADDRESS
   4705  f5db				   DLINDEX    SET	DLINDEX + 1
   4693  f5db					      REPEND
   4694  f5db				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5dc				  -	      ifconst	EXTRADLMEMORY
   4696  f5dc				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5dc				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5dc				  -	      else
   4699  f5dc				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5dc				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5dc				  -	      endif
   4702  f5dc				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5dc					      endif		; EXTRADLMEMORY
   4704  f5dc		       c0		      .byte.b	<TMPMEMADDRESS
   4705  f5dc				   DLINDEX    SET	DLINDEX + 1
   4693  f5dc					      REPEND
   4694  f5dc				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5dd				  -	      ifconst	EXTRADLMEMORY
   4696  f5dd				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5dd				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5dd				  -	      else
   4699  f5dd				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5dd				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5dd				  -	      endif
   4702  f5dd				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5dd					      endif		; EXTRADLMEMORY
   4704  f5dd		       10		      .byte.b	<TMPMEMADDRESS
   4705  f5dd				   DLINDEX    SET	DLINDEX + 1
   4693  f5dd					      REPEND
   4694  f5dd				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5de				  -	      ifconst	EXTRADLMEMORY
   4696  f5de				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5de				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5de				  -	      else
   4699  f5de				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5de				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5de				  -	      endif
   4702  f5de				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5de					      endif		; EXTRADLMEMORY
   4704  f5de		       60		      .byte.b	<TMPMEMADDRESS
   4705  f5de				   DLINDEX    SET	DLINDEX + 1
   4693  f5de					      REPEND
   4694  f5de				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4695  f5df				  -	      ifconst	EXTRADLMEMORY
   4696  f5df				  -	      if	TMPMEMADDRESS > $1FFF
   4697  f5df				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4698  f5df				  -	      else
   4699  f5df				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4700  f5df				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4701  f5df				  -	      endif
   4702  f5df				  -	      endif		; TMPMEMADDRESS > $1FFF
   4703  f5df					      endif		; EXTRADLMEMORY
   4704  f5df		       b0		      .byte.b	<TMPMEMADDRESS
   4705  f5df				   DLINDEX    SET	DLINDEX + 1
   4706  f5e0					      REPEND
   4707  f5e0
   4708  f5e0
   4709  f5e0				   DLINDEX    SET	0
   4710  f5e0					      REPEAT	WZONECOUNT
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       18 80	   ZONE0ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       18 d0	   ZONE1ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       19 20	   ZONE2ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       19 70	   ZONE3ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       19 c0	   ZONE4ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1a 10	   ZONE5ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1a 60	   ZONE6ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1a b0	   ZONE7ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1b 00	   ZONE8ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1b 50	   ZONE9ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1b a0	   ZONE10ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1b f0	   ZONE11ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1c 40	   ZONE12ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1c 90	   ZONE13ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1c e0	   ZONE14ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1d 30	   ZONE15ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1d 80	   ZONE16ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1d d0	   ZONE17ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1e 20	   ZONE18ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1e 70	   ZONE19ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1e c0	   ZONE20ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1f 10	   ZONE21ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1f 60	   ZONE22ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4710  f5e0					      REPEND
   4711  f5e0				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4712  f5e0				  -	      ifconst	EXTRADLMEMORY
   4713  f5e0				  -	      if	TMPMEMADDRESS > $1FFF
   4714  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4715  f5e0				  -	      else
   4716  f5e0				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4717  f5e0				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4718  f5e0				  -	      endif
   4719  f5e0				  -	      endif		; TMPMEMADDRESS > $1FFF
   4720  f5e0					      endif		; EXTRADLMEMORY
   4721  f5e0
   4722  f5e0		       1f b0	   ZONE23ADDRESS =	TMPMEMADDRESS
   4723  f5e0
   4724  f5e0				   DLINDEX    SET	DLINDEX + 1
   4725  f5e0					      REPEND
   4726  f5e0
   4727  f5e0
     $1880 to $1fff used as zone memory, allowing 15 display objects per zone.
   4728  f5e0					      echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   4729  f5e0
   4730  f5e0				   DLHEIGHT
   4731  f5e0					      REPEAT	WZONECOUNT
   4732  f5e0		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5e0					      REPEND
   4732  f5e1		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5e1					      REPEND
   4732  f5e2		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5e2					      REPEND
   4732  f5e3		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5e3					      REPEND
   4732  f5e4		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5e4					      REPEND
   4732  f5e5		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5e5					      REPEND
   4732  f5e6		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5e6					      REPEND
   4732  f5e7		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5e7					      REPEND
   4732  f5e8		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5e8					      REPEND
   4732  f5e9		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5e9					      REPEND
   4732  f5ea		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5ea					      REPEND
   4732  f5eb		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5eb					      REPEND
   4732  f5ec		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5ec					      REPEND
   4732  f5ed		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5ed					      REPEND
   4732  f5ee		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5ee					      REPEND
   4732  f5ef		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5ef					      REPEND
   4732  f5f0		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5f0					      REPEND
   4732  f5f1		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5f1					      REPEND
   4732  f5f2		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5f2					      REPEND
   4732  f5f3		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5f3					      REPEND
   4732  f5f4		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5f4					      REPEND
   4732  f5f5		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5f5					      REPEND
   4732  f5f6		       07		      .byte.b	(WZONEHEIGHT-1)
   4731  f5f6					      REPEND
   4732  f5f7		       07		      .byte.b	(WZONEHEIGHT-1)
   4733  f5f8					      REPEND
   4734  f5f8
   4735  f5f8							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4736  f5f8
   4737  f5f8							; a simple guard, than ensures the 7800basic code hasn't
   4738  f5f8							; spilled into the encryption area...
     2438 bytes left in the 7800basic reserved area.
   4739  f5f8					      echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   4740  f5f8				  -	      if	(*>$FF7D)
   4741  f5f8				  -	      ERR		; abort the assembly
   4742  f5f8					      endif
   4743  f5f8							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4744  f5f8
   4745  f5f8				  -	      ifconst	DEV
   4746  f5f8				  -	      ifnconst	ZONEHEIGHT
   4747  f5f8				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   4748  f5f8				  -	      else
   4749  f5f8				  -	      if	ZONEHEIGHT = 8
   4750  f5f8				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   4751  f5f8				  -	      else
   4752  f5f8				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   4753  f5f8				  -	      endif
   4754  f5f8				  -	      endif
   4755  f5f8					      endif
   4756  f5f8
   4757  f5f8				  -	      if	START_OF_ROM = .
   4758  f5f8				  -	      .byte	0
   4759  f5f8					      endif
   4760  f5f8				   START_OF_ROM SET	0
   4761  f5f8
   4762  f5f8							; FF7E/FF7F contains the 7800basic crc checksum word
   4763  f5f8
   4764  f5f8							; FF80 - FFF7 contains the 7800 encryption key
   4765  f5f8
   4766  f5f8					      ifnconst	bankswitchmode
   4767  fff8					      ORG	$FFF8
   4768  fff8				  -	      else
   4769  fff8				  -	      ifconst	ROM128K
   4770  fff8				  -	      ORG	$27FF8
   4771  fff8				  -	      RORG	$FFF8
   4772  fff8				  -	      endif
   4773  fff8				  -	      ifconst	ROM144K
   4774  fff8				  -	      ORG	$27FF8
   4775  fff8				  -	      RORG	$FFF8
   4776  fff8				  -	      endif
   4777  fff8				  -	      ifconst	ROM256K
   4778  fff8				  -	      ORG	$47FF8
   4779  fff8				  -	      RORG	$FFF8
   4780  fff8				  -	      endif
   4781  fff8				  -	      ifconst	ROM272K
   4782  fff8				  -	      ORG	$47FF8
   4783  fff8				  -	      RORG	$FFF8
   4784  fff8				  -	      endif
   4785  fff8				  -	      ifconst	ROM512K
   4786  fff8				  -	      ORG	$87FF8
   4787  fff8				  -	      RORG	$FFF8
   4788  fff8				  -	      endif
   4789  fff8				  -	      ifconst	ROM528K
   4790  fff8				  -	      ORG	$87FF8
   4791  fff8				  -	      RORG	$FFF8
   4792  fff8				  -	      endif
   4793  fff8					      endif
   4794  fff8
   4795  fff8
   4796  fff8		       ff		      .byte.b	$FF	; region verification. $FF=all regions
   4797  fff9		       f7		      .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   4798  fffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   4799  fffa
   4800  fffa							;Vectors
   4801  fffa		       00 f0		      .word.w	NMI
   4802  fffc		       32 f5		      .word.w	START
   4803  fffe		       5f f0		      .word.w	IRQ
   4804  10000
